/////////////////////////////////////////////////////////////////
// TapirMail
//
// C program shell for rapid application development
// The Flying Pig!
// Started 17/7/2003
//////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////
// Includes

#include "oslib/osmodule.h"
#include "oslib/messagetrans.h"
#include "oslib/wimp.h"
#include "oslib/dragasprite.h"
#include "oslib/macros.h"
#include "oslib/osfile.h"
#include "oslib/osfind.h"
#include "oslib/osgbpb.h"
#include "oslib/resolver.h"
#include "oslib/osbyte.h"
#include "oslib/colourtrans.h"
#include "oslib/wimpspriteop.h"
#include "oslib/territory.h"
#include "oslib/osword.h"
#include "oslib/mimemap.h"

#include "flexlib/flex.h"

#include "TapirMail.h"
#include "Mime.h"
#include "md5.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#include <stddef.h>

#include "sys/byteorder.h"

#include "sys/select.h"

#include "Blowfish.h"

//#if defined _DEBUG
#include <clib/kernel.h>
//#endif

//////////////////////////////////////////////////////////////////
// Defines

#define WORDALIGN(b)         (((b) + 3) & ~3)
#define RANGE(var,min,max)   if ((var) < (min)) var = min; \
                             if ((var) > (max)) var = max;
#define DETAILS_MAX          (512)
#define EDIT_MAX             (30)
#define COLUMNS_MAX          (7)
#define ROW_HEIGHT           (40)
#define SENDER_MAX           (64)
#define SUBJECT_MAX          (128)
#define TO_MAX               (1024)
#define CC_MAX               (1024)
#define BCC_MAX              (1024)
#define COLUMN_XOFFSET       (0)
#define BUTTON_YOFFSET       (80)
#define HEADER_HEIGHT        (48)
#define ROW_YOFFSET          (BUTTON_YOFFSET + HEADER_HEIGHT)
#define MAIN_PANE_HEIGHT     (BUTTON_YOFFSET + HEADER_HEIGHT)
#define TEXT_X_OFFSET        (16)
#define MILLIPOINT           (400)
#define EMAIL_INVALID        (-1)
#define EDIT_INVALID         (-1)
#define EMAIL_TEXT_X_OFFSET  (4)
#define EMAIL_TEXT_Y_OFFSET  (128)
#define EDIT_TEXT_Y_OFFSET_MAX (172)
#define EDIT_TEXT_Y_OFFSET_MIN (116)
#define EDIT_HEAD_EXTENT_MAX (172)
#define EDIT_HEAD_EXTENT_MIN (116)
#define EMAIL_TEXT_WIDTH     (600)
#define EMAIL_CHAR_WIDTH     (77)
#define EMAIL_CHAR_XSIZE     (18)
#define INDENT_CYCLE         (4)
#define STYLE_BOLD           (1 << 0)
#define STYLE_ITALIC         (1 << 1)
#define STYLE_UNDERLINE      (1 << 2)
#define STYLE_STRIKE         (1 << 3)
#define STYLE_LINK           (1 << 4)
#define STYLE_HIDDEN         (1 << 5)
#define EDIT_CHARS_MAX       (1024)
#define EDIT_LINE_MAX        (1024)
#define DEFAULT_X_SCROLL     (32)
#define DEFAULT_Y_SCROLL     (32)

#define EDIT_CHARS_BLOCK     (1024)
#define EDIT_LINE_BLOCK      (1024)

#define EDIT_WIN_LINE_MIN    (30)
#define EMAIL_TEXT_X_SCROLL  (16)
#define RAMTRANSMIT_SIZE     (10 * 1024)
#define NULL_POLL_FAST       (1)
#define NULL_POLL_SLOW       (10)
#define NULL_POLL_SLOWEST    (20)
#define NULL_POLL_NETWORK    (5)
#define MAIN_WIN_MIN_HEIGHT  (ROW_YOFFSET + 1280)
#define SELECT_MEM_MIN       (1024)
#define UID_MAX              (80)
#define COMMAND_LEN          (1024)
#define COMMAND_LEN_QUEUE    (1032)
#define ACCOUNTS_SAVE        "<TapirMail$ChoicesWrite>.Accounts"
#define ACCOUNTS_SAVE_DIR    "<TapirMail$ChoicesWrite>"
#define ACCOUNTS_LOAD        "<TapirMail$ChoicesDir>.Accounts"

#define LICENSE_SAVE         "<TapirMail$LicenseWrite>.License"
#define LICENSE_SAVE_DIR     "<TapirMail$LicenseWrite>"
#define LICENSE_LOAD         "<TapirMail$LicenseDir>.License"

#define ADDRESS_SAVE         "<TapirMail$LicenseWrite>.Addresses"
#define ADDRESS_SAVE_DIR     "<TapirMail$LicenseWrite>"
#define ADDRESS_LOAD         "<TapirMail$LicenseDir>.Addresses"

#define COLUMN_GAP           (8)

#define BUFFERSIZE           (1024*5)
#define COMMANDSIZE          (1024*5)
#define Resolver_GetHost     (0x46001)
#define SENDER_MAX           (64)
#define SUBJECT_MAX          (128)
#define MESSAGE_INVALID      (-1)
#define ADDRESS_LEN_MAX      (256)
#define ADDRESS_NUM_MAX      (64)
#define CONNECTED_OFF_DELAY  (15)
#define POP3_TIMEOUT         (1 * 60 * 100)
#define SMTP_GENERIC_TIMEOUT (5 * 60 * 100)
#define SMTP_START_TIMEOUT   (5 * 60 * 100)
#define SMTP_MAIL_TIMEOUT    (5 * 60 * 100)
#define SMTP_RCPT_TIMEOUT    (5 * 60 * 100)
#define SMTP_DATA_TIMEOUT    (2 * 60 * 100)
#define SMTP_BLOCK_TIMEOUT   (3 * 60 * 100)
#define SMTP_TERMINATION_TIMEOUT  (10 * 60 * 100)
#define TERMINATION_TIMEOUT  (1 * 60 * 100)
#define SMTP_DATAEND_DELAY   (50)
#define STRING_LEN           (1024)
#define TITLE_LEN            (32)
#define PASS_LEN             (STRING_LEN / 2)
#define ACCOUNT_MAX          (20)
#define ACCOUNT_INVALID      (-1)
#define COLUMN_WIDTH_MAX     (1024)
#define COLUMN_REDRAW_ADD    (-0)
#define COLUMN_PTR           "ptr_autoscrh"
#define COLUMN_PTR_X         (15)
#define COLUMN_PTR_Y         (4)
#define DATE_FORMAT          "%ZDY %M3 %24:%MI"
#define OPENWIN_OFFSET       (-60)
#define OPENWIN_OFFSET_MAX   (300)
#define FORWARD_DATE_FORMAT  "%W3, %DY %M3 %CE%YR %24:%MI:%SE"
#define REPLY_DATE_FORMAT    "%W3, %DY %M3 %CE%YR"
#define CHAR_BASE            ('A')
#define MEMFILE_BLOCK        (4096)
#define MENU_XPOS_OFFSET     (-64)
#define ICONBAR_MENU_YPOS    (96 + 44 * 7 + 24 * 2)
#define ICONBAR_MENU_YPOS_R  (96 + 44 * 8 + 24 * 2)
#define REGISTERED           (334446)
#define UNREGISTERED         (874856)
#define CHECKSUM_INIT        (11786)
#define SERIAL_INVALID       (0)
#define MENU_ENTRY_NONE_LEN  (32)
#define FONT_LIST_MAX        (wimp_SIZEOF_MENU(1024))
#define FONT_LIST_IND_MAX    (1024 * 8)
#define FONT_NAME_LENGTH     (256)
#define ADDRESS_INVALID      (-1)
#define ADDRESS_NAME_MAX     (64)
#define ADDRESS_ADDRESS_MAX  (128)
#define ADDRESSES_NUM_MAX    (256)
#define ATTACHMENTS_NUM_MAX  (256)
#define ATTACH_MENU_BUF_SIZE (4096)
#define ATTACH_NUM_TEXT_MAX  (4)

#define ACCOUNT_OPEN_WIDTH   (724)
#define ACCOUNT_OPEN_HEIGHT  (948)
#define ACCOUNT_PANE_HEIGHT  (92)

#define CHOICES_OPEN_WIDTH   (724)
#define CHOICES_OPEN_HEIGHT  (936)
#define CHOICES_PANE_HEIGHT  (92)

#define SETTINGS_OPEN_WIDTH  (724)
#define SETTINGS_OPEN_HEIGHT (684)
#define SETTINGS_PANE_HEIGHT (92)

#define PAGE_SCROLL_Y_ADD    (-2)
#define SIG_LINE_NUM         (4)
#define SIG_LINE_LENGTH      (80)
#define REPLY_INSERT_LEN     (75)
#define EDIT_TITLE_LEN       (16)
#define SMILEY_MAX           (32)
#define SMILEY_NAME_LEN      (12)

#define ATTACHMENT_EDIT_MAX  (12)
#define FILETYPE_NAME_LEN    (8)
#define MIME_BOUNDARY_LEN    (34)
#define MIME_SUPPORT_LINES   (4)
#define ATTACHMENT_INFO_DATE_FORMAT  "\%24:\%mi:\%se \%dy-\%m3-\%ce\%yr"

//#define MAX_SEND_LEN         (64)

//////////////////////////////////////////////////////////////////
// Structures

typedef enum
{
  STATE_INVALID = -1,

  STATE_DISCONNECTED,

  STATE_CREATESOCKET,
  STATE_RESOLVING,
  STATE_CONNECT,
  STATE_CONNECTING,
  STATE_CONNECTED,

  STATE_POP3_AUTHORIZATION,
  STATE_POP3_TRANSACTION,
  STATE_POP3_QUIT,

  STATE_SMTP_AUTHORIZATION,
  STATE_SMTP_TRANSACTION,
  STATE_SMTP_QUIT,

  STATE_CANCEL,
  STATE_FINISHED,

  STATE_NUM
} STATE;

typedef enum
{
  DETAILS_INVALID = -1,

  DETAILS_NONE,
  DETAILS_SIZE,
  DETAILS_UID,
  DETAILS_FULL,
  DETAILS_DELETED,

  DETAILS_NUM
} DETAILS;

typedef enum
{
  AUTHSTATE_INVALID = -1,

  AUTHSTATE_NOSENT,
  AUTHSTATE_USERSENT,
  AUTHSTATE_PASSSENT,

  AUTHSTATE_HELOSENT,

  AUTHSTATE_AUTHLOGIN,
  AUTHSTATE_AUTHPLAIN,
  AUTHSTATE_AUTHCRAMMD5,
  AUTHSTATE_AUTHLOGINSENT,
  AUTHSTATE_AUTHPLAINSENT,
  AUTHSTATE_AUTHCRAMMD5SENT,

  AUTHSTATE_AUTHLOGINUSERSENT,

  AUTHSTATE_AUTHDONE,

  AUTHSTATE_NUM
} AUTHSTATE;

typedef enum
{
  POP3_TRANSTATE_INVALID = -1,

  POP3_TRANSTATE_NOSENT,
  POP3_TRANSTATE_STATSENT,
  POP3_TRANSTATE_LISTSENT,
  POP3_TRANSTATE_LIST,

  POP3_TRANSTATE_UIDLLISTSENT,
  POP3_TRANSTATE_UIDLLIST,
  POP3_TRANSTATE_UIDLLISTDESYNC,

  POP3_TRANSTATE_NEXTDETAILS,
  POP3_TRANSTATE_TOPSENT,
  POP3_TRANSTATE_TOPINTERPRET,

  POP3_TRANSTATE_NEXTDOWNLOAD,
  POP3_TRANSTATE_RETRUIDL,
  POP3_TRANSTATE_SENDRETR,

  POP3_TRANSTATE_RETRSENT,
  POP3_TRANSTATE_RETRINTERPRET,

  POP3_TRANSTATE_NEXTDELETE,
  POP3_TRANSTATE_DELEUIDL,
  POP3_TRANSTATE_SENDDELE,
  POP3_TRANSTATE_DELESENT,

  POP3_TRANSTATE_UIDDESYNC,
  POP3_TRANSTATE_RETRFAIL,
  POP3_TRANSTATE_DELEFAIL,
  POP3_TRANSTATE_DONE,

  POP3_TRANSTATE_NUM
} POP3_TRANSTATE;

typedef enum
{
  SMTP_TRANSTATE_INVALID = -1,

  SMTP_TRANSTATE_NOSENT,

  SMTP_TRANSTATE_MAILSENT,
  SMTP_TRANSTATE_RCPT,
  SMTP_TRANSTATE_RCPTSENT,
  SMTP_TRANSTATE_DATA,
  SMTP_TRANSTATE_DATASENT,
  SMTP_TRANSTATE_TEXT,
  SMTP_TRANSSTATE_TEXTSENT,

  SMTP_TRANSTATE_NEXTMAIL,

  SMTP_TRANSTATE_DONE,

  SMTP_TRANSTATE_NUM
} SMTP_TRANSTATE;

typedef enum
{
  SOCK_INVALID = -1,

  SOCK_OK,
  SOCK_ERR,
  SOCK_FAIL,
  SOCK_WAIT,
  SOCK_RECEIVE,
  SOCK_MULTIDONE,

  SOCK_NUM
} SOCK;

typedef enum
{
  NET_INVALID = -1,

  NET_POP3_LIST,
  NET_POP3_DELETE,
  NET_POP3_DOWNLOAD,

  NET_SMTP_SEND,

  NET_NUM
} NET;

typedef enum
{
  SMTP_SENDTEXT_INVALID = -1,

  SMTP_SENDTEXT_HEADERFROM,
  SMTP_SENDTEXT_HEADERTO,
  SMTP_SENDTEXT_HEADERCC,
  SMTP_SENDTEXT_HEADERSUBJECT,
  SMTP_SENDTEXT_HEADERDATE,
  SMTP_SENDTEXT_HEADERUSERAGENT,
  SMTP_SENDTEXT_HEADERMIME,
  SMTP_SENDTEXT_HEADERCONTENTTYPE,
  SMTP_SENDTEXT_HEADEREND,

  SMTP_SENDTEXT_MIMESUPPORT,
  SMTP_SENDTEXT_MIMESUPPORTEND,

  SMTP_SENDTEXT_EMAILBOUNDARY,
  SMTP_SENDTEXT_EMAILCONTENTTYPE,
  SMTP_SENDTEXT_EMAILHEADEREND,
  SMTP_SENDTEXT_EMAILTEXT,

  SMTP_SENDTEXT_ATTACHMENTS,

  SMTP_SENDTEXT_FAILED,
  SMTP_SENDTEXT_FINISH,
  SMTP_SENDTEXT_FINISHPAUSE,
  SMTP_SENDTEXT_DATAEND,
  SMTP_SENDTEXT_FINISHED,

  SMTP_SENDTEXT_NUM
} SMTP_SENDTEXT;

typedef enum
{
  SMTP_ATTACHMENTS_INVALID = -1,

  SMTP_ATTACHMENTS_START,

  SMTP_ATTACHMENTS_STARTATTACHMENT,
  SMTP_ATTACHMENTS_BOUNDARY,
  SMTP_ATTACHMENTS_HEADERCONTENTTYPE,
  SMTP_ATTACHMENTS_HEADERCONTENTTYPEATTRIBUTES,
  SMTP_ATTACHMENTS_HEADERCONTENTDISPOSITION,
  SMTP_ATTACHMENTS_HEADERCONTENTENCODING,
  SMTP_ATTACHMENTS_HEADEREND,

  SMTP_ATTACHMENTS_DATA,
  SMTP_ATTACHMENTS_DATAEND,

  SMTP_ATTACHMENTS_FINALGAP,
  SMTP_ATTACHMENTS_FINALBOUNDARY,

  SMTP_ATTACHMENTS_FAILED,
  SMTP_ATTACHMENTS_FINISH,

  SMTP_ATTACHMENTS_NUM
} SMTP_ATTACHMENTS;

typedef enum
{
  QUITSTATE_INVALID = -1,

  QUITSTATE_QUIT,
  QUITSTATE_QUITSENT,

  QUITSTATE_NUM
} QUITSTATE;

typedef enum
{
  CONNECTED_INVALID = -1,

  CONNECTED_OFF,
  CONNECTED_WAITING,
  CONNECTED_SENDING,
  CONNECTED_RECEIVING,

  CONNECTED_NUM
} CONNECTED;

typedef enum
{
  MAILSTATE_INVALID = -1,

  MAILSTATE_LOCAL,
  MAILSTATE_GETTING,
  MAILSTATE_REMOTE,
  MAILSTATE_DELETING,

  MAILSTATE_NUM
} MAILSTATE;

typedef enum
{
  PANE_INVALID = -1,

  PANE_NONE,
  PANE_TOP,
  PANE_BASE,

  PANE_NUM
} PANE;

typedef enum
{
  SMTPAUTH_INVALID = -1,

  SMTPAUTH_NONE,
  SMTPAUTH_PLAIN,
  SMTPAUTH_LOGIN,
  SMTPAUTH_CRAMMD5,

  SMTPAUTH_NUM
} SMTPAUTH;










typedef struct _Details
{
  bool                        boSelected;
  int                         nMsgNum;
  int                         nSize;
  int                         nServerSize;
  char                        szSender[SENDER_MAX];
  char                        szSenderDisplay[SENDER_MAX];
  char                        szSubject[SUBJECT_MAX];
  char                        pcDate[5];
  DETAILS                     eState;
  wimp_w                      whWindow;
  wimp_w                      whHead;
  char                        *szRawEmail;
  char                        *szFormEmail;
  int                         nHeaderEndLine;
  int                         nLineHide;
  int                         *anLine;
  int                         *anRawLine;
  int                         nLineMax;
  bool                        boOpenOnLoad;
  char                        szUID[UID_MAX];
  int                         nSortPos;
  wimp_i                      ihSenderIcon;
  wimp_i                      ihSubjectIcon;
  MAILSTATE                   eMailState;
  MIMEDetails                 *asMIMEList;
  int                         nMIMEListNum;
  char                        *szPreMIMEEmail;
  int                         nPreMIMESize;
  char                        szAttachNum[ATTACH_NUM_TEXT_MAX];
  wimp_i                      ihAttNumIcon;
} Details;

typedef struct _Edit
{
  int                         nSize;
  char                        szTo[TO_MAX];
  char                        szSubject[SUBJECT_MAX];
  char                        szCC[CC_MAX];
  char                        szBCC[BCC_MAX];
  wimp_w                      whWindow;
  wimp_w                      whHead;
  char                        *szRawEmail;
  char                        *szFormEmail;
  int                         *anLine;
  int                         nLineMax;
  int                         nFormattedTo;
  bool                        boInsert;
  bool                        boLineChange;
  bool                        boAdvanced;
  int                         nTextOffset;
  bool                        boChanged;
  char                        szWinTitle[EDIT_TITLE_LEN];

  int                         nEmailMem;
  int                         nLineMem;

  char                        szAttachNum[ATTACH_NUM_TEXT_MAX];
  int                         nMIMEListNum;
  MIMEEditDetails             asAttachments[ATTACHMENT_EDIT_MAX];
} Edit;

typedef struct _Selection
{
  bool                        boEdit;
  wimp_w                      whWindow;
  int                         nEmailNum;
  int                         nLineStart;
  int                         nCharStart;
  int                         nLineEnd;
  int                         nCharEnd;

} Selection;

typedef struct _Caret
{
  wimp_w                      whWindow;
  int                         nEditNum;
  int                         nLine;
  int                         nChar;
  int                         nPos;
  int                         nXPos;
  int                         nYPos;
  int                         nCharPref;

} Caret;

typedef struct _Account
{
  char                        szTitle[TITLE_LEN];
  char                        szName[STRING_LEN];
  char                        szEmailAddress[STRING_LEN];
  char                        szPOP3Server[STRING_LEN];
  int                         nPOP3Port;
  char                        szPOP3Username[STRING_LEN];
  bool                        boPOP3RememberPassword;
  bool                        boPOP3GotPassword;
  char                        szPOP3Password[PASS_LEN];
  char                        szSMTPServer[STRING_LEN];
  int                         nSMTPPort;
  bool                        boBCCToSelf;
  bool                        boCCBCC;
  char                        szBCCAddress[STRING_LEN];

  SMTPAUTH                    eSMTPAuth;
  bool                        boSMTPUsePOP3Details;
  char                        szSMTPUsername[STRING_LEN];
  bool                        boSMTPRememberPassword;
  bool                        boSMTPGotPassword;
  char                        szSMTPPassword[PASS_LEN];
  char                        szSigLine[SIG_LINE_NUM][SIG_LINE_LENGTH];
} Account;

typedef struct _MemFile
{
  char                        *pcMemory;
  int                         nSize;
  int                         nPos;
  char                        cMode;
  char                        szFilename[1024];
} MemFile;

typedef struct _Address
{
  char                        szName[ADDRESS_NAME_MAX];
  char                        szAddress[ADDRESS_ADDRESS_MAX];
} Address;

typedef struct _Smiley
{
  char                        szName[SMILEY_NAME_LEN];
  int                         nNameLength;
  int                         nOffset;
} Smiley;

typedef enum _SAVETYPE
{
  SAVETYPE_INVALID = -1,

  SAVETYPE_FILE,
  SAVETYPE_EMAILS,
  SAVETYPE_ICONTEXT,
  SAVETYPE_SELECTCHOOSE,
  SAVETYPE_COLUMN,
  SAVETYPE_SELECTSAVE,
  SAVETYPE_CLIPBOARD,
  SAVETYPE_ATTACHMENT,

  SAVETYPE_NUM
} SAVETYPE;

typedef enum _LOADTYPE
{
  LOADTYPE_INVALID = -1,

  LOADTYPE_EDITTEXT,
  LOADTYPE_EDITMIME,

  LOADTYPE_NUM
} LOADTYPE;

typedef enum
{
  RELPOS_INVALID = -1,

  RELPOS_BEFORE,
  RELPOS_WITHINSTART,
  RELPOS_WITHINEND,
  RELPOS_AFTER,
  RELPOS_OTHEREMAIL,

  RELPOS_NUM
} RELPOS;

typedef enum _NULLPOLL
{
  NULLPOLL_INVALID = -1,

  NULLPOLL_ACTIVE_FAST,
  NULLPOLL_ACTIVE_SLOW,
  NULLPOLL_DEACTIVE_FAST,
  NULLPOLL_DEACTIVE_SLOW,

  NULLPOLL_ACTIVE_NETWORK,
  NULLPOLL_DEACTIVE_NETWORK,

  NULLPOLL_RESET,

  NULLPOLL_NUM
} NULLPOLL;

typedef enum _QUERYACTION
{
  QUERYACTION_INVALID = -1,
  QUERYACTION_NONE,

  QUERYACTION_STOP,
  QUERYACTION_DELETEACCOUNT,
  QUERYACTION_DELETEEMAILS,
  QUERYACTION_DELETEADDRESS,
  QUERYACTION_QUIT,
  QUERYACTION_CLOSEEDIT,

  QUERYACTION_NUM
} QUERYACTION;

typedef enum _ADDRESSMENU
{
  ADDRESSMENU_INVALID = -1,

  ADDRESSMENU_ADDRESSES,
  ADDRESSMENU_TO,
  ADDRESSMENU_CC,
  ADDRESSMENU_BCC,

  ADDRESSMENU_NUM
} ADDRESSMENU;

typedef enum _DELETETYPE
{
  DELETETYPE_INVALID = -1,

  DELETETYPE_GUESS,
  DELETETYPE_OS4,
  DELETETYPE_OS5,

  DELETETYPE_NUM
} DELETETYPE;

//////////////////////////////////////////////////////////////////
// Global variables

static int                    gnWimpVersion;
static wimp_poll_flags        guPollFlags;
static char                   gpcTemp[256];
static char                   *gpcMessages;
static wimp_w                 gwhMain;
static wimp_w                 gwhSave;
static wimp_w                 gwhWarn;
static wimp_w                 gwhText;
static wimp_w                 gwhEdit;
static wimp_w                 gwhEdHe;
static wimp_w                 gwhEmHe;
static wimp_w                 gwhMaHe;
static wimp_w                 gwhQery;
static wimp_w                 gwhAcct;
static wimp_w                 gwhLogn;
static wimp_w                 gwhUnLk;
static wimp_w                 gwhChce;
static wimp_w                 gwhRegi;
static wimp_w                 gwhSett;
static wimp_w                 gwhAddr;
static wimp_w                 gwhAttc;
static wimp_w                 gwhAcBa;
static wimp_w                 gwhEdAt;

static wimp_w                 gwhChBa;
static wimp_w                 gwhSeBa;


static wimp_i                 gihIconBarIcon;
static int                    gnMenuWins = 0;
static wimp_w                 gawhMenuWinHandle[10];
static int                    gnMenuXpos = 0;
static int                    gnMenuYpos = 0;
static wimp_menu              *gpcMenuCurrent = NULL;
static wimp_menu              *gpcIconBarMenu;
static wimp_menu              *gpcMainMenu;
static wimp_menu              *gpcEmailMenu;
static wimp_menu              *gpcLognMenu;
static wimp_menu              *gpcAcctMenu;
static wimp_menu              *gpcNewMenu;
static wimp_menu              *gpcMainSelMenu;
static wimp_menu              *gpcMainSendMenu;
static wimp_menu              *gpcMainHiMenu;
static wimp_menu              *gpcMainAcMenu;
static wimp_menu              *gpcEmailEditMenu;
static wimp_menu              *gpcEmailSendMenu;
static wimp_menu              *gpcNewEditMenu;
static wimp_menu              *gpcChoiceAcctMenu;
static wimp_menu              *gpcLocalFontMenu;
static wimp_menu              *gpcRemoteFontMenu;
static wimp_menu              *gpcAddrMenu;
static wimp_menu              *gpcAttcMenu;
static wimp_menu              *gpcEditAttcMenu;
char                          *gpcAcctMenuBuffer;
char                          *gpcAddrMenuBuffer;
char                          *gpcFontMenuBuffer;
char                          *gpcAttcMenuBuffer;
char                          *gpcEdAtMenuBuffer;
static wimp_t                 gnTaskHandle;
static bool                   gboDrag = FALSE;
static char                   gacFontRef[256];
static int                    gnMessageMyRef = 0;
static SAVETYPE               geSaveType = SAVETYPE_INVALID;
static LOADTYPE               geLoadType = LOADTYPE_INVALID;
static int                    gnSaveFileType;
static char                   gszSaveString[255];
static font_f                 ghFont;
static font_f                 ghFontB;
static font_f                 ghEmailFont;
static font_f                 ghEmailBFont;
static font_f                 ghEmailIFont;
static font_f                 ghEmailBIFont;

static int                    gnDetailsNum;
static int                    gnEditNum;
static Details                gasDetails[DETAILS_MAX];
static Edit                   gasEdit[EDIT_MAX];

static int                    ganSort[DETAILS_MAX + 1];

static int                    ganColWidth[COLUMNS_MAX];
static int                    gnRowHeight;
static int                    gnTextYOffset;
static int                    gnEmailRowHeight;
static int                    gnEmailTextYOffset;
static int                    gnEmailTextWidth;
static int                    gnEllipsisWidth;
static int                    gnEllipsisWidthB;
static wimp_w                 gawhEmailsOpen[DETAILS_MAX + 1];
static int                    ganEmailsOpen[DETAILS_MAX + 1];
static wimp_w                 gawhEditOpen[EDIT_MAX + 1];
static int                    ganEditOpen[EDIT_MAX + 1];

static int                    ganEmailSave[DETAILS_MAX];
static bool                   gboEditSave;
static int                    gnEmailSaveNum;
static int                    gnEmailSavePos;

static os_colour              gauIndCol[] = {os_COLOUR_LIGHT_BLUE,
                                             os_COLOUR_DARK_BLUE,
                                             os_COLOUR_LIGHT_RED,
                                             os_COLOUR_DARK_GREEN};
static Selection              gsSelect;
static int                    gnSelectLineStart;
static int                    gnSelectCharStart;
static int                    gnEmailSelected;
static bool                   gboEditSelected;
static int                    gnEditSaveSelected;
static Caret                  gsCaret;
static char                   *gpcCopySelect;
static int                    gnCopySelectSize;
static bool                   gboCaretLost;
static int                    gnMyRef;
static bool                   gboDelete;
static bool                   gboClipClaimed;
static char                   *gpcClipboard;
static int                    gnClipboardSize;
static wimp_message_data_xfer gsMessageStore;
static wimp_t                 gthSender;
static char                   gpcRamTransBuffer[RAMTRANSMIT_SIZE];
static int                    gnRamTransRef;
static char *                 gpcRamTransPos;
static int                    gnRamTransEmailPos;
static int                    gnRamTransAttcPos;
static int                    gnRamTransLeft;
static int                    gnFastPollAcc;
static int                    gnSlowPollAcc;
static bool                   gboNetworkPoll;
static bool                   gboPointerEdit;
static int                    gnPointerEmail;
static bool                   gboLinkPointer;
static bool                   gboColumnPointer;
static os_t                   gnMonotonicTime;
static os_t                   gnTimeInc;
static osspriteop_area        *gpcSprites;
static osspriteop_area        *gpcEmoticons;
static os_t                   gnSMTPPause;



static char                  gszServer[COMMAND_LEN - 5];
static char                  gpcBuffer[BUFFERSIZE];
static int                   gnBufferStart = 0;
static char                  gpcCommand[COMMANDSIZE];
//static char                  gszCommand[COMMAND_LEN];
static AUTHSTATE             geAuthState = AUTHSTATE_INVALID;
static POP3_TRANSTATE        gePOP3TranState = POP3_TRANSTATE_INVALID;
static SMTP_TRANSTATE        geSMTPTranState = SMTP_TRANSTATE_INVALID;
static QUITSTATE             geQuitState = QUITSTATE_INVALID;
static int                   gnCurrentMsg;

#if defined _DEBUG
static STATE                 gePrevState = STATE_INVALID;
#endif
static STATE                 geState = STATE_INVALID;
static int                   gnAddress;
static socket_s              gsSocket;

static int                   ganRETRAct[DETAILS_MAX + 1];
static int                   gnRETRActNum;
static int                   gnRETRActPos;
static int                   ganMAILAct[DETAILS_MAX + 1];
static int                   gnMAILActNum;
static int                   gnMAILActPos;
static int                   gnMAILActLine;
static int                   ganDELEAct[DETAILS_MAX + 1];
static int                   gnDELEActNum;
static int                   gnDELEActPos;

static Account               gasAccount[ACCOUNT_MAX];
static int                   gnAccount;
static int                   gnAccountNum;
static int                   gnAccountDialogue;
static int                   gnAccountSettingsDialogue;
static int                   gnAccountLogin;

static NET                   geNetCom;
static int                   gnDownloadPos;
static int                   gnPort;
static char                  gaszToAddress[ADDRESS_LEN_MAX][ADDRESS_NUM_MAX];
static int                   gnToAddressNum;
static int                   gnCCAddressNum;
static int                   gnBCCAddressNum;
static int                   gnAllAddressNum;
static int                   gnToAddressPos;
static SMTP_SENDTEXT         geSMTPSendTextState;
static char                  *gpcCurrentEmail;
static char                  gszProgTitle[128];
static int                   gnTotalMailSize;
static int                   gnTotalMailSizeTemp;
static CONNECTED             geConnectStatus;
static os_t                  gnLastSendRecTime;
static os_t                  gnTimeoutTime;
static int                   gnDragColumn;
static int                   gnColumnXPosStart;
static int                   gnOpenOffset;
static int                   gnSelected;
static bool                  gboTentativeSelection;
static bool                  gboAccountsLoaded;
static char                  gszUnlockPassword[1024];
static char                  gszDateFormat[1024];
static bool                  gboLog;
static QUERYACTION           geQueryAction;
static int                   gnRegistered = UNREGISTERED;
static char                  gszName[256];
static unsigned int          guSerial = SERIAL_INVALID;
static int                   gnDefaultAccount = ACCOUNT_INVALID;
static int                   gnDefaultAccountDisplay = ACCOUNT_INVALID;
static char                  gszFont[FONT_NAME_LENGTH] = "Trinity.Medium";
static char                  gszFontB[FONT_NAME_LENGTH] = "Trinity.Bold";
static char                  gszLocalChoiceFont[FONT_NAME_LENGTH] = "";
static char                  gszRemoteChoiceFont[FONT_NAME_LENGTH] = "";
static int                   gnAddress = ADDRESS_INVALID;
static Address               gasAddresses[ADDRESSES_NUM_MAX];
static int                   gnAddressNum;
static ADDRESSMENU           geAddressMenuType;
static int                   gnAttachmentNum;
static bool                  gboSMTPAuthLOGIN;
static bool                  gboSMTPAuthPLAIN;
static bool                  gboSMTPAuthCRAMMD5;
static char                  gacBase16[16] = "0123456789abcdef";
static int                   gnEmailCharWidth = EMAIL_CHAR_XSIZE;
static wimp_w                gwhWindowClose;
static DELETETYPE            geDeleteTypeConfig;
static bool                  gboIyonixDelete;
static osspriteop_trans_tab  *gpsTransTable = NULL;
static int                   gnSmileyNum;
static Smiley                gasSmileys[SMILEY_MAX];
static bool                  gboEmoticons;
static char                  gszLoadFileName[MIME_FILENAME_MAX];
static int                   gnLoadFileType = 0;
static char                  gszMIMEBoundary[MIME_BOUNDARY_LEN];
static SMTP_ATTACHMENTS      geSMTPAttachmentsState;
static int                   gnSMTPAttachmentsNum;
static int                   gnSMTPAttachmentsPos;
static char                  gszSendCommand[COMMAND_LEN_QUEUE];
static int                   gnSendCommandSent;
static int                   gnSendCommandLen;
static socket_s              gsSendSocket;
static bool                  gboUIDDesync;
static char gacBoundaryCharList[64]
  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
#if defined _DEBUG
static int                   gnDebugQueued = 0;
static int                   gnDebugSent = 0;
#endif
#if defined MAX_SEND_LEN
static int                   gnMaxSendLen = MAX_SEND_LEN;
static int                   gnNullPollNetwork = NULL_POLL_NETWORK;
static bool                  gboFastSending = FALSE;
#endif

//////////////////////////////////////////////////////////////////
// Main application

void RedrawWindow (wimp_block *pcBlock);
void RedrawMain (wimp_draw *psRedraw);
void SetMainExtent (int nEmailMax);
void ClearAllSelected (void);
int EmailRow (int nYPos);
void ToggleSelectRow (int nRow);
void CreateEmailWindow (int nEmailNum);
void RedrawEmail (wimp_draw *psRedraw, int nEmailNum);
int CreateFormattedEmail (int nEmailNum);
void InsertEmailColour (char *szFormatted, int * pnMemory, os_colour uCol, os_colour uBack);
int CopyFormatted (char * szFrom, char * szTo, int nLen, os_colour uCol, os_colour uBack);
void CheckStyles (char * szWordStart, char * szWordEnd, unsigned int * puStyles);
void SelectReOrder (Selection *psSelection);
void InvertSelection (Selection * psSelect, wimp_draw *psRedraw);
void ChangeSelection (Selection * psNew);
void FindEmailCoords (int nEmailNum, int nXPos, int nYPos, int * pnLine, int * pnChar);
void DragSelectionBox (bool boEdit, int nEmailNum, int nXPos, int nYPos);
void NullPoll (wimp_block *pcBlock);
RELPOS PointRelativeSelection (bool boEdit, int nEmailNum, int nXPos, int nYPos, Selection * psSelect, int * pnLine, int * pnChar);
int CreateEditWindow (void);
int CreateEditWindowAddress (char * szAddress);
void RedrawEdit (wimp_draw *psRedraw, int nEditNum);
int FormatLines (int nEditNum, int nLineStart, int nLineEnd);
void ReFormat (int nEditNum, int nChangedLine, int nLineEnd, int * psStartLine, int * psEndLine);
void FindEditCoords (int nEditNum, int nXPos, int nYPos, int * pnLine, int * pnChar);
void SetCaretPos (int nEditNum, int nLine, int nChar);
void InsertChar (int nEditNum, int nPos, int nLine, char cChar);
void UpdateEditWindow (int nEditNum, int nStartLine, int nEndLine);
void MoveCaretRight (int nRight);
void MoveCaretLeft (int nLeft);
void MoveCaretDown (int nDown);
void MoveCaretUp (int nUp);
void DeleteChar (int nEditNum, int nPos, int nLine);
void DragCentred (int nXPos, int nYPos, char * szIconName);
bool DeleteSection (int nEditNum, Selection * psSelect);
void ShiftSelection (Caret * psCaretPre, Caret * psCaret);
void SearchCaretRight (char * szSearch);
void SearchCaretLeft (char * szSearch);
void InsertString (int nEditNum, int nPos, int nLine, char * szString);
void ShiftLines (int nEditNum, int nLineStart, int nLine, int nChar);
void LoseCaret (wimp_block *pcBlock);
void ScrollRequest (wimp_block *pcBlock);
void CreateEditSelect (int nEditNum, bool boEdit, char ** ppcMem, int * pnSize);
int CountNonControl (char * szString, int nLength);
void ClearCaret (void);
void InsertText (int nEditNum, int nPos, int nLine, char * szString, int nLength);
void InsertTextFlex (int nEditNum, int nPos, int nLine, char * * pszString, int nLength);
void ClearSelection (void);
void SetEditHeight (int nEditNum, int nLine);
void CopySelectToClip (void);
void ClearClipboard (void);
void DataRequest (wimp_block * pcBlock);
void ClaimEntity (wimp_block * pcBlock);
void LaunchURL (wimp_block * pcBlock);
void PasteClipboard (void);
void ScrollWindowToCaret (void);
void RamFetchReturned (wimp_block *pcBlock);
void SetNullPollActive (bool boActive);
void PointerEntering (wimp_block * pcBlock);
void PointerLeaving (wimp_block * pcBlock);
void FindWordAtCoords (bool boEdit, int nEmailNum, int nXPos, int nYPos, char ** pszWordStart, char ** pszWordEnd);
bool WordIsLink (char * szWordStart, char * szWordEnd);
int WordIsSmiley (char * szWordStart, char * szWordEnd);
void ClickOnURL (bool boEdit, int nEmailNum, int nXPos, int nYPos);
void PlotSmileys(font_f hFont, char *szPlotLine, int nXPos, int nYPos, int nPlotLen);
void OpenWindowInitPane (wimp_w whWindow, wimp_w whPane, PANE ePaneType);
void OpenWindowInitPaneCentreSize (wimp_w whWindow, wimp_w whPane, PANE ePaneType, int nWidth, int nHeight);
void OpenWindowInitPaneNew (wimp_w whWindow, wimp_w whPane, PANE ePaneType);
void ShowHeader (int nEmailNum, bool boShow);
void RedrawMainHead (wimp_draw *psRedraw);
void UpdateMain (int nRowStart, int nRowEnd);
void CompileSelectedList (void);
void DestroyEditWindow (int nEditNum);
char * TagArg (char * szTag, char * szArg0);
void ShowWarningTagArg (char * szTag, char * szArg0);
void SendEmail (int nEditNum);
void DestroyEmailWindow (int nEmailNum);
void DestroySelectedEmails (void);
void DeleteMultipleEmails (int nStartEmail, int nEndEmail);
void DeleteEmailDetails (int nEmailNum);
void RenumberQueues (int nDeletedEmail);
void SetIconSprite (char * szSprite, wimp_w whWindow, wimp_i ihIcon);
wimp_w LoadTemplateMaHe (char * szWindowTitle, osspriteop_area * pcSpriteArea);
STATE ImmediateUpdate (socket_s * psSocket);
void ShowQueryTag (char * szTag, char * szContinueTag, char * szCancelTag, QUERYACTION eAction);
void ShowQueryTagVolatile (char * szTag, char * szContinueTag, char * szCancelTag, QUERYACTION eAction);
void CloseQuery (void);
void ClearAccountDetails (int nAccount);
void SetAccountDetails (int nAccount);
void SetAccountSettingsDetails (int nAccount);
void SetAccountDialogue (int nAccount);
void SetAccountSettingsDialogue (int nAccount);
void GenerateAccountMenu (wimp_menu * pcMenu);
void OpenLoginMenu (void);
void OpenLoginWindow (int nShowAccount);
void SetLoginWindow (int nShowAccount);
void SetupIconbarMenu (void);
void MenuSelectIconbarAccount (int nAccount);
void LoginAccount (int nAccount);
void OpenMainLoginMenu (void);
void SaveAccountDetails (void);
void SaveSection (FILE * pfhFile, char * szSection);
void SaveDetail (FILE * pfhFile, char * szName, char * szDetails);
bool LoadAccountDetails (void);
int FindSection (FILE * pfhFile, char * szSection);
bool FindValue (FILE * pfhFile, int nSection, char * szName, char * szValue, int nValueLen);
void MouseClickMaHeWorkArea (int nXPos, int nYPos, int nButton);
void SortEmails (bool (*Compare)(int, int));
bool CompareSizeIncreasing (int nEmail1, int nEmail2);
bool CompareSizeDecreasing (int nEmail1, int nEmail2);
bool CompareMsgNumIncreasing (int nEmail1, int nEmail2);
bool CompareMsgNumDecreasing (int nEmail1, int nEmail2);
bool CompareSenderIncreasing (int nEmail1, int nEmail2);
bool CompareSenderDecreasing (int nEmail1, int nEmail2);
bool CompareSubjectIncreasing (int nEmail1, int nEmail2);
bool CompareSubjectDecreasing (int nEmail1, int nEmail2);
bool CompareDateIncreasing (int nEmail1, int nEmail2);
bool CompareDateDecreasing (int nEmail1, int nEmail2);
bool CompareMailStateIncreasing (int nEmail1, int nEmail2);
bool CompareMailStateDecreasing (int nEmail1, int nEmail2);
void InterpretDate (char * szTime, char * pcUTCTime);
void DateToText (char * pcUTCTime, char * szDate, int nStringLen);
int cmpstr (char * szString1, char * szString2);
void CopySenderDisplay (char * szCopyTo, char * szSender);
void CopySize (int nSize, char * szCopyTo);
void DragColumnWidth (int nXPos, int nYPos, int nColumn);
void SetColumnWidth (int nColumn, int nWidth);
void SetColumnFromScreen (int nColumn, int nXPos);
void CheckColumnEdgePointer (int nXPos, int nYPos);
void OpenAccountWindow (int nDialogueAccount);
void OpenAccountSettingsWindow (int nDialogueAccount);
void SetEmailSave (int nEmailNum, bool boEdit);
int EmailSaveSize (void);
void RamFetchEmails (wimp_block *pcBlock);
bool SetEmailSaveSelection ();
void CreateForwardMessage (int nEmailNum);
void CreateReplyMessage (int nEmailNum);
void AppendExtractedAddresses (char * szInput, char * szOutput, int nOutLen, bool boIncludeSelf);
void CreateReplyToAllMessage (int nEmailNum);
void SetSubMenu (wimp_menu * pcMain, int nItem, wimp_menu * pcSub);
void SetMenuItemGreyness (bool boState, wimp_menu * pcMenu, int nItem);
void SetMenuItemTicked (bool boTicked, wimp_menu * pcMenu, int nItem);;
void SelectAllEmails (void);
void InvertAllEmails (void);
void SetUpMainMenu (void);
void SetUpEmailMenu (void);
void SetUpNewMenu (void);
void OpenSelectedEmails (void);
void ScrambleData (int * anPlain, int * anBuffer, int nBufferLen, char * szPassword);
void UnscrambleData (int * anScrambled, int * anBuffer, int nBufferLen, char * szPassword);
void HexToString (char * szPlainText, int * anBuffer, int nBufferLen);
void StringToHex (char * szPlainText, int * anBuffer, int nBufferLen);
int LoadFileFlex (char * szFilename, char * * ppcMemory, int * pnSize);
char * memgets (char * str, int n, MemFile * psMemory);
int memseek (MemFile * psMemory, int pos, int from);
int memtell (MemFile * psMemory);
int FindSectionMem (MemFile * pfhFile, char * szSection);
bool FindValueMem (MemFile * pfhFile, int nSection, char * szName, char * szValue, int nValueLen);
int memputc (int c, MemFile * psMemory);
int memputs (char * str, MemFile * psMemory);
void SaveSectionMem (MemFile * pfhFile, char * szSection);
void SaveDetailMem (MemFile * pfhFile, char * szName, char * szDetails);
MemFile * memopen (char * filename, char * mode);
int memclose (MemFile * psMemFile);
void OpenUnlockWindow (void);
void OpenChoicesWindow (void);
void UnlockOkay (void);
void ChoicesOkay (void);
void SetChoicesDetails (void);
void SetChoicesDialogue (void);
void DeleteAccount (int nAccount);
void QueryContinue (void);
void QueryCancel (void);
bool TransferInProgress (void);
void PreQuit (void);
void Lock (void);
int ExtendLineMem (int nEditNum);
int ExtendEmailMem (int nEditNum);
int ExtendLineMemTo (int nEditNum, int nSize);
int ExtendEmailMemTo (int nEditNum, int nSize);
void FindAdditionalFonts (void);
void ReleaseAdditionalFonts (void);
void ModeChange (void);
void Register (void);
unsigned int CheckRegister (char * szName, unsigned int uKey);
void LoadLicense (void);
void SetRegistrationInfo (void);
void OpenRegisterWindow (void);
void RegisterCancel (void);
void GetOSVersion (char * szVersion, int nLength);
void OpenChoicesLoginMenu (void);
void SetChoicesAccount (int nShowAccount);
void GenerateAccountMenuOffset (wimp_menu * pcMenu, int nOffset);
void GenerateAccountMenuNone (wimp_menu * pcMenu);
void ShowChoicesAccount (int nShowAccount);
void OpenDefaultAccount (void);
void OpenChoicesLocalFontMenu (void);
void ChoicesLocalFontSelect (wimp_selection * psSelection);
void OpenChoicesRemoteFontMenu (void);
void ChoicesRemoteFontSelect (wimp_selection * psSelection);
void SetUpFontMenu (wimp_menu * pcMenu, char * szFont);
bool ChangeListFonts (char * szFont, char * szFontB);
void ShowAdvanced (int nEditNum, bool boShow);
void OpenAddressesWindow (int nAddress);
void SetAddressesDialogue (int nAddress);
void AddressesDialogueDelete (void);
void AddressesDialogueUpdate (void);
void AddressesDialogueNew (void);
void SaveAddressesDetails (void);
bool LoadAddressesDetails (void);
void GenerateAddressesMenu (ADDRESSMENU eMenuType);
void OpenAddressMenu (wimp_w whWindow, wimp_i ihIcon, ADDRESSMENU eMenuType);
void AddAddressToIcon (wimp_w whWindow, wimp_i ihIcon, int nAddress, int nMaxLen);
void AddFromToAddress (int nEmailNum);
void CloseWindowHandlePane (wimp_w whWindow, wimp_w whPane);
inline void EditChanged (int nEditNum);
void EditChangedInitial (int nEditNum);
void SetIconTextIncrement (char * szText, wimp_w whWindow, wimp_i ihIcon);
void IconTextIncrement (wimp_w whWindow, wimp_i ihIcon);
void SetDeleteType (DELETETYPE eDeleteType);
char * strnchr (char * szString, char cChar, int nLength);
char * strnzchr (char * szString, char cChar, int nLength);
void GenerateTransTable (void);
void PopulateSmileys (void);
void RedrawAllEmailEditWindows (void);
int ConvertString (char * szOutput, char * szInput, int nBufferLen);


//void     POPloop       (/*int argc, char * * argv*/);
void     NetworkLoop       (NET eNetCom);

void     ShowWarning   (os_error * sError);
STATE    Resolve       (char * szHostName, int * pnAddress);
#if defined _DEBUG
void     PrintState    (STATE eState);
#endif
SOCK     CreateSocket  (socket_s * psSocket);
STATE    Connect       (int nAddress, socket_s * psSocket, int nPort);
SOCK     POP3SocketRead    (socket_s * psSocket);
SOCK     SendCommand   (char * szCommand, socket_s * psSocket);
SOCK     POP3RemoveLine    (char * pcBuffer, int nLength, int * pnBufferStart);
STATE    POP3Authorization (socket_s * psSocket);
STATE    POP3Transaction   (socket_s * psSocket);
STATE    POP3Quit          (socket_s * psSocket);
void     ResetDetails      (void);

SOCK     SMTPSocketRead    (socket_s * psSocket);
SOCK     SMTPRemoveLine    (char * pcBuffer, int nLength, int * pnBufferStart);
STATE    SMTPAuthorization (socket_s * psSocket);
STATE    SMTPTransaction   (socket_s * psSocket);
STATE    SMTPQuit          (socket_s * psSocket);
void     ParseAddresses    (int nEditNum);
int      AddressesToArray  (char * szText, int nCount, int nMax);
void     CheckNetCom       (NET eNetCom);
void     AddToRETRQueue    (int nEmailNum);
void     ShiftRETRQueue    (void);
void     AddToMAILQueue    (int nEmailNum);
void     ShiftMAILQueue    (void);
void     AddToDELEQueue    (int nEmailNum);
void     ShiftDELEQueue    (void);
void     ShiftDELEQueueRedraw (void);
SMTP_TRANSTATE SMTPSendText (socket_s * psSocket, SOCK eReturnSend);
void     SMTPMailSendSuccess (int nEditNum);
void     SMTPMailSendFail  (int nEditNum);
void     PrintPOP3Transaction (POP3_TRANSTATE eState);
void     CompileDeleteList (void);
void     ClearPOP3Queues   (void);
void     SetConnectStatus  (CONNECTED eStatus);
void     ResetTimeout      (os_t nTime);
void     CheckTimeout      (void);
void     Cancel            (void);
STATE    CheckConnected    (socket_s sSocket);

void CheckMIME (int nEmailNum);
void GenerateAttachmentMenu (wimp_menu * pcMenu, int nEmailNum);
void OpenAttachmentMenu (wimp_w whWindow, wimp_i ihIcon, int nEmailNum);
void GenerateEditAttachmentMenu (wimp_menu * pcMenu, int nEmailNum);
void OpenEditAttachmentMenu (wimp_w whWindow, wimp_i ihIcon, int nEmailNum);
void MenuWarning (wimp_block *pcBlock);
void AttachmentSave (void);
void SaveAttachment (char * szFilename);
void RamFetchAttachment (wimp_block *pcBlock);
void EditAttachmentsIconUpdate (int nEditNum);
bool AddFileToAttachmentsListFlex (int nEditNum, char * szFileName, int nFileType, char * * ppcStartFile, int nFileSize, bool boUseAttributes, unsigned int uLoad, unsigned int uExec, unsigned int uAccess);
void RemoveFileFromAttachmentsList (int nEditNum, int nAttachmentNum);
void SetEditAttachmentDetails (int nEditNum, int nAttachmentNum);
SMTP_SENDTEXT SMTPSendAttachments (socket_s * psSocket, SOCK eReturnSend);
SOCK SendCommandStart (char * szCommand, socket_s * psSocket);
SOCK SendCommandUpdate (void);
void SendCommandReset (void);

void SetSMTPAuthGreyness (void);
void EncodeMD5 (char * pcIn, int nInSize, char * pcOut);
void EncodeHMACMD5 (char * pcIn, int nInSize, char * pcKey, int nKeySize, char * pcOut);


// Respond to swi errors
inline void err (os_error * psError)
{
  if (psError)
  {
    ShowWarning (psError);
  }
}

//////////////////////////////////////////////////////////////////
// Log a string to reporter
inline void Log (char * szPrefix, char * szText)
{
  char                        szLog[1024];
  _kernel_swi_regs            sRegs;

  if (gboLog)
  {
    strncpy (szLog, szPrefix, 512);
    strncat (szLog, szText, 512);

    sRegs.r[0] = (int)szLog;
    _kernel_swi (Report_Text0, & sRegs, & sRegs);
  }
}

//////////////////////////////////////////////////////////////////
// Log a string to reporter
inline void LogVar (char * szFormat, int nVariable)
{
  char                        szLog[1024];
  _kernel_swi_regs            sRegs;

  if (gboLog)
  {
    sprintf (szLog, szFormat, nVariable);
    sRegs.r[0] = (int)szLog;
    _kernel_swi (Report_Text0, & sRegs, & sRegs);
  }
}

// Main program
int main (int argc, char * * argv)
{
  wimp_block                  cBlock;
  int                         nCount;
  int                         nSubCount;
  wimp_event_no               nEvent;
  wimp_MESSAGE_LIST(12) sMessages = {{message_DATA_SAVE,
                                     message_DATA_SAVE_ACK,
                                     message_DATA_LOAD,
//                                     message_DATA_OPEN,
                                     message_RAM_FETCH,
                                     message_RAM_TRANSMIT,
                                     message_CLAIM_ENTITY,
                                     message_DATA_REQUEST,
                                     message_MODE_CHANGE,
                                     message_HELP,
                                     message_MENU_WARNING,
                                     message_URL_LAUNCH,
                                     0u}};
  wimp_message_list *psUserMessages = (wimp_message_list*)&sMessages;
  os_t                        nMonotonicTime;
  int                         nAllocSuccess;
  bool                        boEmailLaunch;
  char                        szEmailLaunchTo[TO_MAX];
  int                         nArgPos;

  // Check for parameters
  boEmailLaunch = FALSE;
  szEmailLaunchTo[0] = 0;
  nArgPos = 1;
  while (nArgPos < argc)
  {
    REPORT (argv[nArgPos]);

    if (strcmp (argv[nArgPos], "-url") == 0)
    {
      nArgPos++;
      if (nArgPos < argc)
      {
        if (strncmp (argv[nArgPos], "mailto:", 7) == 0)
        {
          strncpy (szEmailLaunchTo, argv[nArgPos] + 7, TO_MAX);
        }
        else
        {
          strncpy (szEmailLaunchTo, argv[nArgPos], TO_MAX);
        }
        boEmailLaunch = TRUE;
      }
    }
    nArgPos++;
  }

  // Variables
  guPollFlags = FLAGS;
  gnFastPollAcc = 0;
  gnSlowPollAcc = 0;
  gboNetworkPoll = FALSE;
  gnTimeoutTime = -1;
  gpcCurrentEmail = NULL;
  gnOpenOffset = 0;
  gnSelected = 0;
  gboTentativeSelection = TRUE;
  strcpy (gszUnlockPassword, "");
  geQueryAction = QUERYACTION_NONE;
  gnAddressNum = 0;
  gnAttachmentNum = 0;
  SetDeleteType (DELETETYPE_GUESS);
  gboUIDDesync = FALSE;
#if defined MAX_SEND_LEN
  gnMaxSendLen = MAX_SEND_LEN;
  gnNullPollNetwork = NULL_POLL_NETWORK;
  gboFastSending = FALSE;
#endif

//  SetNullPollActive (NULLPOLL_ACTIVE_SLOW);

  gboPointerEdit = FALSE;
  gnPointerEmail = EMAIL_INVALID;
  gboLinkPointer = FALSE;
  gboColumnPointer = FALSE;
  strncpy (gszDateFormat, DATE_FORMAT, sizeof (gszDateFormat));
  gboLog = FALSE;

  // Reset the account details
  for (nCount = 0; nCount <= ACCOUNT_MAX; nCount++)
  {
    ClearAccountDetails (nCount);
  }
  gnAccountNum = 0;
  gnAccount = ACCOUNT_INVALID;
  gnAccountDialogue = ACCOUNT_INVALID;
  gnAccountLogin = 0;
  gnDefaultAccount = ACCOUNT_INVALID;
  gnAccountSettingsDialogue = ACCOUNT_INVALID;
  gnAddress = ADDRESS_INVALID;
  geAddressMenuType = ADDRESSMENU_INVALID;

  FindAdditionalFonts ();

  // Set up blank edit structures
  for (nCount = 0; nCount < EDIT_MAX; nCount++)
  {
    gasEdit[nCount].nSize = -1;
    strcpy (gasEdit[nCount].szTo, "");
    strcpy (gasEdit[nCount].szSubject, "");
    strcpy (gasEdit[nCount].szCC, "");
    strcpy (gasEdit[nCount].szBCC, "");
    gasEdit[nCount].whWindow = wimp_BACKGROUND;
    gasEdit[nCount].whHead = wimp_BACKGROUND;
    gasEdit[nCount].szRawEmail = NULL;
    gasEdit[nCount].szFormEmail = NULL;
    gasEdit[nCount].boInsert = FALSE;
    gasEdit[nCount].boLineChange = FALSE;
    gasEdit[nCount].boAdvanced = FALSE;
    gasEdit[nCount].nTextOffset = EDIT_TEXT_Y_OFFSET_MIN;
    gasEdit[nCount].boChanged = FALSE;
    strcpy (gasEdit[nCount].szWinTitle, "");

    strncpy (gasEdit[nCount].szAttachNum, "0", ATTACH_NUM_TEXT_MAX);
    gasEdit[nCount].nMIMEListNum = 0;
    for (nSubCount = 0; nSubCount < ATTACHMENT_EDIT_MAX; nSubCount++)
    {
      ClearMIMEEditDetails (& gasEdit[nCount].asAttachments[nSubCount]);
    }

    gawhEditOpen[nCount] = wimp_BACKGROUND;
    ganEditOpen[nCount] = EDIT_INVALID;
  }
  gawhEditOpen[EDIT_MAX] = wimp_BACKGROUND;
  ganEditOpen[EDIT_MAX] = EDIT_INVALID;

  gnEditNum = 0;
  gwhWindowClose = 0;

  // Set up some arbitrary details
  ResetDetails ();
  gnBufferStart = 0;
  geState = STATE_DISCONNECTED;
  gnRETRActNum = 0;
  gnRETRActPos = 0;
  gnMAILActNum = 0;
  gnMAILActPos = 0;
  gnDELEActNum = 0;
  gnDELEActPos = 0;
  geNetCom = NET_INVALID;
  for (nCount = 0; nCount < (DETAILS_MAX + 1); nCount++)
  {
    ganRETRAct[nCount] = EMAIL_INVALID;
    ganMAILAct[nCount] = EMAIL_INVALID;
    ganDELEAct[nCount] = EMAIL_INVALID;
  }

  for (nCount = 0; nCount < DETAILS_MAX; nCount++)
  {
    ganEmailSave[nCount] = EMAIL_INVALID;
  }
  gnEmailSaveNum = 0;
  gboEditSave = FALSE;
  gnEmailSavePos = 0;

//  for (nCount = 0; nCount < DETAILS_MAX; nCount++)
//  {
//    gasDetails[nCount].nMsgNum = nCount + 1;
//    gasDetails[nCount].nSize = nCount * 15;
//    gasDetails[nCount].boSelected = FALSE;
//    sprintf (gasDetails[nCount].szSender, "sender%d@anon.com", nCount);
//    sprintf (gasDetails[nCount].szSubject, "Here's email number %d", nCount);
//    gasDetails[nCount].szRawEmail = NULL;
//    gasDetails[nCount].whWindow = wimp_BACKGROUND;
//    gasDetails[nCount].whHead = wimp_BACKGROUND;
//    gawhEmailsOpen[nCount] = wimp_BACKGROUND;
//    ganEmailsOpen[nCount] = EMAIL_INVALID;
//  }
//  gasDetails[0].szRawEmail = LoadFile ("<TapirMail$Dir>.Email1",
//    & gasDetails[0].nSize);

//  gasDetails[5].szRawEmail = LoadFile ("<TapirMail$Dir>.Email1",
//    & gasDetails[5].nSize);

  gnEmailSelected = EMAIL_INVALID;
  gboEditSelected = FALSE;
  gnEditSaveSelected = EDIT_INVALID;
  gnTotalMailSize = 0;
  gnTotalMailSizeTemp = 0;

  ganColWidth[0] = 0;
  ganColWidth[1] = ganColWidth[0] + 56;
  ganColWidth[2] = ganColWidth[1] + 80;
  ganColWidth[3] = ganColWidth[2] + 120;
  ganColWidth[4] = ganColWidth[3] + 380;
  ganColWidth[5] = ganColWidth[4] + 420;
  ganColWidth[6] = ganColWidth[5] + 224;

  gsSelect.boEdit = FALSE;
  gsSelect.nLineStart = 20;
  gsSelect.nCharStart = 15;
  gsSelect.nLineEnd = 29;
  gsSelect.nCharEnd = 11;
  gsSelect.whWindow = wimp_BACKGROUND;
  gsSelect.nEmailNum = EMAIL_INVALID;

  gpcCopySelect = NULL;
  gnCopySelectSize = 0;
  gboClipClaimed = FALSE;
  gpcClipboard = NULL;
  gnClipboardSize = 0;
  gboEmoticons = TRUE;

  gnRamTransRef = -1;
  gpcRamTransPos = NULL;
  gnRamTransLeft = 0;
  gnRamTransEmailPos = 0;
  gnRamTransAttcPos = 0;

  ClearCaret ();
  gboCaretLost = TRUE;
  gnMyRef = -1;

  // Load Messages file
  gpcMessages = osmodule_alloc (17 + sizeof(MESSAGES));
  strcpy(gpcMessages + 16, MESSAGES);

  messagetrans_open_file ((messagetrans_control_block*)gpcMessages,
    gpcMessages + 16, 0);

  // Initialise task
  gnTaskHandle = wimp_initialise (wimp_VERSION_RO3, Tag ("Tsk"),
    psUserMessages, & gnWimpVersion);

  // Initialise the flex memory
  strncpy (gszProgTitle, Tag("Tsk"), sizeof (gszProgTitle));
  flex_init (gszProgTitle, 0, 0);

  // Load license
  LoadLicense ();

  // Create a clipboard area
  nAllocSuccess = flex_alloc ((flex_ptr)(& gpcCopySelect), SELECT_MEM_MIN);
  if (nAllocSuccess == 0)
  {
    gpcCopySelect = NULL;
  }
  gnCopySelectSize = 0;

  // Load templates
  for (nCount = 0; nCount < 256; nCount++)
  {
    gacFontRef[nCount] = 0;
  }
  wimp_open_template (TEMPLATES);
  gwhMain = LoadTemplate ("Main");
  gwhSave = LoadTemplate ("Save");
  gwhWarn = LoadTemplate ("Warning");
  gwhText = LoadTemplate ("Text");
  gwhEdit = LoadTemplate ("Edit");
  gwhQery = LoadTemplate ("Query");
  gwhAcct = LoadTemplate ("Account");
  gwhLogn = LoadTemplate ("Login");
  gwhUnLk = LoadTemplate ("Unlock");
  gwhChce = LoadTemplate ("Choices");
  gwhSett = LoadTemplate ("Settings");
  gwhAddr = LoadTemplate ("Addresses");
  gwhAttc = LoadTemplate ("SaveAttc");
  gwhAcBa = LoadTemplate ("AccBase");
  gwhChBa = LoadTemplate ("ChoBase");
  gwhSeBa = LoadTemplate ("SetBase");
  gwhEdAt = LoadTemplate ("EditAttc");
  if (gnRegistered != REGISTERED)
  {
    gwhRegi = LoadTemplate ("Register");
  }
  else
  {
    gwhRegi = NULL;
  }
  SetIconText (Tag ("SaveEmail"), gwhSave, 2);

  // Load sprites
  gpcSprites = LoadSprites (SPRITES);

  gwhEdHe = LoadTemplateSprites ("EditHead", gpcSprites);
  gwhEmHe = LoadTemplateSprites ("EmailHead", gpcSprites);
//  gwhMaHe = LoadTemplateSprites ("MainHead", gpcSprites);
  gwhMaHe = LoadTemplateMaHe ("MainHead", gpcSprites);

  // Load emoticon sprites
  gpcEmoticons = LoadSprites (EMOTICONS);
  PopulateSmileys ();
  GenerateTransTable ();

  // Create menus
  if (gnRegistered != REGISTERED)
  {
    gpcIconBarMenu = CreateMenu (Tag ("Menu1R"));
  }
  else
  {
    gpcIconBarMenu = CreateMenu (Tag ("Menu1"));
  }

  gpcMainMenu = CreateMenu (Tag ("Menu2"));
  gpcEmailMenu = CreateMenu (Tag ("Menu3"));
  gpcNewMenu = CreateMenu (Tag ("Menu4"));

  gpcMainSelMenu = CreateMenu (Tag ("Menu2-0"));
  gpcMainSendMenu = CreateMenu (Tag ("Menu2-1"));
  gpcMainHiMenu = CreateMenu (Tag ("Menu2-2"));
  gpcMainAcMenu = CreateMenu (Tag ("Menu2-3"));
  gpcEmailEditMenu = CreateMenu (Tag ("Menu3-0"));
  gpcEmailSendMenu = CreateMenu (Tag ("Menu3-1"));
  gpcNewEditMenu = CreateMenu (Tag ("Menu4-0"));

  SetSubMenu (gpcMainMenu, 1, gpcMainSelMenu);
  SetSubMenu (gpcMainMenu, 2, gpcMainSendMenu);
  SetSubMenu (gpcMainMenu, 3, gpcMainHiMenu);
  SetSubMenu (gpcMainMenu, 4, gpcMainAcMenu);
  SetSubMenu (gpcEmailMenu, 2, gpcEmailEditMenu);
  SetSubMenu (gpcEmailMenu, 3, gpcEmailSendMenu);
  SetSubMenu (gpcNewMenu, 2, gpcNewEditMenu);

  SetSubMenu (gpcMainSelMenu, 2, (wimp_menu*)gwhSave);
  SetSubMenu (gpcEmailMenu, 0, (wimp_menu*)gwhSave);
  SetSubMenu (gpcNewMenu, 0, (wimp_menu*)gwhSave);

  SetMenuItemGreyness (TRUE, gpcEmailEditMenu, 0);
  SetMenuItemGreyness (TRUE, gpcEmailEditMenu, 2);
  SetMenuItemGreyness (TRUE, gpcEmailEditMenu, 4);

  gpcLognMenu = (wimp_menu*)malloc (wimp_SIZEOF_MENU(ACCOUNT_MAX));
  gpcAcctMenu = (wimp_menu*)malloc (wimp_SIZEOF_MENU(ACCOUNT_MAX));
  gpcChoiceAcctMenu = (wimp_menu*)malloc
    (wimp_SIZEOF_MENU((ACCOUNT_MAX + 1)));
  gpcAcctMenuBuffer = (char *)malloc (256 + ACCOUNT_MAX * TITLE_LEN);
  gpcIconBarMenu->entries[1].sub_menu = gpcAcctMenu;
  gpcAddrMenu = (wimp_menu*)malloc (wimp_SIZEOF_MENU((ADDRESSES_NUM_MAX)));
  gpcAddrMenuBuffer = (char *)malloc (32);
  gpcAttcMenuBuffer = (char *)malloc (ATTACH_MENU_BUF_SIZE);
  gpcEdAtMenuBuffer = (char *)malloc (ATTACH_MENU_BUF_SIZE);
  gpcAttcMenu = (wimp_menu*)malloc (wimp_SIZEOF_MENU((ATTACHMENTS_NUM_MAX)));
  gpcEditAttcMenu = (wimp_menu*)malloc
    (wimp_SIZEOF_MENU((ATTACHMENTS_NUM_MAX)));

  SetSubMenu (gpcEmailMenu, 1, gpcAttcMenu);
  SetSubMenu (gpcNewMenu, 1, gpcEditAttcMenu);

  // Create space for the font menus
  gpcLocalFontMenu = (wimp_menu*)malloc (FONT_LIST_MAX);
  gpcRemoteFontMenu = (wimp_menu*)malloc (FONT_LIST_MAX);
  gpcFontMenuBuffer = malloc (FONT_LIST_IND_MAX);

  // Close templates
  wimp_close_template ();

  // Set up the registration and version info
  SetRegistrationInfo ();
  SetIconText (VERSION_STRING_LONG, gawhMenuWinHandle[0], 3);

  // Create icon
  gihIconBarIcon = CreateIconbarIcon (Tag ("Icn"), 92, 68);
  geConnectStatus = CONNECTED_INVALID;
  SetConnectStatus (CONNECTED_OFF);

  // Load account details
  gboAccountsLoaded = LoadAccountDetails ();
  LoadAddressesDetails ();

  // Resize the main window
  SetMainExtent (-1);

  // Open an email window if -url argument set
  if (boEmailLaunch)
  {
    if (gnAccountNum != 0)
    {
      CreateEditWindowAddress (szEmailLaunchTo);
      boEmailLaunch = FALSE;
    }
    else
    {
      ShowWarningTag ("Er31");
    }
  }

  xos_read_monotonic_time (& gnMonotonicTime);
  srand (gnMonotonicTime);
  gnTimeInc = NULL_POLL_SLOWEST;

  // Main polling loop
  //////////////////////////////////////////////////////////////////
  do
  {
    nEvent = wimp_poll_idle (guPollFlags, & cBlock, gnMonotonicTime, NULL);
    xos_read_monotonic_time (& nMonotonicTime);
    if (nMonotonicTime > gnMonotonicTime)
    {
      gnMonotonicTime = nMonotonicTime + gnTimeInc;
    }
    switch (nEvent)
    {
      case  0: // Null
        NullPoll (& cBlock);
        break;
      case  1: // Redraw window
        RedrawWindow (& cBlock);
        break;
      case  2: // Open window
        OpenWindow (& cBlock);
        break;
      case  3: // Closewindow
        CloseWindow (& cBlock);
        break;
      case  4: // Pointer leaving window
        PointerLeaving (& cBlock);
        break;
      case  5: // Pointer entering window
        PointerEntering (& cBlock);
        break;
      case  6:
        MouseClick (& cBlock);
        break;
      case  7: // User drag box
        UserDragBox (& cBlock);
        break;
      case  8: // Keys
        Keys (& cBlock);
        break;
      case  9:
        MenuSelect (& cBlock);
        break;
      case 10: // Scroll request
        ScrollRequest (& cBlock);
        break;
      case 11: // Lose caret
        LoseCaret (& cBlock);
        break;
      case 12: // Gain caret
        break;
      case 17: // Receive message
      case 18:
        Receive (& cBlock);
        break;
      case 19: // UserMessage Acknowledge
        Acknowledged (& cBlock);
        break;
      default: // Default
        break;
    }
  } while TRUE;

  //////////////////////////////////////////////////////////////////

  return 0;
}

//////////////////////////////////////////////////////////////////
// Poll 16,17: Message received
void Receive (wimp_block *pcBlock)
{
  switch (pcBlock->message.action)
  {
    case message_QUIT:
      PreQuit ();
      break;
    case message_DATA_SAVE:
      DataSave (pcBlock);
      break;
    case message_DATA_SAVE_ACK:
      DataSaveAck (pcBlock);
      break;
    case message_DATA_LOAD:
      DataLoad (pcBlock);
      break;
//    case message_DATA_OPEN:
//      DataOpen (pcBlock);
//      break;
    case message_RAM_FETCH:
      RamFetch (pcBlock);
      break;
    case message_RAM_TRANSMIT:
      RamTransmit (pcBlock);
      break;
    case message_CLAIM_ENTITY:
      ClaimEntity (pcBlock);
      break;
    case message_DATA_REQUEST:
      DataRequest (pcBlock);
      break;
    case message_MODE_CHANGE:
      ModeChange ();
    case message_HELP:
      Help (pcBlock);
      break;
    case message_MENU_WARNING:
      MenuWarning (pcBlock);
      break;
    case message_URL_LAUNCH:
      LaunchURL (pcBlock);
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Poll 19: Message acknowledge received
void Acknowledged (wimp_block *pcBlock)
{
  switch (pcBlock->message.action)
  {
    case message_RAM_FETCH:
      RamFetchReturned (pcBlock);
      break;
    case message_URL_LAUNCH:
      OpenURLReturned (pcBlock);
      break;
  }
  gnMessageMyRef = 0;
}

//////////////////////////////////////////////////////////////////
// Pre quit
void PreQuit (void)
{
  int                         nEditNum;
  bool                        boChanged;

  if (TransferInProgress ())
  {
    ShowQueryTag ("Ms4", "MsYes", "MsNo", QUERYACTION_QUIT);
  }
  else
  {
    nEditNum = 0;
    boChanged = FALSE;
    while ((!boChanged) && (nEditNum < EDIT_MAX))
    {
      if ((gasEdit[nEditNum].whWindow != wimp_BACKGROUND)
        && (gasEdit[nEditNum].boChanged))
      {
        boChanged = TRUE;
      }
      nEditNum++;
    }
    if (boChanged)
    {
      ShowQueryTag ("Ms7", "MsYes", "MsNo", QUERYACTION_QUIT);
    }
    else
    {
      Quit ();
    }
  }
}

//////////////////////////////////////////////////////////////////
// Quit task
void Quit (void)
{
  int                         nCount;
  int                         nRemove;

  ReleaseAdditionalFonts ();

  // Free the fonts
  for (nCount = 0; nCount < 256; nCount++)
  {
    if (gacFontRef[nCount])
    {
      for (nRemove = 0; nRemove < gacFontRef[nCount]; nRemove++)
      {
        xfont_lose_font ((font_f)nCount);
      }
    }
  }

  // Close the program
  wimp_close_down (gnTaskHandle);
}

//////////////////////////////////////////////////////////////////
// The edit window has been changed
inline void EditChanged (int nEditNum)
{
  if (!gasEdit[nEditNum].boChanged)
  {
    EditChangedInitial (nEditNum);
  }
}

//////////////////////////////////////////////////////////////////
// The edit window has been changed for the first time
void EditChangedInitial (int nEditNum)
{
  wimp_window_info            sWindow;
  wimp_outline                sOutline;

  gasEdit[nEditNum].boChanged = TRUE;
  sWindow.w = gasEdit[nEditNum].whWindow;
  xwimp_get_window_info_header_only (& sWindow);
  strncpy (sWindow.title_data.indirected_text.text,
    Tag("EditTitle"), sWindow.title_data.indirected_text.size - 2);
  strcat (sWindow.title_data.indirected_text.text, " *");
  if (gnWimpVersion < 502)
  {
    // Non nested wimp
    sOutline.w = gasEdit[nEditNum].whWindow;
    xwimp_get_window_outline (& sOutline);
    xwimp_force_redraw (wimp_BACKGROUND, sOutline.outline.x0,
      sWindow.visible.y1, sOutline.outline.x1, sOutline.outline.y1);
  }
  else
  {
    // Nested wimp
    xwimp_force_redraw_title (gasEdit[nEditNum].whWindow);
  }
}

//////////////////////////////////////////////////////////////////
// Poll 6: Process mouse clicks
void MouseClick (wimp_block *pcBlock)
{
  int                         nXPos       = pcBlock->pointer.pos.x;
  int                         nYPos       = pcBlock->pointer.pos.y;
  wimp_mouse_state            nButton     = pcBlock->pointer.buttons;
  wimp_w                      whWindow    = pcBlock->pointer.w;
  wimp_i                      ihIcon      = pcBlock->pointer.i;
  char                        *szFileIcon;
  int                         nEmailNum;
  wimp_window_state           sState;
  int                         nWinXPos;
  int                         nWinYPos;
  Selection                   sSelect;
  bool                        boWinFound;
  int                         nEmailSearch;
  int                         nEditSearch;
  RELPOS                      eRelPos;
  int                         nLine;
  int                         nChar;
  int                         nStartLine;
  int                         nEndLine;
  bool                        boClearSelect;
  bool                        boRemember;
  char                        szSnip[1024];
  int                         nLength;
  bool                        boUpdate;

  boWinFound = FALSE;
  sState.w = whWindow;
  xwimp_get_window_state (& sState);
  nWinXPos = nXPos - sState.visible.x0 + sState.xscroll;
  nWinYPos = nYPos - sState.visible.y1 + sState.yscroll;

  if (whWindow == wimp_ICON_BAR)
  {
    switch (nButton)
    {
      case wimp_CLICK_SELECT:
        if (gboAccountsLoaded)
        {
          if (gnAccount != ACCOUNT_INVALID)
          {
            OpenWindowInitPane (gwhMain, gwhMaHe, PANE_TOP);
          }
          else
          {
            if (gnAccountNum > 0)
            {
              OpenLoginWindow (gnAccount);
            }
            else
            {
              OpenAccountWindow (ACCOUNT_INVALID);
            }
          }
        }
        else
        {
          OpenUnlockWindow ();
        }
        break;
      case wimp_CLICK_MENU:
        SetupIconbarMenu ();
        if (gnRegistered == REGISTERED)
        {
          OpenMenu (gpcIconBarMenu, nXPos + MENU_XPOS_OFFSET,
            ICONBAR_MENU_YPOS);
        }
        else
        {
          OpenMenu (gpcIconBarMenu, nXPos + MENU_XPOS_OFFSET,
            ICONBAR_MENU_YPOS_R);
        }
        break;
      case wimp_CLICK_ADJUST:
        if (gboAccountsLoaded)
        {
          if (gnAccountNum > 0)
          {
            OpenLoginWindow (gnAccount);
          }
          else
          {
            OpenAccountWindow (ACCOUNT_INVALID);
          }
        }
        else
        {
          OpenUnlockWindow ();
        }
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhMain)
  {
    if (nButton == wimp_CLICK_MENU)
    {
      SetUpMainMenu ();
      if (gboTentativeSelection)
      {
        nEmailNum = EmailRow (nWinYPos);
        // Clear current selection
        ClearAllSelected ();
        // Select an email
        ToggleSelectRow (nEmailNum);
        SetUpMainMenu ();
        gboTentativeSelection = TRUE;
      }
      OpenMenu (gpcMainMenu, nXPos + MENU_XPOS_OFFSET, nYPos);
    }
    else
    {
      switch (ihIcon)
      {
        case -1: // Work area
          nEmailNum = EmailRow (nWinYPos);
          if (nButton & wimp_SINGLE_ADJUST)
          {
            // Select an email
            ToggleSelectRow (nEmailNum);
          }
          if (nButton & wimp_SINGLE_SELECT)
          {
            if (!gasDetails[ganSort[nEmailNum]].boSelected)
            {
              // Clear current selection
              ClearAllSelected ();
              // Select an email
              ToggleSelectRow (nEmailNum);
            }
          }

          if ((nButton & wimp_DOUBLE_SELECT)
            || (nButton & wimp_DOUBLE_ADJUST))
          {
            if (nEmailNum != EMAIL_INVALID)
            {
              if (gasDetails[ganSort[nEmailNum]].szRawEmail)
              {
                CreateEmailWindow (ganSort[nEmailNum]);
              }
              else
              {
                gasDetails[ganSort[nEmailNum]].boOpenOnLoad = TRUE;
                AddToRETRQueue (ganSort[nEmailNum]);
                CheckNetCom (NET_POP3_DOWNLOAD);
              }
            }
          }

          if ((nButton & wimp_DRAG_SELECT)
            || (nButton & wimp_DRAG_ADJUST))
          {
            if (SetEmailSaveSelection ())
            {
              gnSaveFileType = 0xfff;
              DragCentred (nXPos, nYPos, "file_fff");
              geSaveType = SAVETYPE_EMAILS;
            }
          }
          break;
        default: // Save drag
          if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
          {
            strncpy (gszSaveString, GetIconText (whWindow, ihIcon),
              sizeof(gszSaveString));
            DragBox (whWindow, ihIcon);
            geSaveType = SAVETYPE_ICONTEXT;
          }
          break;
      }
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhSave)
  {
    switch (ihIcon)
    {
      case (wimp_i)3: // Save drag
        if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
        {
          szFileIcon = GetIconText (gwhSave, 3);
          gnSaveFileType = 0xfff;
          DragSprite (whWindow, ihIcon, "file_fff");
          geSaveType = SAVETYPE_FILE;
        }
        break;
      case (wimp_i)1: // Cancel
        CloseMenu ();
        break;
      case (wimp_i)0: // Save
        gnSaveFileType = 0xfff;
        SaveSave ();
        if (nButton != wimp_CLICK_ADJUST)
        {
          CloseMenu ();
        }
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhAttc)
  {
    switch (ihIcon)
    {
      case (wimp_i)3: // Save drag
        if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
        {
          szFileIcon = GetIconText (gwhAttc, 3);
          gnSaveFileType = gasDetails[gnEmailSelected]
            .asMIMEList[gnAttachmentNum].nFileType;
          DragSprite (whWindow, ihIcon, szFileIcon);
          geSaveType = SAVETYPE_ATTACHMENT;
        }
        break;
      case (wimp_i)1: // Cancel
        CloseMenu ();
        break;
      case (wimp_i)0: // Save
        gnSaveFileType = gasDetails[gnEmailSelected]
          .asMIMEList[gnAttachmentNum].nFileType;
        AttachmentSave ();
        if (nButton != wimp_CLICK_ADJUST)
        {
          CloseMenu ();
        }
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhWarn)
  {
    switch (ihIcon)
    {
      case (wimp_i)0: // OK
        CloseWarning ();
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhQery)
  {
    switch (ihIcon)
    {
      case (wimp_i)0: // Continue
        QueryContinue ();
        break;
      case (wimp_i)5: // Cancel
        QueryCancel ();
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gawhMenuWinHandle[0])
  {
    switch (ihIcon)
    {
      case (wimp_i)8: // Email
        OpenURL (Tag("Email"));
        if (nButton != wimp_CLICK_ADJUST)
        {
          CloseMenu ();
        }
        break;
      case (wimp_i)9: // Website
        OpenURL (Tag("Website"));
        if (nButton != wimp_CLICK_ADJUST)
        {
          CloseMenu ();
        }
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhMaHe)
  {
    switch (ihIcon)
    {
      case (wimp_i)-1: // Work area
        MouseClickMaHeWorkArea (nWinXPos, nWinYPos, nButton);
        break;
      case (wimp_i)1: // Download list
        CheckNetCom (NET_POP3_LIST);
        break;
      case (wimp_i)2: // Download emails
        CompileSelectedList ();
        CheckNetCom (NET_POP3_DOWNLOAD);
        break;
      case (wimp_i)3: // Forget emails
        DestroySelectedEmails ();
        break;
      case (wimp_i)4: // Delete emails
        ShowQueryTag ("Ms3", "MsYes", "MsNo", QUERYACTION_DELETEEMAILS);
        break;
      case (wimp_i)5: // New email
        CreateEditWindow ();
        break;
      case (wimp_i)6: // Stop operation
        if (geConnectStatus != CONNECTED_OFF)
        {
          ShowQueryTag ("Ms1", "MsYes", "MsNo", QUERYACTION_STOP);
        }
        break;
      case (wimp_i)7: // Invert selection
        InvertAllEmails ();
        break;
      case (wimp_i)8: // Open Accounts menu
        OpenMainLoginMenu ();
        break;
      default:
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhAcct)
  {
    switch (ihIcon)
    {
      case (wimp_i)18: // POP3 remember password
        boRemember = !GetIconSelectionState (gwhAcct, 18);
        SetIconGreyness (boRemember, gwhAcct, 19);
        SetIconGreyness (boRemember, gwhAcct, 20);
        break;
      case (wimp_i)31: // SMTP use POP3 details
      case (wimp_i)34: // SMTP remember password
      case (wimp_i)27: // None
      case (wimp_i)28: // Plain
      case (wimp_i)29: // Login
      case (wimp_i)30: // Cram-MD5
        SetSMTPAuthGreyness ();
        break;
      default:
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhAcBa)
  {
    switch (ihIcon)
    {
      case (wimp_i)2: // OK
        if (gnAccountDialogue == ACCOUNT_INVALID)
        {
          SetAccountDetails (gnAccountNum);
          gnAccountDialogue = gnAccountNum;
          gnAccountNum++;
        }
        else
        {
          SetAccountDetails (gnAccountDialogue);
          SetLoginWindow (gnAccountLogin);
        }
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhAcct, gwhAcBa);
        }
        break;
      case (wimp_i)1: // Save
        if (gnAccountDialogue == ACCOUNT_INVALID)
        {
          SetAccountDetails (gnAccountNum);
          gnAccountDialogue = gnAccountNum;
          gnAccountNum++;
        }
        else
        {
          SetAccountDetails (gnAccountDialogue);
          SetLoginWindow (gnAccountLogin);
        }
        SaveAccountDetails ();
        SaveAddressesDetails ();
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhAcct, gwhAcBa);
        }
        break;
      case (wimp_i)0: // Cancel
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhAcct, gwhAcBa);
        }
        SetAccountDialogue (gnAccountDialogue);
        break;
      case (wimp_i)3: // Delete
        ShowQueryTag ("Ms2", "MsYes", "MsNo", QUERYACTION_DELETEACCOUNT);
        CloseWindowHandlePane (gwhAcct, gwhAcBa);
        break;
      default:
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhSett)
  {
    switch (ihIcon)
    {
      default: // Save drag
        if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
        {
          strncpy (gszSaveString, GetIconText (whWindow, ihIcon),
            sizeof(gszSaveString));
          DragBox (whWindow, ihIcon);
          geSaveType = SAVETYPE_ICONTEXT;
        }
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhSeBa)
  {
    switch (ihIcon)
    {
      case (wimp_i)2: // OK
        if (gnAccountSettingsDialogue != ACCOUNT_INVALID)
        {
          SetAccountSettingsDetails (gnAccountSettingsDialogue);
        }
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhSett, gwhSeBa);
        }
        break;
      case (wimp_i)1: // Save
        if (gnAccountSettingsDialogue != ACCOUNT_INVALID)
        {
          SetAccountSettingsDetails (gnAccountSettingsDialogue);
        }
        SaveAccountDetails ();
        SaveAddressesDetails ();
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhSett, gwhSeBa);
        }
        break;
      case (wimp_i)0: // Cancel
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhSett, gwhSeBa);
        }
        SetAccountSettingsDialogue (gnAccountSettingsDialogue);
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhLogn)
  {
    switch (ihIcon)
    {
      case (wimp_i)4: // OK
        gasAccount[gnAccountLogin].boPOP3GotPassword = FALSE;
        gasAccount[gnAccountLogin].boSMTPGotPassword = FALSE;
        LoginAccount (gnAccountLogin);
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandle (gwhLogn);
        }
        break;
      case (wimp_i)3: // Cancel
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandle (gwhLogn);
        }
        break;
      case (wimp_i)0: // Account Menu
        OpenLoginMenu ();
        break;
      default:
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhUnLk)
  {
    switch (ihIcon)
    {
      case (wimp_i)1: // OK
        UnlockOkay ();
        if ((nButton == wimp_CLICK_SELECT) || gboAccountsLoaded)
        {
          CloseWindowHandle (gwhUnLk);
        }
        break;
      case (wimp_i)0: // Cancel
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandle (gwhUnLk);
        }
        break;
      default:
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhChce)
  {
    switch (ihIcon)
    {
      case (wimp_i)20: // Open local mail font menu
        OpenChoicesLocalFontMenu ();
        break;
      case (wimp_i)23: // Open remote mail font menu
        OpenChoicesRemoteFontMenu ();
        break;
      case (wimp_i)28: // Open account choices menu
        OpenChoicesLoginMenu ();
        break;
      default:
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhChBa)
  {
    switch (ihIcon)
    {
      case (wimp_i)2: // OK
        ChoicesOkay ();
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhChce, gwhChBa);
        }
        break;
      case (wimp_i)0: // Cancel
        SetChoicesDialogue ();
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhChce, gwhChBa);
        }
        break;
      case (wimp_i)1: // Save all
        ChoicesOkay ();
        SaveAccountDetails ();
        SaveAddressesDetails ();
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandlePane (gwhChce, gwhChBa);
        }
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhRegi)
  {
    switch (ihIcon)
    {
      case (wimp_i)7: // OK
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandle (gwhRegi);
        }
        Register ();
        break;
      case (wimp_i)6: // Cancel
        RegisterCancel ();
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandle (gwhRegi);
        }
        break;
      case (wimp_i)5: // Open website
        OpenURL (Tag("WebReg"));
        break;
      default:
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhAddr)
  {
    switch (ihIcon)
    {
      case (wimp_i)2: // Addresses menu
        OpenAddressMenu (whWindow, ihIcon, ADDRESSMENU_ADDRESSES);
        break;
      case (wimp_i)3: // Close
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandle (gwhAddr);
        }
        break;
      case (wimp_i)4: // Save addresses
        SaveAddressesDetails ();
        if (nButton == wimp_CLICK_SELECT)
        {
          CloseWindowHandle (gwhAddr);
        }
        break;
      case (wimp_i)11: // Delete
        ShowQueryTag ("Ms5", "MsYes", "MsNo", QUERYACTION_DELETEADDRESS);
        break;
      case (wimp_i)12: // New
        AddressesDialogueNew ();
        break;
      case (wimp_i)13: // Set
        AddressesDialogueUpdate ();
        break;
      default: // Save drag
        if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
        {
          strncpy (gszSaveString, GetIconText (whWindow, ihIcon),
            sizeof(gszSaveString));
          DragBox (whWindow, ihIcon);
          geSaveType = SAVETYPE_ICONTEXT;
        }
        break;
    }
    boWinFound = TRUE;
  }

  if (whWindow == gwhEdAt)
  {
    switch (ihIcon)
    {
      case (wimp_i)10: // Remove
        RemoveFileFromAttachmentsList (gnEmailSelected, gnAttachmentNum);
        if (nButton == wimp_CLICK_ADJUST)
        {
          if (gnAttachmentNum < gasEdit[gnEmailSelected].nMIMEListNum)
          {
            SetEditAttachmentDetails (gnEmailSelected, gnAttachmentNum);
          }
          GenerateEditAttachmentMenu (gpcEditAttcMenu, gnEmailSelected);
          OpenMenu (gpcMenuCurrent, gnMenuXpos, gnMenuYpos);
        }
        else
        {
          CloseMenu ();
        }
        break;
      default: // Save drag
        if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
        {
          strncpy (gszSaveString, GetIconText (whWindow, ihIcon),
            sizeof(gszSaveString));
          DragBox (whWindow, ihIcon);
          geSaveType = SAVETYPE_ICONTEXT;
        }
        break;
    }
  }

  // Check for all of the email windows
  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEmailsOpen[nEmailSearch])
    {
      if (nButton == wimp_CLICK_MENU)
      {
        gnEmailSelected = ganEmailsOpen[nEmailSearch];
        gboEditSelected = FALSE;
        SetUpEmailMenu ();
        SetEmailSave (gnEmailSelected, FALSE);
        OpenMenu (gpcEmailMenu, nXPos + MENU_XPOS_OFFSET, nYPos);
      }

      eRelPos = PointRelativeSelection (FALSE, ganEmailsOpen[nEmailSearch],
        nXPos, nYPos, & gsSelect, & nLine, & nChar);

      if (nButton & wimp_SINGLE_SELECT)
      {
        if ((eRelPos != RELPOS_WITHINSTART)
          && (eRelPos != RELPOS_WITHINEND))
        {
          ClearSelection ();
        }
      }

      if (nButton & wimp_DOUBLE_SELECT)
      {
        // Launch a URL
        ClickOnURL (FALSE, ganEmailsOpen[nEmailSearch], nXPos, nYPos);
      }

      if (nButton & wimp_SINGLE_ADJUST)
      {
        if ((eRelPos == RELPOS_BEFORE)
          || (eRelPos == RELPOS_WITHINSTART))
        {
          sSelect = gsSelect;
          sSelect.nLineStart = nLine;
          sSelect.nCharStart = nChar;
          ChangeSelection (& sSelect);
        }
        if ((eRelPos == RELPOS_AFTER)
          || (eRelPos == RELPOS_WITHINEND))
        {
          sSelect = gsSelect;
          sSelect.nLineEnd = nLine;
          sSelect.nCharEnd = nChar;
          ChangeSelection (& sSelect);
        }
      }

      if (nButton & wimp_DRAG_SELECT)
      {
        if ((eRelPos == RELPOS_WITHINSTART)
          || (eRelPos == RELPOS_WITHINEND))
        {
          CreateEditSelect (ganEmailsOpen[nEmailSearch], FALSE,
            & gpcCopySelect, & gnCopySelectSize);
          geSaveType = SAVETYPE_SELECTSAVE;
          DragCentred (nXPos, nYPos, "file_fff");
        }
        else
        {
          gnSelectLineStart = nLine;
          gnSelectCharStart = nChar;
          DragSelectionBox (FALSE, ganEmailsOpen[nEmailSearch], nXPos,
            nYPos);
          geSaveType = SAVETYPE_SELECTCHOOSE;
          SetNullPollActive (NULLPOLL_ACTIVE_FAST);
        }
      }

      if (nButton & wimp_DRAG_ADJUST)
      {
        gnSelectLineStart = nLine;
        gnSelectCharStart = nChar;
        if ((eRelPos == RELPOS_BEFORE)
          || (eRelPos == RELPOS_WITHINSTART))
        {
          gnSelectLineStart = gsSelect.nLineEnd;
          gnSelectCharStart = gsSelect.nCharEnd;
        }
        if ((eRelPos == RELPOS_AFTER)
          || (eRelPos == RELPOS_WITHINEND))
        {
          gnSelectLineStart = gsSelect.nLineStart;
          gnSelectCharStart = gsSelect.nCharStart;
        }
        DragSelectionBox (FALSE, ganEmailsOpen[nEmailSearch], nXPos, nYPos);
        geSaveType = SAVETYPE_SELECTCHOOSE;
        SetNullPollActive (NULLPOLL_ACTIVE_FAST);
      }
      boWinFound = TRUE;
    }

    if ((!boWinFound)
      && (gasDetails[ganEmailsOpen[nEmailSearch]].whHead == whWindow))
    {
      switch (ihIcon)
      {
        case 4: // Copy
          CopySelectToClip ();
          ClearSelection ();
          break;
        case 5: // Reply
          CreateReplyMessage (ganEmailsOpen[nEmailSearch]);
          break;
        case 6: // Reply to all
          CreateReplyToAllMessage (ganEmailsOpen[nEmailSearch]);
          break;
        case 7: // Forward
          CreateForwardMessage (ganEmailsOpen[nEmailSearch]);
          break;
        case 8: // Save
          gnEmailSelected = ganEmailsOpen[nEmailSearch];
          gboEditSelected = FALSE;
          SetEmailSave (gnEmailSelected, FALSE);
          OpenMenu ((wimp_menu *)gwhSave, nXPos + MENU_XPOS_OFFSET, nYPos);
          break;
        case 9: // Toggle Header
          if (gasDetails[ganEmailsOpen[nEmailSearch]].nLineHide == 0)
          {
            ShowHeader (ganEmailsOpen[nEmailSearch], FALSE);
          }
          else
          {
            ShowHeader (ganEmailsOpen[nEmailSearch], TRUE);
          }
          break;
        case 10: // Add 'From:' address to address book
          AddFromToAddress (ganEmailsOpen[nEmailSearch]);
          break;
        case 11: // Open Attachments menu
          if (gasDetails[ganEmailsOpen[nEmailSearch]].nMIMEListNum > 0)
          {
            gnEmailSelected = ganEmailsOpen[nEmailSearch];
            gboEditSelected = FALSE;
            OpenAttachmentMenu (whWindow, ihIcon,
              ganEmailsOpen[nEmailSearch]);
          }
          break;
        default: // Save drag
          if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
          {
            strncpy (gszSaveString, GetIconText (whWindow, ihIcon),
              sizeof(gszSaveString));
            DragBox (whWindow, ihIcon);
            geSaveType = SAVETYPE_ICONTEXT;
          }
          break;
      }
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }


  // Check for all of the edit windows
  nEditSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEditOpen[nEditSearch])
    {
      eRelPos = PointRelativeSelection (TRUE, ganEditOpen[nEditSearch],
        nXPos, nYPos, & gsSelect, & nLine, & nChar);

      if (nButton == wimp_CLICK_MENU)
      {
        gnEmailSelected = ganEditOpen[nEditSearch];
        gboEditSelected = TRUE;
        SetUpNewMenu ();
        SetEmailSave (gnEmailSelected, TRUE);
        OpenMenu (gpcNewMenu, nXPos + MENU_XPOS_OFFSET, nYPos);
      }

      if (nButton & wimp_SINGLE_SELECT)
      {
        SetCaretPos (ganEditOpen[nEditSearch], nLine, nChar);
        gsCaret.nCharPref = gsCaret.nChar;

        if ((eRelPos != RELPOS_WITHINSTART)
          && (eRelPos != RELPOS_WITHINEND))
        {
          ClearSelection ();
        }
      }

      if (nButton & wimp_DOUBLE_SELECT)
      {
        // Launch a URL
        ClickOnURL (TRUE, ganEditOpen[nEditSearch], nXPos, nYPos);
      }

      if (nButton & wimp_SINGLE_ADJUST)
      {
        if (eRelPos == RELPOS_OTHEREMAIL)
        {
          sSelect.boEdit = TRUE;
          sSelect.whWindow = whWindow;
          sSelect.nEmailNum = ganEditOpen[nEditSearch];
          sSelect.nLineStart = gsCaret.nLine;
          sSelect.nCharStart = gsCaret.nChar;
          sSelect.nLineEnd = nLine;
          sSelect.nCharEnd = nChar;
          ChangeSelection (& sSelect);
        }

        SetCaretPos (ganEditOpen[nEditSearch], nLine, nChar);
        gsCaret.nCharPref = gsCaret.nChar;

        if ((eRelPos == RELPOS_BEFORE)
          || (eRelPos == RELPOS_WITHINSTART))
        {
          sSelect = gsSelect;
          sSelect.nLineStart = nLine;
          sSelect.nCharStart = nChar;
          ChangeSelection (& sSelect);
        }
        if ((eRelPos == RELPOS_AFTER)
          || (eRelPos == RELPOS_WITHINEND))
        {
          sSelect = gsSelect;
          sSelect.nLineEnd = nLine;
          sSelect.nCharEnd = nChar;
          ChangeSelection (& sSelect);
        }
      }

      if (nButton & wimp_DRAG_SELECT)
      {
        if ((eRelPos == RELPOS_WITHINSTART)
          || (eRelPos == RELPOS_WITHINEND))
        {
          CreateEditSelect (ganEditOpen[nEditSearch], TRUE,
            & gpcCopySelect, & gnCopySelectSize);
          geSaveType = SAVETYPE_SELECTSAVE;
          DragCentred (nXPos, nYPos, "file_fff");
        }
        else
        {
          SetCaretPos (ganEditOpen[nEditSearch], nLine, nChar);
          gsCaret.nCharPref = gsCaret.nChar;

          gnSelectLineStart = nLine;
          gnSelectCharStart = nChar;
          DragSelectionBox (TRUE, ganEditOpen[nEditSearch], nXPos, nYPos);
          geSaveType = SAVETYPE_SELECTCHOOSE;
          SetNullPollActive (NULLPOLL_ACTIVE_FAST);
        }

      }

      if (nButton & wimp_DRAG_ADJUST)
      {
        SetCaretPos (ganEditOpen[nEditSearch], nLine, nChar);
        gsCaret.nCharPref = gsCaret.nChar;

        gnSelectLineStart = nLine;
        gnSelectCharStart = nChar;
        if ((eRelPos == RELPOS_BEFORE)
          || (eRelPos == RELPOS_WITHINSTART))
        {
          gnSelectLineStart = gsSelect.nLineEnd;
          gnSelectCharStart = gsSelect.nCharEnd;
        }
        if ((eRelPos == RELPOS_AFTER)
          || (eRelPos == RELPOS_WITHINEND))
        {
          gnSelectLineStart = gsSelect.nLineStart;
          gnSelectCharStart = gsSelect.nCharStart;
        }
        DragSelectionBox (TRUE, ganEditOpen[nEditSearch], nXPos, nYPos);
        geSaveType = SAVETYPE_SELECTCHOOSE;
        SetNullPollActive (NULLPOLL_ACTIVE_FAST);
      }
      boWinFound = TRUE;
    }

    if ((!boWinFound)
      && (gasEdit[ganEditOpen[nEditSearch]].whHead == whWindow))
    {
      boClearSelect = FALSE;
      switch (ihIcon)
      {
        case 4: // Cut
          CopySelectToClip ();
          if (nButton & wimp_CLICK_ADJUST)
          {
            boUpdate = DeleteSection (ganEditOpen[nEditSearch], & gsSelect);
            if (ganEditOpen[nEditSearch] == gsCaret.nEditNum)
            {
              if (gsCaret.nChar == 0)
              {
                nLength = ConvertString(szSnip, Tag("Snip"), sizeof(szSnip));
              }
              else
              {
                nLength = ConvertString(szSnip, Tag("SnipMid"),
                  sizeof(szSnip));
              }
              InsertText (gsCaret.nEditNum, gsCaret.nPos, gsCaret.nLine,
                szSnip, nLength);
              boUpdate = TRUE;
            }
            if (boUpdate)
            {
              EditChanged (ganEditOpen[nEditSearch]);
              ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
                & nStartLine, & nEndLine);
              UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
                nEndLine);
            }
          }
          else
          {
            if (DeleteSection (ganEditOpen[nEditSearch], & gsSelect))
            {
              ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
                & nStartLine, & nEndLine);
              UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
                nEndLine);
              EditChanged (ganEditOpen[nEditSearch]);
            }
          }
          break;
        case 5: // Copy
          CopySelectToClip ();
          boClearSelect = TRUE;
          break;
        case 6: // Paste
          PasteClipboard ();
          EditChanged (ganEditOpen[nEditSearch]);
          break;
        case 7: // Send
          SendEmail (ganEditOpen[nEditSearch]);
          break;
        case 8: // Save
          gnEmailSelected = ganEditOpen[nEditSearch];
          gboEditSelected = TRUE;
          SetEmailSave (gnEmailSelected, TRUE);
          OpenMenu ((wimp_menu *)gwhSave, nXPos + MENU_XPOS_OFFSET, nYPos);
          break;
        case 14: // Toggle Advanced
          if (gasEdit[ganEditOpen[nEditSearch]].boAdvanced == TRUE)
          {
            ShowAdvanced (ganEditOpen[nEditSearch], FALSE);
          }
          else
          {
            ShowAdvanced (ganEditOpen[nEditSearch], TRUE);
          }
          break;
        case 15: // 'To:' address menu
          gnEmailSelected = ganEditOpen[nEditSearch];
          gboEditSelected = TRUE;
          OpenAddressMenu (whWindow, ihIcon, ADDRESSMENU_TO);
          break;
        case 16: // 'CC:' address menu
          gnEmailSelected = ganEditOpen[nEditSearch];
          gboEditSelected = TRUE;
          OpenAddressMenu (whWindow, ihIcon, ADDRESSMENU_CC);
          break;
        case 17: // 'BCC:' address menu
          gnEmailSelected = ganEditOpen[nEditSearch];
          gboEditSelected = TRUE;
          OpenAddressMenu (whWindow, ihIcon, ADDRESSMENU_BCC);
          break;
        case 18: // Open Attachments menu
          if (gasEdit[ganEditOpen[nEditSearch]].nMIMEListNum > 0)
          {
            gnEmailSelected = ganEditOpen[nEditSearch];
            gboEditSelected = TRUE;
            OpenEditAttachmentMenu (whWindow, ihIcon,
              ganEditOpen[nEditSearch]);
          }
          break;
        default: // Save drag
          if (nButton & (wimp_DRAG_SELECT | wimp_DRAG_ADJUST))
          {
            strncpy (gszSaveString, GetIconText (whWindow, ihIcon),
              sizeof(gszSaveString));
            DragBox (whWindow, ihIcon);
            geSaveType = SAVETYPE_ICONTEXT;
          }
          break;
      }
      if (boClearSelect
        && (gsSelect.nLineStart != -1)
        && (gsSelect.whWindow == gasEdit[ganEditOpen[nEditSearch]].whWindow)
        && (gsSelect.nEmailNum == ganEditOpen[nEditSearch]))
      {
        ClearSelection ();
      }
      boWinFound = TRUE;
    }
    nEditSearch++;
  }
}

//////////////////////////////////////////////////////////////////
// Poll 8: Act on user key presses
void Keys (wimp_block *pcBlock)
{
  wimp_w                      whWindow;
  wimp_i                      ihIcon;
  wimp_key_no                 nKey;
  int                         nEditSearch;
  bool                        boWinFound;
  int                         nStartLine;
  int                         nEndLine;
  bool                        boClearSelect;
  Caret                       sCaretPre;
  bool                        boShift;
  char                        szSnip[1024];
  int                         nLength;
  bool                        boUpdate;

  whWindow = pcBlock->key.w;
  ihIcon = pcBlock->key.i;
  nKey = pcBlock->key.c;
  boWinFound = FALSE;
  boShift = (osbyte1 (osbyte_SCAN_KEYBOARD, 0x80, 0) == 0xff);

  // Check for all of the edit windows
  nEditSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEditOpen[nEditSearch])
    {
      boClearSelect = FALSE;
      switch (nKey)
      {
        case ('C' - 64):
          CopySelectToClip ();
          boClearSelect = TRUE;
          break;
        case ('X' - 64):
          CopySelectToClip ();
          if (boShift)
          {
            boUpdate = DeleteSection (ganEditOpen[nEditSearch], & gsSelect);
            if (ganEditOpen[nEditSearch] == gsCaret.nEditNum)
            {
              if (gsCaret.nChar == 0)
              {
                nLength = ConvertString(szSnip, Tag("Snip"), sizeof(szSnip));
              }
              else
              {
                nLength = ConvertString(szSnip, Tag("SnipMid"),
                  sizeof(szSnip));
              }
              InsertText (gsCaret.nEditNum, gsCaret.nPos, gsCaret.nLine,
                szSnip, nLength);
              boUpdate = TRUE;
            }
            if (boUpdate)
            {
              EditChanged (ganEditOpen[nEditSearch]);
              ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
                & nStartLine, & nEndLine);
              UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
                nEndLine);
            }
          }
          else
          {
            if (DeleteSection (ganEditOpen[nEditSearch], & gsSelect))
            {
              EditChanged (ganEditOpen[nEditSearch]);
              ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
                & nStartLine, & nEndLine);
              UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
                nEndLine);
            }
          }
          break;
        case ('V' - 64):
          PasteClipboard ();
          EditChanged (ganEditOpen[nEditSearch]);
          break;
        case ('Z' - 64):
          boClearSelect = TRUE;
          break;
        case wimp_KEY_TAB:
          DeleteSection (ganEditOpen[nEditSearch], & gsSelect);
          InsertString (ganEditOpen[nEditSearch], gsCaret.nPos,
            gsCaret.nLine, "     ");
          ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
            & nStartLine, & nEndLine);
          MoveCaretRight (5);
          UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
            nEndLine);
          EditChanged (ganEditOpen[nEditSearch]);
          boClearSelect = TRUE;
          break;
        case wimp_KEY_INSERT:
          gasEdit[ganEditOpen[nEditSearch]].boInsert
            = !gasEdit[ganEditOpen[nEditSearch]].boInsert;
          break;
        case (wimp_KEY_RIGHT + wimp_KEY_CONTROL):
          SearchCaretRight (" \n");
          boClearSelect = TRUE;
          break;
        case (wimp_KEY_LEFT + wimp_KEY_CONTROL):
          SearchCaretLeft (" \n");
          boClearSelect = TRUE;
          break;
        case (wimp_KEY_DOWN + wimp_KEY_CONTROL):
          SearchCaretRight ("\n");
          boClearSelect = TRUE;
          break;
        case (wimp_KEY_UP + wimp_KEY_CONTROL):
          SearchCaretLeft ("\n");
          boClearSelect = TRUE;
          break;
        case (wimp_KEY_RIGHT + wimp_KEY_CONTROL + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          SearchCaretRight (" \n");
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case (wimp_KEY_LEFT + wimp_KEY_CONTROL + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          SearchCaretLeft (" \n");
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case (wimp_KEY_DOWN + wimp_KEY_CONTROL + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          SearchCaretRight ("\n");
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case (wimp_KEY_UP + wimp_KEY_CONTROL + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          SearchCaretLeft ("\n");
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case (wimp_KEY_LEFT + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          MoveCaretLeft(1);
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case (wimp_KEY_RIGHT + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          MoveCaretRight(1);
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case (wimp_KEY_UP + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          MoveCaretUp(1);
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case (wimp_KEY_DOWN + wimp_KEY_SHIFT):
          sCaretPre = gsCaret;
          MoveCaretDown(1);
          ShiftSelection (& sCaretPre, & gsCaret);
          break;
        case wimp_KEY_LEFT:
          MoveCaretLeft(1);
          boClearSelect = TRUE;
          break;
        case wimp_KEY_RIGHT:
          MoveCaretRight(1);
          boClearSelect = TRUE;
          break;
        case wimp_KEY_UP:
          MoveCaretUp(1);
          boClearSelect = TRUE;
          break;
        case wimp_KEY_DOWN:
          MoveCaretDown(1);
          boClearSelect = TRUE;
          break;

        case wimp_KEY_HOME:
          SetCaretPos (gsCaret.nEditNum, gsCaret.nLine, 0);
//          SearchCaretLeft ("\n");
          gsCaret.nCharPref = gsCaret.nChar;
          boClearSelect = TRUE;
          break;

        case wimp_KEY_COPY:
          if (gboIyonixDelete)
          {
            SetCaretPos (gsCaret.nEditNum, gsCaret.nLine,
              gasEdit[gsCaret.nEditNum].anLine[gsCaret.nLine + 1]
              - gasEdit[gsCaret.nEditNum].anLine[gsCaret.nLine] - 1);
            gsCaret.nCharPref = gsCaret.nChar;
//            SearchCaretRight ("\n");
          }
          else
          {
            if (!DeleteSection (ganEditOpen[nEditSearch], & gsSelect))
            {
              DeleteChar (ganEditOpen[nEditSearch], gsCaret.nPos,
                gsCaret.nLine);
            }
            EditChanged (ganEditOpen[nEditSearch]);
            ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
              & nStartLine, & nEndLine);
            UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
              nEndLine);
          }
          boClearSelect = TRUE;
          break;

        case wimp_KEY_BACKSPACE:
//        case wimp_KEY_DELETE:
          if (!DeleteSection (ganEditOpen[nEditSearch], & gsSelect))
          {
            if (gsCaret.nPos > 0)
            {
              MoveCaretLeft(1);
              DeleteChar (ganEditOpen[nEditSearch], gsCaret.nPos,
                gsCaret.nLine);
            }
          }
          EditChanged (ganEditOpen[nEditSearch]);
          ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
            & nStartLine, & nEndLine);
          UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine, nEndLine);
          boClearSelect = TRUE;
          break;

        case wimp_KEY_DELETE:
//        case wimp_KEY_COPY:
          if (!DeleteSection (ganEditOpen[nEditSearch], & gsSelect))
          {
            if (gboIyonixDelete)
            {
              DeleteChar (ganEditOpen[nEditSearch], gsCaret.nPos,
                gsCaret.nLine);
            }
            else
            {
              if (gsCaret.nPos > 0)
              {
                MoveCaretLeft(1);
                DeleteChar (ganEditOpen[nEditSearch], gsCaret.nPos,
                  gsCaret.nLine);
              }
            }
          }
          EditChanged (ganEditOpen[nEditSearch]);
          ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
            & nStartLine, & nEndLine);
          UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine, nEndLine);
          boClearSelect = TRUE;
          break;



        case wimp_KEY_RETURN:
            DeleteSection (ganEditOpen[nEditSearch], & gsSelect);
            InsertChar (ganEditOpen[nEditSearch], gsCaret.nPos,
              gsCaret.nLine, '\n');
            ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
              & nStartLine, & nEndLine);
            MoveCaretRight (1);
            UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
              nEndLine);
            EditChanged (ganEditOpen[nEditSearch]);
            boClearSelect = TRUE;
            break;
        default:
          if ((nKey >= 32) && (nKey < 127))
          {
            DeleteSection (ganEditOpen[nEditSearch], & gsSelect);
            InsertChar (ganEditOpen[nEditSearch], gsCaret.nPos,
              gsCaret.nLine, (char)nKey);
            ReFormat (ganEditOpen[nEditSearch], gsCaret.nLine, -1,
              & nStartLine, & nEndLine);
            MoveCaretRight (1);
            UpdateEditWindow (ganEditOpen[nEditSearch], nStartLine,
              nEndLine);
            EditChanged (ganEditOpen[nEditSearch]);
            boClearSelect = TRUE;
          }
          else
          {
            xwimp_process_key (nKey);
          }
          break;
      }
      if (boClearSelect
        && (gsSelect.nLineStart != -1)
        && (gsSelect.whWindow == whWindow)
        && (gsSelect.nEmailNum == ganEditOpen[nEditSearch]))
      {
        ClearSelection ();
      }
      boWinFound = TRUE;
    }
    nEditSearch++;
  }

  nEditSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gasEdit[ganEditOpen[nEditSearch]].whHead)
    {
      switch (nKey)
      {
        case wimp_KEY_RETURN:
          SetCaretPos (ganEditOpen[nEditSearch], 0, 0);
          gsCaret.nCharPref = gsCaret.nChar;
          break;
        default:
          xwimp_process_key (nKey);
          break;
      }
      boWinFound = TRUE;
    }
    nEditSearch++;
  }

  if (!boWinFound)
  {
    if (whWindow == gwhLogn)
    {
      switch (nKey)
      {
        case wimp_KEY_RETURN:
          gasAccount[gnAccountLogin].boPOP3GotPassword = FALSE;
          gasAccount[gnAccountLogin].boSMTPGotPassword = FALSE;
          LoginAccount (gnAccountLogin);
          CloseWindowHandle (gwhLogn);
          break;
        case wimp_KEY_ESCAPE:
          CloseWindowHandle (gwhLogn);
          break;
        case wimp_KEY_UP:
          gnAccountLogin = (gnAccountNum + gnAccountLogin - 1)
            % gnAccountNum;
          SetLoginWindow (gnAccountLogin);
          break;
        case wimp_KEY_DOWN:
          gnAccountLogin = (gnAccountLogin + 1) % gnAccountNum;
          SetLoginWindow (gnAccountLogin);
          break;
        default:
          xwimp_process_key (nKey);
          break;
      }
      boWinFound = TRUE;
    }
  }

  if (!boWinFound)
  {
    switch (nKey)
    {
      case wimp_KEY_RETURN:
        if (whWindow == gwhSave)
        {
          gnSaveFileType = 0xfff;
          SaveSave ();
          CloseMenu ();
        }
        if (whWindow == gwhAttc)
        {
          gnSaveFileType = gasDetails[gnEmailSelected]
            .asMIMEList[gnAttachmentNum].nFileType;
          AttachmentSave ();
          CloseMenu ();
        }
        if (whWindow == gwhWarn)
        {
          CloseWarning ();
        }
        if (whWindow == gwhQery)
        {
          QueryContinue ();
        }
        if (whWindow == gwhAcct)
        {
          if (gnAccountDialogue == ACCOUNT_INVALID)
          {
            SetAccountDetails (gnAccountNum);
            gnAccountDialogue = gnAccountNum;
            gnAccountNum++;
          }
          else
          {
            SetAccountDetails (gnAccountDialogue);
            SetLoginWindow (gnAccountLogin);
          }
          CloseWindowHandlePane (gwhAcct, gwhAcBa);
        }
        if (whWindow == gwhSett)
        {
          if (gnAccountSettingsDialogue != ACCOUNT_INVALID)
          {
            SetAccountSettingsDetails (gnAccountSettingsDialogue);
          }
          CloseWindowHandlePane (gwhSett, gwhSeBa);
        }
        if (whWindow == gwhUnLk)
        {
          UnlockOkay ();
          CloseWindowHandle (gwhUnLk);
        }
        if (whWindow == gwhChce)
        {
          ChoicesOkay ();
          CloseWindowHandlePane (gwhChce, gwhChBa);
        }
        if (whWindow == gwhRegi)
        {
          CloseWindowHandle (gwhRegi);
          Register ();
        }
        if (whWindow == gwhAddr)
        {
          AddressesDialogueUpdate ();
        }
        break;
      case wimp_KEY_ESCAPE:
        if ((whWindow == gwhSave) || (whWindow == gwhAttc))
        {
          CloseMenu ();
        }
        if (whWindow == gwhWarn)
        {
          CloseWarning ();
        }
        if (whWindow == gwhQery)
        {
          QueryCancel ();
        }
        if (whWindow == gwhAcct)
        {
          CloseWindowHandlePane (gwhAcct, gwhAcBa);
          SetAccountDialogue (gnAccountDialogue);
        }
        if (whWindow == gwhSett)
        {
          CloseWindowHandlePane (gwhSett, gwhSeBa);
          SetAccountSettingsDialogue (gnAccountSettingsDialogue);
        }
        if (whWindow == gwhUnLk)
        {
          CloseWindowHandle (gwhUnLk);
        }
        if (whWindow == gwhChce)
        {
          CloseWindowHandlePane (gwhChce, gwhChBa);
        }
        if (whWindow == gwhRegi)
        {
          RegisterCancel ();
          CloseWindowHandle (gwhRegi);
        }
        if (whWindow == gwhAddr)
        {
          CloseWindowHandle (gwhAddr);
        }
        break;
      default:
        xwimp_process_key (nKey);
        break;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Poll 9: Act on menu selections
void MenuSelect (wimp_block *pcBlock)
{
  wimp_pointer                sPointer;
  int                         nStartLine;
  int                         nEndLine;
  char                        szSnip[1024];
  int                         nLength;

  xwimp_get_pointer_info (& sPointer);

  if (gpcMenuCurrent == gpcIconBarMenu)
  {
    switch (pcBlock->selection.items[0])
    {
      case 1: // Account
        if (pcBlock->selection.items[1] == -1)
        {
          OpenLoginWindow (gnAccount);
        }
        else
        {
          MenuSelectIconbarAccount (pcBlock->selection.items[1]);
        }
        break;
      case 2: // New account
        OpenAccountWindow (ACCOUNT_INVALID);
        break;
      case 3: // Choices
        OpenChoicesWindow ();
        break;
      case 4: // Addresses
        OpenAddressesWindow (ADDRESS_INVALID);
        break;
      case 5: // Lock
        Lock ();
        break;
      case 6: // Quit
        if (gnRegistered == REGISTERED)
        {
          PreQuit ();
        }
        else
        {
          OpenRegisterWindow ();
        }
        break;
      case 7: // Quit (Unregistered)
        PreQuit ();
        break;
      default:
        break;
    }
  }

  if (gpcMenuCurrent == gpcMainMenu)
  {
    switch (pcBlock->selection.items[0])
    {
      case 0: // Check mail
        CheckNetCom (NET_POP3_LIST);
        break;
      case 1: // Selection
        switch (pcBlock->selection.items[1])
        {
          case 0: // Open emails
            OpenSelectedEmails ();
            break;
          case 1: // Download emails
            CompileSelectedList ();
            CheckNetCom (NET_POP3_DOWNLOAD);
            break;
          case 3: // Forget emails
            DestroySelectedEmails ();
            break;
          case 4: // Delete emails
            ShowQueryTag ("Ms3", "MsYes", "MsNo", QUERYACTION_DELETEEMAILS);
            break;
          default:
            break;
        }
        break;
      case 2: // Send
        switch (pcBlock->selection.items[1])
        {
          case 0: // New
            CreateEditWindow ();
            break;
          case 1: // Reply
            CreateReplyMessage (ganEmailSave[0]);
            break;
          case 2: // Reply to all
            CreateReplyToAllMessage (ganEmailSave[0]);
            break;
          case 3: // Forward
            CreateForwardMessage (ganEmailSave[0]);
            break;
          default:
            break;
        }
        break;
      case 3: // Highlight
        switch (pcBlock->selection.items[1])
        {
          case 0: // All
            SelectAllEmails ();
            break;
          case 1: // None
            ClearAllSelected ();
            break;
          case 2: // Invert
            InvertAllEmails ();
            break;
          default:
            break;
        }
        break;
      case 4: // Account
        switch (pcBlock->selection.items[1])
        {
          case 0: // Profile
            OpenAccountWindow (gnAccount);
            break;
          case 1: // Options
            OpenAccountSettingsWindow (gnAccount);
            break;
          default:
            break;
        }
        break;
      case 5: // Stop operation
        if (geConnectStatus != CONNECTED_OFF)
        {
          ShowQueryTag ("Ms1", "MsYes", "MsNo", QUERYACTION_STOP);
        }
        break;
      default:
        break;
    }
  }
  if (gpcMenuCurrent == gpcEmailMenu)
  {
    switch (pcBlock->selection.items[0])
    {
      case 2: // Edit
        switch (pcBlock->selection.items[1])
        {
          case 1: // Copy
            CopySelectToClip ();
            ClearSelection ();
            break;
          case 3: // Clear
            ClearSelection ();
            break;
          default:
            break;
        }
        break;
      case 3: // Send
        switch (pcBlock->selection.items[1])
        {
          case 0: // Reply
            CreateReplyMessage (gnEmailSelected);
            break;
          case 1: // Reply to all
            CreateReplyToAllMessage (gnEmailSelected);
            break;
          case 2: // Forward
            CreateForwardMessage (gnEmailSelected);
            break;
          default:
            break;
        }
        break;
      case 4: // Header
        if (gasDetails[gnEmailSelected].nLineHide == 0)
        {
          ShowHeader (gnEmailSelected, FALSE);
        }
        else
        {
          ShowHeader (gnEmailSelected, TRUE);
        }
        break;
      default:
        break;
    }
  }

  if (gpcMenuCurrent == gpcLognMenu)
  {
    SetLoginWindow (pcBlock->selection.items[0]);
  }

  if (gpcMenuCurrent == gpcNewMenu)
  {
    switch (pcBlock->selection.items[0])
    {
      case 2: // Edit
        switch (pcBlock->selection.items[1])
        {
          case 0: // Cut
            CopySelectToClip ();
            if (DeleteSection (gnEmailSelected, & gsSelect))
            {
              EditChanged (gnEmailSelected);
              ReFormat (gnEmailSelected, gsCaret.nLine, -1,
                & nStartLine, & nEndLine);
              UpdateEditWindow (gnEmailSelected, nStartLine,
                nEndLine);
            }
            break;
          case 1: // Copy
            CopySelectToClip ();
            ClearSelection ();
            break;
          case 2: // Paste
            PasteClipboard ();
            EditChanged (gnEmailSelected);
            break;
          case 3: // Clear
            ClearSelection ();
            break;
          case 4: // Snip
            CopySelectToClip ();
            DeleteSection (gnEmailSelected, & gsSelect);
            EditChanged (gnEmailSelected);
            if (gsCaret.nChar == 0)
            {
              nLength = ConvertString(szSnip, Tag("Snip"), sizeof(szSnip));
            }
            else
            {
              nLength = ConvertString(szSnip, Tag("SnipMid"),
                sizeof(szSnip));
            }
            InsertText (gsCaret.nEditNum, gsCaret.nPos, gsCaret.nLine,
              szSnip, nLength);
            ReFormat (gnEmailSelected, gsCaret.nLine, -1,
              & nStartLine, & nEndLine);
            UpdateEditWindow (gnEmailSelected, nStartLine,
              nEndLine);
            break;
          default:
            break;
        }
        break;
      case 3: // Send
        SendEmail (gnEmailSelected);
        break;
      case 4: // Advanced
        if (gasEdit[gnEmailSelected].boAdvanced)
        {
          ShowAdvanced (gnEmailSelected, FALSE);
        }
        else
        {
          ShowAdvanced (gnEmailSelected, TRUE);
        }
        break;
      default:
        break;
    }
  }

  if (gpcMenuCurrent == gpcChoiceAcctMenu)
  {
    SetChoicesAccount (pcBlock->selection.items[0] - 1);
  }

  if (gpcMenuCurrent == gpcLocalFontMenu)
  {
    ChoicesLocalFontSelect (& pcBlock->selection);

    if (sPointer.buttons & wimp_CLICK_ADJUST)
    {
      SetUpFontMenu (gpcLocalFontMenu, gszLocalChoiceFont);
    }
  }

  if (gpcMenuCurrent == gpcRemoteFontMenu)
  {
    ChoicesRemoteFontSelect (& pcBlock->selection);

    if (sPointer.buttons & wimp_CLICK_ADJUST)
    {
      SetUpFontMenu (gpcRemoteFontMenu, gszRemoteChoiceFont);
    }
  }

  if (gpcMenuCurrent == gpcAddrMenu)
  {
    switch (geAddressMenuType)
    {
      case ADDRESSMENU_ADDRESSES:
        SetAddressesDialogue (pcBlock->selection.items[0]);
        break;
      case ADDRESSMENU_TO:
        AddAddressToIcon (gasEdit[gnEmailSelected].whHead, (wimp_i)0,
          pcBlock->selection.items[0], TO_MAX);
        break;
      case ADDRESSMENU_CC:
        AddAddressToIcon (gasEdit[gnEmailSelected].whHead, (wimp_i)9,
          pcBlock->selection.items[0], CC_MAX);
        break;
      case ADDRESSMENU_BCC:
        AddAddressToIcon (gasEdit[gnEmailSelected].whHead, (wimp_i)12,
          pcBlock->selection.items[0], BCC_MAX);
        break;
      default:
        break;
    }
    GenerateAddressesMenu (geAddressMenuType);
  }

  if (gpcMenuCurrent == gpcAcctMenu)
  {
    MenuSelectIconbarAccount (pcBlock->selection.items[0]);
  }

  if (sPointer.buttons & wimp_CLICK_ADJUST)
  {
    if (gpcMenuCurrent == gpcIconBarMenu)
    {
      SetupIconbarMenu ();
    }
    if (gpcMenuCurrent == gpcMainMenu)
    {
      SetUpMainMenu ();
    }
    if (gpcMenuCurrent == gpcEmailMenu)
    {
      SetUpEmailMenu ();
    }
    if (gpcMenuCurrent == gpcNewMenu)
    {
      SetUpNewMenu ();
    }
    if ((gpcMenuCurrent == gpcLognMenu)
      || (gpcMenuCurrent == gpcAcctMenu))
    {
      GenerateAccountMenu (gpcMenuCurrent);
    }
    if (gpcMenuCurrent == gpcChoiceAcctMenu)
    {
      GenerateAccountMenuNone (gpcMenuCurrent);
    }

    OpenMenu (gpcMenuCurrent, gnMenuXpos, gnMenuYpos);
  }
}

//////////////////////////////////////////////////////////////////
// Poll 7: User has finished dragging an object
void UserDragBox (wimp_block *pcBlock)
{
  char                        *szFilename;
  wimp_w                      whWindow;
  wimp_pointer                sPointer;
  wimp_message                sMessage;
  Selection                   sSelect;
  wimp_auto_scroll_info       sScrollInfo;

  pcBlock = pcBlock;

  xdragasprite_stop ();
  gboDrag = FALSE;

  xwimp_get_pointer_info (& sPointer);

  whWindow = sPointer.w;

  if ((whWindow != gwhMain)
     && (whWindow != gwhSave)
     && (whWindow != gwhWarn))
  {
    switch (geSaveType)
    {
      case SAVETYPE_EMAILS:
        sMessage.data.data_xfer.w = whWindow;
        sMessage.data.data_xfer.i = sPointer.i;
        sMessage.data.data_xfer.pos = sPointer.pos;
        sMessage.data.data_xfer.est_size = EmailSaveSize ();
        sMessage.data.data_xfer.file_type = gnSaveFileType;

        strncpy (sMessage.data.data_xfer.file_name, Tag ("SaveEmailSel"),
211);
        sMessage.data.data_xfer.file_name[211] = 0;

        sMessage.size = WORDALIGN((44 + 1 + strlen (Tag("SaveEmailSel"))));
        sMessage.your_ref = 0;
        sMessage.action = message_DATA_SAVE;

        xwimp_send_message_to_window (wimp_USER_MESSAGE, & sMessage,
                   whWindow, sPointer.i, NULL);
        break;
      case SAVETYPE_FILE:
        sMessage.data.data_xfer.w = whWindow;
        sMessage.data.data_xfer.i = sPointer.i;
        sMessage.data.data_xfer.pos = sPointer.pos;
        sMessage.data.data_xfer.est_size = EmailSaveSize ();
        sMessage.data.data_xfer.file_type = gnSaveFileType;

        szFilename = GetIconText (gwhSave, 2);
        while (strchr (szFilename, '.'))
        {
          szFilename = strchr(szFilename, '.') + 1;
        }

        strncpy (sMessage.data.data_xfer.file_name, szFilename, 211);
        sMessage.data.data_xfer.file_name[211] = 0;

        sMessage.size = WORDALIGN((44 + 1 + strlen (szFilename)));
        sMessage.your_ref = 0;
        sMessage.action = message_DATA_SAVE;

        xwimp_send_message_to_window (wimp_USER_MESSAGE, & sMessage,
                   whWindow, sPointer.i, NULL);
        break;
      case SAVETYPE_ICONTEXT:
        sMessage.data.data_xfer.w = whWindow;
        sMessage.data.data_xfer.i = sPointer.i;
        sMessage.data.data_xfer.pos = sPointer.pos;
        sMessage.data.data_xfer.est_size = strlen(gszSaveString) + 1;
        sMessage.data.data_xfer.file_type = 0xfff;

        strncpy (sMessage.data.data_xfer.file_name, "IconText", 12);
        sMessage.data.data_xfer.file_name[11] = 0;

        sMessage.size = WORDALIGN((44 + 12));
        sMessage.your_ref = 0;
        sMessage.action = message_DATA_SAVE;

        xwimp_send_message_to_window (wimp_USER_MESSAGE, & sMessage,
          whWindow, sPointer.i, NULL);
        break;
      case SAVETYPE_SELECTCHOOSE:
        SetNullPollActive (NULLPOLL_DEACTIVE_FAST);
        if (gsSelect.boEdit)
        {
          FindEditCoords (gsSelect.nEmailNum, sPointer.pos.x,
            sPointer.pos.y, & sSelect.nLineEnd, & sSelect.nCharEnd);
        }
        else
        {
          FindEmailCoords (gsSelect.nEmailNum, sPointer.pos.x,
            sPointer.pos.y, & sSelect.nLineEnd, & sSelect.nCharEnd);
        }
        sSelect.boEdit = gsSelect.boEdit;
        sSelect.nLineStart = gnSelectLineStart;
        sSelect.nCharStart = gnSelectCharStart;
        sSelect.whWindow = gsSelect.whWindow;
        sSelect.nEmailNum = gsSelect.nEmailNum;
        ChangeSelection (& sSelect);
        sScrollInfo.w = gsSelect.whWindow;
        sScrollInfo.pause_zone_sizes.x0 = 80;
        sScrollInfo.pause_zone_sizes.y0 = 80;
        sScrollInfo.pause_zone_sizes.x1 = 80;
        sScrollInfo.pause_zone_sizes.y1 = 80;
        sScrollInfo.pause_duration = 0;
        sScrollInfo.state_change = NULL;
        sScrollInfo.handle = NULL;
        xwimp_auto_scroll (0, & sScrollInfo, NULL);
        break;
      case SAVETYPE_SELECTSAVE:
        if (gpcCopySelect)
        {
          sMessage.data.data_xfer.w = whWindow;
          sMessage.data.data_xfer.i = sPointer.i;
          sMessage.data.data_xfer.pos = sPointer.pos;
          sMessage.data.data_xfer.est_size = gnCopySelectSize;
          sMessage.data.data_xfer.file_type = 0xfff;

          strncpy (sMessage.data.data_xfer.file_name,
            Tag ("SaveSel"), 12);
          sMessage.data.data_xfer.file_name[11] = 0;

          sMessage.size = WORDALIGN((44 + 12));
          sMessage.your_ref = 0;
          sMessage.action = message_DATA_SAVE;

          xwimp_send_message_to_window (wimp_USER_MESSAGE, & sMessage,
            whWindow, sPointer.i, NULL);
        }
        break;
      case SAVETYPE_COLUMN:
        SetNullPollActive (NULLPOLL_DEACTIVE_FAST);
        SetColumnFromScreen (gnDragColumn, sPointer.pos.x);
        break;
      case SAVETYPE_ATTACHMENT:
        sMessage.data.data_xfer.w = whWindow;
        sMessage.data.data_xfer.i = sPointer.i;
        sMessage.data.data_xfer.pos = sPointer.pos;
        switch (gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].
          eEncoding)
        {
          case CTENCODING_QUOTEDPRINTABLE:
          case CTENCODING_PLAIN:
          default:
            sMessage.data.data_xfer.est_size = gasDetails[gnEmailSelected]
              .asMIMEList[gnAttachmentNum].nSizePre;
            break;
          case CTENCODING_BASE64:
            sMessage.data.data_xfer.est_size = ((gasDetails[gnEmailSelected]
              .asMIMEList[gnAttachmentNum].nSizePre * 3) / 4) + 3;
            break;
        }
        sMessage.data.data_xfer.file_type = gnSaveFileType;

        szFilename = GetIconText (gwhAttc, 2);
        while (strchr (szFilename, '.'))
        {
          szFilename = strchr(szFilename, '.') + 1;
        }

        strncpy (sMessage.data.data_xfer.file_name, szFilename, 211);
        sMessage.data.data_xfer.file_name[211] = 0;

        sMessage.size = WORDALIGN((44 + 1 + strlen (szFilename)));
        sMessage.your_ref = 0;
        sMessage.action = message_DATA_SAVE;

        xwimp_send_message_to_window (wimp_USER_MESSAGE, & sMessage,
                   whWindow, sPointer.i, NULL);
        break;
      default:
        break;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Opens the pane for a window
void OpenWindowPane (PANE ePaneType, wimp_w whPane, wimp_open * psMainOpen, wimp_open * psPaneOpen, int nHeight)
{
  switch (ePaneType)
  {
    default:
    case PANE_TOP:
      *psPaneOpen = *psMainOpen;
      psPaneOpen->w = whPane;
      xwimp_open_window (psPaneOpen);
      psMainOpen->next = psPaneOpen->w;
      break;
    case PANE_BASE:
      *psPaneOpen = *psMainOpen;
      psPaneOpen->visible.y1 = psMainOpen->visible.y0 + nHeight;
      psPaneOpen->w = whPane;
      xwimp_open_window (psPaneOpen);
      psMainOpen->next = psPaneOpen->w;
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Poll 2: Open window given window block
void OpenWindow (wimp_block *pcBlock)
{
  wimp_w                      whWindow;
  bool                        boWinFound;
  int                         nEmailSearch;
  wimp_open                   sPaneOpen;
  PANE                        ePaneType;
  int                         nHeight = 0;

  whWindow = pcBlock->open.w;

  ePaneType = PANE_NONE;
  boWinFound = FALSE;
  if (whWindow == gwhMain)
  {
    ePaneType = PANE_TOP;
    boWinFound = TRUE;
    nHeight = MAIN_PANE_HEIGHT;
    OpenWindowPane (ePaneType, gwhMaHe, & pcBlock->open, & sPaneOpen,
      nHeight);
  }

  if (whWindow == gwhAcct)
  {
    ePaneType = PANE_BASE;
    boWinFound = TRUE;
    nHeight = ACCOUNT_PANE_HEIGHT;
    OpenWindowPane (ePaneType, gwhAcBa, & pcBlock->open, & sPaneOpen,
      nHeight);
  }

  if (whWindow == gwhChce)
  {
    ePaneType = PANE_BASE;
    boWinFound = TRUE;
    nHeight = CHOICES_PANE_HEIGHT;
    OpenWindowPane (ePaneType, gwhChBa, & pcBlock->open, & sPaneOpen,
      nHeight);
  }

  if (whWindow == gwhSett)
  {
    ePaneType = PANE_BASE;
    boWinFound = TRUE;
    nHeight = SETTINGS_PANE_HEIGHT;
    OpenWindowPane (ePaneType, gwhSeBa, & pcBlock->open, & sPaneOpen,
      nHeight);
  }

  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEmailsOpen[nEmailSearch])
    {
      sPaneOpen = pcBlock->open;
      sPaneOpen.w = gasDetails[ganEmailsOpen[nEmailSearch]].whHead;
      xwimp_open_window (& sPaneOpen);
      pcBlock->open.next = sPaneOpen.w;
      ePaneType = PANE_TOP;
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }

  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEditOpen[nEmailSearch])
    {
      sPaneOpen = pcBlock->open;
      sPaneOpen.w = gasEdit[ganEditOpen[nEmailSearch]].whHead;
      xwimp_open_window (& sPaneOpen);
      pcBlock->open.next = sPaneOpen.w;
      ePaneType = PANE_TOP;
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }
  xwimp_open_window (& pcBlock->open);

  if (ePaneType != PANE_NONE)
  {
    switch (ePaneType)
    {
      case PANE_TOP:
        // Check to see whether the pane is in the correct position
        if ((sPaneOpen.visible.x0 != pcBlock->open.visible.x0)
          || (sPaneOpen.visible.y1 != pcBlock->open.visible.y1)
          || (sPaneOpen.visible.x1 != pcBlock->open.visible.x1))
        {
          sPaneOpen.visible = pcBlock->open.visible;
          xwimp_open_window (& sPaneOpen);
        }
        break;
      case PANE_BASE:
        // Check to see whether the pane is in the correct position
        if ((sPaneOpen.visible.x0 != pcBlock->open.visible.x0)
          || (sPaneOpen.visible.y0 != pcBlock->open.visible.y0)
          || (sPaneOpen.visible.x1 != pcBlock->open.visible.x1))
        {
          sPaneOpen.visible = pcBlock->open.visible;
          sPaneOpen.visible.y1 = pcBlock->open.visible.y0 + nHeight;
          xwimp_open_window (& sPaneOpen);
        }
        break;
      default:
        // Do nothing
        break;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Open a window on screen that is currently closed
void OpenWindowInit (wimp_w whWindow)
{
  wimp_window_state           sState;

  sState.w = whWindow;
  xwimp_get_window_state (& sState);
  sState.next = wimp_TOP;
  xwimp_open_window ((wimp_open *)& sState);
}

//////////////////////////////////////////////////////////////////
// Open a window on screen that is currently closed with its pane
void OpenWindowInitPane (wimp_w whWindow, wimp_w whPane, PANE ePaneType)
{
  wimp_window_state           sState;
  wimp_window_state           sPane;

  sState.w = whWindow;
  xwimp_get_window_state (& sState);
  sState.next = wimp_TOP;
  xwimp_open_window ((wimp_open *)& sState);

  switch (ePaneType)
  {
    default:
    case PANE_TOP:
      sState.w = whPane;
      xwimp_open_window ((wimp_open *)& sState);
      break;
    case PANE_BASE:
      sPane.w = whPane;
      xwimp_get_window_state (& sPane);
      sState.w = whPane;
      sState.visible.y1
        = sState.visible.y0 + (sPane.visible.y1 - sPane.visible.y0);
      xwimp_open_window ((wimp_open *)& sState);
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Open a window on screen that is currently closed with its pane
void OpenWindowInitPaneNew (wimp_w whWindow, wimp_w whPane, PANE ePaneType)
{
  wimp_window_state           sState;
  wimp_window_state           sPane;

  sState.w = whWindow;
  xwimp_get_window_state (& sState);
  sState.yscroll = 0;
  sState.next = wimp_TOP;
  xwimp_open_window ((wimp_open *)& sState);

  switch (ePaneType)
  {
    default:
    case PANE_TOP:
      sState.w = whPane;
      xwimp_open_window ((wimp_open *)& sState);
      break;
    case PANE_BASE:
      sPane.w = whPane;
      xwimp_get_window_state (& sPane);
      sState.w = whPane;
      sState.visible.y1
        = sState.visible.y0 + (sPane.visible.y1 - sPane.visible.y0);
      xwimp_open_window ((wimp_open *)& sState);
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Open a window in the centre of the screen
void OpenWindowInitCentre (wimp_w whWindow)
{
  int                         nHeight;
  int                         nWidth;
  int                         nEigFactor;
  int                         nSize;
  int                         nPosition;
  wimp_window_state           sState;

  sState.w = whWindow;
  xwimp_get_window_state (& sState);
  sState.next = wimp_TOP;

  nWidth = sState.visible.x1 - sState.visible.x0;
  nHeight = sState.visible.y1 - sState.visible.y0;

  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_XEIG_FACTOR,
    & nEigFactor, NULL);
  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_XWIND_LIMIT,
    & nSize, NULL);
  nPosition = ((nSize << nEigFactor) - nWidth) / 2;
  sState.visible.x0 = nPosition;
  sState.visible.x1 = nPosition + nWidth;

  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_YEIG_FACTOR,
    & nEigFactor, NULL);
  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_YWIND_LIMIT,
    & nSize, NULL);
  nPosition = ((nSize << nEigFactor) - nHeight) / 2;
  sState.visible.y0 = nPosition;
  sState.visible.y1 = nPosition + nHeight;

  xwimp_open_window ((wimp_open *)& sState);
}

//////////////////////////////////////////////////////////////////
// Open a window in the centre of the screen with a pane
void OpenWindowInitPaneCentreSize (wimp_w whWindow, wimp_w whPane, PANE ePaneType, int nWidth, int nHeight)
{
//  int                         nHeight;
//  int                         nWidth;
  int                         nEigFactor;
  int                         nSize;
  int                         nPosition;
  wimp_window_state           sState;
  wimp_window_state           sPane;

  sState.w = whWindow;
  xwimp_get_window_state (& sState);
  sState.next = wimp_TOP;
  sState.xscroll = 0;
  sState.yscroll = 0;

//  nWidth = sState.visible.x1 - sState.visible.x0;
//  nHeight = sState.visible.y1 - sState.visible.y0;

  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_XEIG_FACTOR,
    & nEigFactor, NULL);
  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_XWIND_LIMIT,
    & nSize, NULL);
  nPosition = ((nSize << nEigFactor) - nWidth) / 2;
  sState.visible.x0 = nPosition;
  sState.visible.x1 = nPosition + nWidth;

  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_YEIG_FACTOR,
    & nEigFactor, NULL);
  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_YWIND_LIMIT,
    & nSize, NULL);
  nPosition = ((nSize << nEigFactor) - nHeight) / 2;
  sState.visible.y0 = nPosition;
  sState.visible.y1 = nPosition + nHeight;

  xwimp_open_window ((wimp_open *)& sState);

  switch (ePaneType)
  {
    default:
    case PANE_TOP:
      sState.w = whPane;
      xwimp_open_window ((wimp_open *)& sState);
      break;
    case PANE_BASE:
      sPane.w = whPane;
      xwimp_get_window_state (& sPane);
      sState.w = whPane;
      sState.visible.y1
        = sState.visible.y0 + (sPane.visible.y1 - sPane.visible.y0);
      xwimp_open_window ((wimp_open *)& sState);
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Open a given menu at the given position on screen
void OpenMenu (wimp_menu * pcMenu, int nXPos, int nYPos)
{
  xwimp_create_menu (pcMenu, nXPos, nYPos);

  gnMenuXpos = nXPos;
  gnMenuYpos = nYPos;
  gpcMenuCurrent = pcMenu;
}

//////////////////////////////////////////////////////////////////
// Poll 3: Close a window
void CloseWindow (wimp_block *pcBlock)
{
  wimp_w                      whWindow;
  bool                        boWinFound;
  int                         nEmailSearch;

  whWindow = pcBlock->open.w;

  boWinFound = FALSE;
  if (whWindow == gwhMain)
  {
    err (xwimp_close_window (whWindow));
    err (xwimp_close_window (gwhMaHe));
    boWinFound = TRUE;
  }

  if (whWindow == gwhAcct)
  {
    err (xwimp_close_window (whWindow));
    err (xwimp_close_window (gwhAcBa));
    boWinFound = TRUE;
  }

  if (whWindow == gwhChce)
  {
    err (xwimp_close_window (whWindow));
    err (xwimp_close_window (gwhChBa));
    boWinFound = TRUE;
  }

  if (whWindow == gwhSett)
  {
    err (xwimp_close_window (whWindow));
    err (xwimp_close_window (gwhSeBa));
    boWinFound = TRUE;
  }

  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEmailsOpen[nEmailSearch])
    {
      err( xwimp_close_window (whWindow));
      err( xwimp_close_window
        (gasDetails[ganEmailsOpen[nEmailSearch]].whHead));
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }

  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEditOpen[nEmailSearch])
    {
      if (gasEdit[ganEditOpen[nEmailSearch]].boChanged)
      {
        gwhWindowClose = whWindow;
        ShowQueryTagVolatile ("Ms6", "MsDiscard", "MsCancel",
          QUERYACTION_CLOSEEDIT);
      }
      else
      {
        err (xwimp_close_window (whWindow));
        err (xwimp_close_window (gasEdit[ganEditOpen[nEmailSearch]].whHead));
        DestroyEditWindow (ganEditOpen[nEmailSearch]);
      }
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }

  if (!boWinFound)
  {
    wimp_close_window (whWindow);
  }
}

//////////////////////////////////////////////////////////////////
// Close window given handle
void CloseWindowHandle (wimp_w whWindow)
{
  wimp_close_window (whWindow);
}

//////////////////////////////////////////////////////////////////
// Close window given handle and its pane
void CloseWindowHandlePane (wimp_w whWindow, wimp_w whPane)
{
  wimp_close_window (whWindow);
  wimp_close_window (whPane);
}

//////////////////////////////////////////////////////////////////
// Close the currently open menu
void CloseMenu (void)
{
  xwimp_create_menu ((wimp_menu*)-1, 0, 0);

  gnMenuXpos = 0;
  gnMenuYpos = 0;
  gpcMenuCurrent = NULL;
}

//////////////////////////////////////////////////////////////////
// Create an iconbar icon
wimp_i CreateIconbarIcon (char * szSprite, int nWidth, int nHeight)
{
  wimp_i                      ihIcon;
  wimp_icon_create            sIconBlock;

  sIconBlock.w = wimp_ICON_BAR_RIGHT;
  sIconBlock.icon.extent.x0 = 0;
  sIconBlock.icon.extent.y0 = 0;
  sIconBlock.icon.extent.x1 = nWidth;
  sIconBlock.icon.extent.y1 = nHeight;
  sIconBlock.icon.flags = wimp_ICON_SPRITE |
                   (wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT);
  strncpy(sIconBlock.icon.data.sprite, szSprite, 12);

  ihIcon = wimp_create_icon (& sIconBlock);

  return ihIcon;
}

//////////////////////////////////////////////////////////////////
// Create window from Templates file
wimp_w LoadTemplate (char * szWindowTitle)
{
  wimp_window                 *pcWindow;
  char *                      pcIndirected;
  int                         nWindowSize;
  int                         nIndirectedSize;
  char                        szTitle[12];
  wimp_w                      whWindow;

  wimp_load_template (0, NULL, NULL, NULL, szWindowTitle, 0,
    & nWindowSize, & nIndirectedSize);

  pcWindow = (wimp_window*)malloc (nWindowSize);
  pcIndirected = malloc (nIndirectedSize);
  strncpy (szTitle, szWindowTitle, 12);

  wimp_load_template (pcWindow, pcIndirected, pcIndirected + nIndirectedSize,
    gacFontRef, szWindowTitle, 0, NULL, NULL);

  whWindow = wimp_create_window (pcWindow);

  free((void *)pcWindow);

  return whWindow;
}

//////////////////////////////////////////////////////////////////
// Create window from Templates file with sprites
wimp_w LoadTemplateSprites (char * szWindowTitle, osspriteop_area * pcSpriteArea)
{
  wimp_window                 *pcWindow;
  char *                      pcIndirected;
  int                         nWindowSize;
  int                         nIndirectedSize;
  char                        szTitle[12];
  wimp_w                      whWindow;

  wimp_load_template (0, NULL, NULL, NULL, szWindowTitle, 0,
    & nWindowSize, & nIndirectedSize);

  pcWindow = (wimp_window*)malloc (nWindowSize);
  pcIndirected = malloc (nIndirectedSize);
  strncpy (szTitle, szWindowTitle, 12);

  wimp_load_template (pcWindow, pcIndirected, pcIndirected + nIndirectedSize,
    gacFontRef, szWindowTitle, 0, NULL, NULL);

  if (pcSpriteArea)
  {
    pcWindow->sprite_area = pcSpriteArea;
  }

  whWindow = wimp_create_window (pcWindow);

  free((void *)pcWindow);

  return whWindow;
}

//////////////////////////////////////////////////////////////////
// Create Main Head window from Templates file with sprites
wimp_w LoadTemplateMaHe (char * szWindowTitle, osspriteop_area * pcSpriteArea)
{
  wimp_window                 *pcWindow;
  char *                      pcIndirected;
  int                         nWindowSize;
  int                         nIndirectedSize;
  char                        szTitle[12];
  wimp_w                      whWindow;

  wimp_load_template (0, NULL, NULL, NULL, szWindowTitle, 0,
    & nWindowSize, & nIndirectedSize);

  pcWindow = (wimp_window*)malloc (nWindowSize);
  pcIndirected = malloc (nIndirectedSize);
  strncpy (szTitle, szWindowTitle, 12);

  wimp_load_template (pcWindow, pcIndirected, pcIndirected + nIndirectedSize,
    gacFontRef, szWindowTitle, 0, NULL, NULL);

  if (pcSpriteArea)
  {
    pcWindow->sprite_area = pcSpriteArea;
  }

  pcWindow->icons[0].data.indirected_sprite.area = pcSpriteArea;

  whWindow = wimp_create_window (pcWindow);

  free((void *)pcWindow);

  return whWindow;
}

//////////////////////////////////////////////////////////////////
// Create a menu from a text string - usually kept in the messages file
wimp_menu * CreateMenu (char * szMenu)
{
  wimp_menu                   *pcMenu;
  char *                      pcBuffer;
  char *                      nAt = 0;
  char *                      nAt2 = 0;
  int                         nWidth = 0;
  wimp_menu_flags             uFlags;
  char                        szMenuString[512];
  char *                      pcMenuString;
  int                         nMenuItems;
  char                        *szItem;
  int                         nMenuEntry;
  int                         nStringLen;

  nMenuItems = -1;
  szItem = szMenu;
  while (szItem)
  {
    nMenuItems++;
    szItem = strchr(szItem + 1, ',');
  }

  pcMenu = (wimp_menu*)malloc (wimp_SIZEOF_MENU(nMenuItems));
  pcBuffer = (char *)malloc (strlen(szMenu));

  nAt = strchr (szMenu, ',');
  if (!nAt)
  {
    nAt = (char *)strlen (szMenu);
  }
  else
  {
    nAt -= (int)szMenu;
  }
  strncpy (szMenuString, szMenu, (int)nAt);
  szMenuString[(int)nAt] = 0;

  if (strlen (szMenuString) >= 12)
  {
    strcpy (pcBuffer, szMenuString);
    pcMenu->title_data.indirected_text.text = pcBuffer;
    pcBuffer += strlen (szMenuString) + 1;
    uFlags = wimp_MENU_TITLE_INDIRECTED;
  }
  else
  {
    strncpy (pcMenu->title_data.text, szMenuString, 12);
    uFlags = 0u;
  }
  pcMenu->title_fg = wimp_COLOUR_BLACK;
  pcMenu->title_bg = wimp_COLOUR_LIGHT_GREY;
  pcMenu->work_fg = wimp_COLOUR_BLACK;
  pcMenu->work_bg = wimp_COLOUR_WHITE;

  pcMenu->height = 44;
  pcMenu->gap = 0;

  nMenuEntry = 0;
  do
  {
    pcMenu->entries[nMenuEntry].sub_menu = (wimp_menu*)-1;
    pcMenu->entries[nMenuEntry].icon_flags = wimp_ICON_TEXT
                   | wimp_ICON_FILLED
                   | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT);
    nAt2 = nAt + 1;

    nAt = strchr (szMenu + (int)nAt2, ',');
    if (!nAt)
    {
      nAt = (char *)strlen (szMenu) + 1;
    }
    else
    {
      nAt -= (int)szMenu;
    }
    strncpy (szMenuString, szMenu + (int)nAt2, (int)nAt - (int)nAt2);
    szMenuString[(int)nAt - (int)nAt2] = 0;

    pcMenuString = szMenuString;

    if (pcMenuString[0] == '+')
    {
      uFlags = wimp_MENU_TICKED;
      pcMenuString++;
    }
    if (pcMenuString[0] == '-')
    {
      uFlags |= wimp_MENU_SEPARATE;
      pcMenuString++;
    }
    if (pcMenuString[0] == '|')
    {
      uFlags |= wimp_MENU_WRITABLE;
      pcMenuString++;
    }
    if (pcMenuString[0] == '>')
    {
      pcMenuString++;
      if (gnMenuWins < (int)sizeof(gawhMenuWinHandle))
      {
        gawhMenuWinHandle[gnMenuWins] = LoadTemplate (pcMenuString);
        pcMenu->entries[nMenuEntry].sub_menu
                   = (wimp_menu*)gawhMenuWinHandle[gnMenuWins];

        gnMenuWins++;
      }
    }

    nStringLen = (int)strlen (pcMenuString);
    if (strlen (pcMenuString) >= 12)
    {
      pcMenu->entries[nMenuEntry].icon_flags |= wimp_ICON_INDIRECTED;
      pcMenu->entries[nMenuEntry].data.indirected_text.text = pcBuffer;
      pcMenu->entries[nMenuEntry].data.indirected_text.validation = NULL;
      pcMenu->entries[nMenuEntry].data.indirected_text.size = nStringLen + 1;
      strcpy (pcBuffer, pcMenuString);
      pcBuffer += nStringLen + 1;
    }
    else
    {
      strncpy (pcMenu->entries[nMenuEntry].data.text, pcMenuString, 12);
    }

    pcMenu->entries[nMenuEntry].menu_flags = uFlags;
    if (nStringLen > nWidth)
    {
      nWidth = nStringLen;
    }
    nMenuEntry++;
    uFlags = 0u;
  } while ((int)nAt < (int)strlen (szMenu));

  pcMenu->width = (nWidth + 1) * 16;
  pcMenu->entries[nMenuEntry - 1].menu_flags |= wimp_MENU_LAST;

  return pcMenu;
}

//////////////////////////////////////////////////////////////////
// Get the text string from an icon
char * GetIconText (wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_state             sIconState;
  char                        *szString;
  int                         nTerminate = 0;

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  if (sIconState.icon.flags & wimp_ICON_INDIRECTED)
  {
    szString = sIconState.icon.data.indirected_text.text;
    while (szString[nTerminate] >= 32)
    {
      nTerminate++;
    }
    szString[nTerminate] = 0;
  }
  else
  {
    szString = sIconState.icon.data.text;
    while ((szString[nTerminate] >= 32) && (nTerminate < 12))
    {
      nTerminate++;
    }
    szString[nTerminate] = 0;
  }
  return szString;
}

//////////////////////////////////////////////////////////////////
// Set the text string for an icon
void SetIconText (char * szText, wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_state             sIconState;

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  if (sIconState.icon.flags & wimp_ICON_INDIRECTED)
  {
    strcpy (sIconState.icon.data.indirected_text.text, szText);
  }
  else
  {
    strncpy (sIconState.icon.data.text, szText, 12);
    sIconState.icon.data.text[11] = 0;
  }

  xwimp_set_icon_state (whWindow, ihIcon, 0, 0);
}

//////////////////////////////////////////////////////////////////
// Set the text string for an icon and increment postfixed numbers
void SetIconTextIncrement (char * szText, wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_state             sIconState;
  int                         nNumPos;
  char                        *szIconText;
  bool                        boCarry;

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  nNumPos = strlen (szText) - 1;

  if (sIconState.icon.flags & wimp_ICON_INDIRECTED)
  {
    szIconText = sIconState.icon.data.indirected_text.text;
    strcpy (sIconState.icon.data.indirected_text.text, szText);
  }
  else
  {
    szIconText = sIconState.icon.data.text;
    strncpy (sIconState.icon.data.text, szText, 12);
    sIconState.icon.data.text[11] = 0;
    if (nNumPos > 11)
    {
      nNumPos = 11;
    }
  }

  // Increment any postfixed numbers
  boCarry = TRUE;
  while ((nNumPos >= 0)  && boCarry
    && ((szIconText[nNumPos] >= '0') && (szIconText[nNumPos] <= '9')))
  {
    if (szIconText[nNumPos] < '9')
    {
      szIconText[nNumPos]++;
      boCarry = FALSE;
    }
    else
    {
      szIconText[nNumPos] = '0';
      boCarry = TRUE;
    }
    nNumPos--;
  }

  xwimp_set_icon_state (whWindow, ihIcon, 0, 0);
}

//////////////////////////////////////////////////////////////////
// Increment postfixed numbers to icon text
void IconTextIncrement (wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_state             sIconState;
  int                         nNumPos;
  char                        *szIconText;
  bool                        boCarry;

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  if (sIconState.icon.flags & wimp_ICON_INDIRECTED)
  {
    szIconText = sIconState.icon.data.indirected_text.text;
  }
  else
  {
    szIconText = sIconState.icon.data.text;
  }

  nNumPos = strlen (szIconText) - 1;

  // Increment any postfixed numbers
  boCarry = TRUE;
  while ((nNumPos >= 0)  && boCarry
    && ((szIconText[nNumPos] >= '0') && (szIconText[nNumPos] <= '9')))
  {
    if (szIconText[nNumPos] < '9')
    {
      szIconText[nNumPos]++;
      boCarry = FALSE;
    }
    else
    {
      szIconText[nNumPos] = '0';
      boCarry = TRUE;
    }
    nNumPos--;
  }

  xwimp_set_icon_state (whWindow, ihIcon, 0, 0);
}

//////////////////////////////////////////////////////////////////
// Set the sprite string for an icon
void SetIconSprite (char * szSprite, wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_state             sIconState;

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  if (sIconState.icon.flags & wimp_ICON_INDIRECTED)
  {
    strcpy ((char*)(sIconState.icon.data.indirected_sprite.id), szSprite);
  }
  else
  {
    strncpy (sIconState.icon.data.sprite, szSprite, 12);
    sIconState.icon.data.sprite[11] = 0;
  }

  xwimp_set_icon_state (whWindow, ihIcon, 0, 0);
}

//////////////////////////////////////////////////////////////////
// Get the selection state from an icon
bool GetIconSelectionState (wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_state             sIconState;
  bool                        boState;

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  if (sIconState.icon.flags & wimp_ICON_SELECTED)
  {
    boState = TRUE;
  }
  else
  {
    boState = FALSE;
  }

  return boState;
}

//////////////////////////////////////////////////////////////////
// Set the selection state from an icon
void SetIconSelectionState (bool boState, wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_flags             uFlagsEOR;

  if (boState)
  {
    uFlagsEOR = wimp_ICON_SELECTED;
  }
  else
  {
    uFlagsEOR = 0;
  }

  xwimp_set_icon_state (whWindow, ihIcon, uFlagsEOR, wimp_ICON_SELECTED);
}

//////////////////////////////////////////////////////////////////
// Grey out or ungrey an icon
void SetIconGreyness (bool boState, wimp_w whWindow, wimp_i ihIcon)
{
  wimp_icon_flags             uFlagsEOR;

  if (boState)
  {
    uFlagsEOR = wimp_ICON_SHADED;
  }
  else
  {
    uFlagsEOR = 0;
  }

  xwimp_set_icon_state (whWindow, ihIcon, uFlagsEOR, wimp_ICON_SHADED);
}

//////////////////////////////////////////////////////////////////
// Sender wants to send data to the receiver
// Normal use: user has terminated a drag, so this message is sent
// Response:   DataSaveAck
//             RamFetch
void DataSave (wimp_block *pcBlock)
{
  int                         nEditSearch;
  bool                        boWinFound;
  wimp_w                      whWindow;
  int                         nLine;
  int                         nChar;
  RELPOS                      eRelPos;
  char                        szNumber[6];

  whWindow = pcBlock->message.data.data_xfer.w;

  // Find out if it was saved in to an Edit window
  boWinFound = FALSE;
  nEditSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
  {
    // Check for a drag to the main part of an edit window

    // Check filetype
    if (pcBlock->message.data.data_xfer.file_type == 0xfff)
    {
      if (whWindow == gawhEditOpen[nEditSearch])
      {
        eRelPos = PointRelativeSelection (TRUE, ganEditOpen[nEditSearch],
          pcBlock->message.data.data_xfer.pos.x,
          pcBlock->message.data.data_xfer.pos.y,
          & gsSelect, & nLine, & nChar);

        geLoadType = LOADTYPE_EDITTEXT;

        if ((eRelPos == RELPOS_WITHINSTART)
          || (eRelPos == RELPOS_WITHINEND))
        {
          gboDelete = TRUE;
        }
        else
        {
          gboDelete = FALSE;
        }

        SetCaretPos (ganEditOpen[nEditSearch], nLine, nChar);
        gsCaret.nCharPref = gsCaret.nChar;

        // Check the size
/*
        pcBlock->message.size = 60;
        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_DATA_SAVE_ACK;
        strcpy (pcBlock->message.data.data_xfer.file_name, "<Wimp$Scrap>");


        xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
          pcBlock->message.sender);
*/
        // Make a copy in case the RamFetch returns;
        gsMessageStore = pcBlock->message.data.data_xfer;
        gthSender = pcBlock->message.sender;

        pcBlock->message.size = 28;
        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_RAM_FETCH;
        pcBlock->message.data.ram_xfer.addr = gpcRamTransBuffer;
        pcBlock->message.data.ram_xfer.size = RAMTRANSMIT_SIZE;

        xwimp_send_message (wimp_USER_MESSAGE_RECORDED, & pcBlock->message,
          pcBlock->message.sender);

        gnMyRef = pcBlock->message.my_ref;

        boWinFound = TRUE;
      }
    }

    // Check for a drag to the header part of an edit window
    if ((!boWinFound)
      && (gasEdit[ganEditOpen[nEditSearch]].whHead == whWindow))
    {
      if (gasEdit[ganEditOpen[nEditSearch]].nMIMEListNum
        < ATTACHMENT_EDIT_MAX)
      {
        // Add the file to the attachment list
        geLoadType = LOADTYPE_EDITMIME;
        gnEditSaveSelected = ganEditOpen[nEditSearch];

        // Make a copy in case the RamFetch returns;
        gsMessageStore = pcBlock->message.data.data_xfer;
        gthSender = pcBlock->message.sender;

        strncpy (gszLoadFileName, pcBlock->message.data.data_xfer.file_name,
          MIME_FILENAME_MAX);
        gnLoadFileType = pcBlock->message.data.data_xfer.file_type;

        pcBlock->message.size = 28;
        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_RAM_FETCH;
        pcBlock->message.data.ram_xfer.addr = gpcRamTransBuffer;
        pcBlock->message.data.ram_xfer.size = RAMTRANSMIT_SIZE;

        xwimp_send_message (wimp_USER_MESSAGE_RECORDED, & pcBlock->message,
          pcBlock->message.sender);

        gnMyRef = pcBlock->message.my_ref;
      }
      else
      {
        sprintf(szNumber, "%d", ATTACHMENT_EDIT_MAX);
        ShowWarningTagArg ("Er41", szNumber);
      }

      boWinFound = TRUE;
    }
    nEditSearch++;
  }
}

//////////////////////////////////////////////////////////////////
// RamFetch Acknowledge received - try DataSaveAck instead
// Usually followed by a DataLoad message
void RamFetchReturned (wimp_block *pcBlock)
{
  if (gnMyRef == pcBlock->message.my_ref)
  {
    // Use the copy made earlier during the DataSave
    pcBlock->message.data.data_xfer = gsMessageStore;

    pcBlock->message.size = 60;
    pcBlock->message.your_ref = pcBlock->message.my_ref;
    pcBlock->message.action = message_DATA_SAVE_ACK;
    strcpy (pcBlock->message.data.data_xfer.file_name, "<Wimp$Scrap>");

    xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
      gthSender);
  }
}

//////////////////////////////////////////////////////////////////
// Acknowledge that you received a DataSave message
// Usually followed by a DataLoad message
void DataSaveAck (wimp_block *pcBlock)
{
  char                        *szFilename;
  int                         nStringLen;

  CloseMenu ();

  switch (geSaveType)
  {
      case SAVETYPE_EMAILS:
        szFilename = pcBlock->message.data.data_xfer.file_name;

        // Save the file
        SaveFile (szFilename);

        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_DATA_LOAD;

        xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
          pcBlock->message.sender);
        break;
      case SAVETYPE_FILE:
        szFilename = pcBlock->message.data.data_xfer.file_name;
        // Save the file to the given filename
        SetIconTextIncrement (szFilename, gwhSave, 2);

        // Save the file
        SaveFile (szFilename);

        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_DATA_LOAD;

        xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
          pcBlock->message.sender);
        break;
      case SAVETYPE_ICONTEXT:
        szFilename = pcBlock->message.data.data_xfer.file_name;
        // Save the file to the given filename
        nStringLen = strlen (gszSaveString);

        err (xosfile_save_stamped (szFilename, 0xfff, gszSaveString,
          (gszSaveString + nStringLen)));

        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_DATA_LOAD;

        xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
          pcBlock->message.sender);
        break;
      case SAVETYPE_SELECTSAVE:
        szFilename = pcBlock->message.data.data_xfer.file_name;

        if (gpcCopySelect)
        {
          // Save the file to the given filename
          err (xosfile_save_stamped (szFilename, 0xfff, gpcCopySelect,
            (gpcCopySelect + gnCopySelectSize)));

          pcBlock->message.your_ref = pcBlock->message.my_ref;
          pcBlock->message.action = message_DATA_LOAD;

          xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
            pcBlock->message.sender);
        }
        break;
      case SAVETYPE_CLIPBOARD:
        szFilename = pcBlock->message.data.data_xfer.file_name;

        if (gpcClipboard)
        {
          // Save the file to the given filename
          err (xosfile_save_stamped (szFilename, 0xfff, gpcClipboard,
            (gpcClipboard + gnClipboardSize)));

          pcBlock->message.your_ref = pcBlock->message.my_ref;
          pcBlock->message.action = message_DATA_LOAD;

          xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
            pcBlock->message.sender);
        }
        break;
      case SAVETYPE_ATTACHMENT:
        szFilename = pcBlock->message.data.data_xfer.file_name;
        // Save the file to the given filename

        // Save the file
        SaveAttachment (szFilename);

        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_DATA_LOAD;

        xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
          pcBlock->message.sender);
        break;
      default:
        break;
  }
}

//////////////////////////////////////////////////////////////////
// Receiver of this message should load the file
// and answer with DataSaveAck if successful
void DataLoad (wimp_block *pcBlock)
{
  char                        *szFilename;
  char                        *pcLoadedFile;
  int                         nSize;
  int                         nStartLine;
  int                         nEndLine;
  RELPOS                      eRelPos;
  bool                        boWinFound;
  int                         nEditSearch;
  wimp_w                      whWindow;
  int                         nLine;
  int                         nChar;
  bool                        boSuccess;
  int                         nLoadSuccess;
  bool                        boUseAttributes;
  unsigned int                uLoad;
  unsigned int                uExec;
  unsigned int                uAccess;
  os_error                    *psError;

  szFilename = pcBlock->message.data.data_xfer.file_name;

  // Load the file from the given filename
//  pcLoadedFile = LoadFile (szFilename, & nSize);

  nLoadSuccess = LoadFileFlex (szFilename, & pcLoadedFile, & nSize);

  if ((pcLoadedFile) && (nLoadSuccess == 1))
  {
    // Get the file attributes
    psError = xosfile_read (szFilename, NULL, & uLoad, & uExec, NULL,
      & uAccess);
    if (psError)
    {
      err (psError);
      boUseAttributes = FALSE;
    }
    else
    {
      boUseAttributes = TRUE;
    }

    // Delete the file
    if (strcmp (szFilename, "<Wimp$Scrap>") == 0)
    {
      err (xosfile_delete (szFilename, NULL, NULL, NULL, NULL, NULL));
    }
    else
    {
      strncpy (gszLoadFileName, szFilename, MIME_FILENAME_MAX);
    }

    whWindow = pcBlock->message.data.data_xfer.w;

    // Find out if it was saved in to an Edit window
    boWinFound = FALSE;

    nEditSearch = 0;
    while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
    {
      // Check filetype
      if (pcBlock->message.data.data_xfer.file_type == 0xfff)
      {
        if (whWindow == gawhEditOpen[nEditSearch])
        {
          eRelPos = PointRelativeSelection (TRUE, ganEditOpen[nEditSearch],
            pcBlock->message.data.data_xfer.pos.x,
            pcBlock->message.data.data_xfer.pos.y,
            & gsSelect, & nLine, & nChar);

          if ((eRelPos == RELPOS_WITHINSTART)
            || (eRelPos == RELPOS_WITHINEND))
          {
            SetCaretPos (ganEditOpen[nEditSearch], gsSelect.nLineStart,
            gsSelect.nCharStart);
            gsCaret.nCharPref = gsCaret.nChar;
            DeleteSection (gsCaret.nEditNum, & gsSelect);
          }
          else
          {
            SetCaretPos (ganEditOpen[nEditSearch], nLine, nChar);
            gsCaret.nCharPref = gsCaret.nChar;
          }

          InsertTextFlex (gsCaret.nEditNum, gsCaret.nPos, gsCaret.nLine,
            & pcLoadedFile, nSize);
          ReFormat (gsCaret.nEditNum, gsCaret.nLine, -1,
            & nStartLine, & nEndLine);
          MoveCaretRight (nSize);
          UpdateEditWindow (gsCaret.nEditNum, nStartLine,
            nEndLine);
          EditChanged (ganEditOpen[nEditSearch]);
          ClearSelection ();

          gnMyRef = pcBlock->message.my_ref;

          // Loaded successfully, so respond with a DataLoadAck
          pcBlock->message.your_ref = pcBlock->message.my_ref;
          pcBlock->message.action = message_DATA_LOAD_ACK;

          xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
            pcBlock->message.sender);

          boWinFound = TRUE;
        }
      }

      if ((!boWinFound)
        && (gasEdit[ganEditOpen[nEditSearch]].whHead == whWindow))
      {
        // Add the file to the attachment list
        // geLoadType = LOADTYPE_EDITMIME;
        // gnEmailSelected = ganEditOpen[nEditSearch];
        // gboEditSelected = TRUE;

        // strncpy (gszLoadFileName, szFilename, MIME_FILENAME_MAX);
        // gnLoadFileType = pcBlock->message.data.data_xfer.file_type;

        boSuccess = AddFileToAttachmentsListFlex (ganEditOpen[nEditSearch],
          gszLoadFileName, pcBlock->message.data.data_xfer.file_type,
          & pcLoadedFile, nSize, boUseAttributes, uLoad, uExec, uAccess);

        if (boSuccess)
        {
          gnMyRef = pcBlock->message.my_ref;

          // Loaded successfully, so respond with a DataLoadAck
          pcBlock->message.your_ref = pcBlock->message.my_ref;
          pcBlock->message.action = message_DATA_LOAD_ACK;

          xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
            pcBlock->message.sender);
        }
        boWinFound = TRUE;
      }
      nEditSearch++;
    }

//    free (pcLoadedFile);
    if (pcLoadedFile)
    {
      flex_free ((flex_ptr)(& pcLoadedFile));
    }
  }
}

////////////////////////////////////////////////////////////////////
//// User has double clicked on a file
//void DataOpen (wimp_block *pcBlock)
//{
//  char                        *szFilename;
//  char                        *pcLoadedFile;
//  int                         nSize;
//
//  // Check filetype
//  if (pcBlock->message.data.data_xfer.file_type == 0xffd)
//  {
//    szFilename = pcBlock->message.data.data_xfer.file_name;
//
//    // Load the file from the given filename
//    pcLoadedFile = LoadFile (szFilename, & nSize);
//
//    if (pcLoadedFile)
//    {
//      pcBlock->message.your_ref = pcBlock->message.my_ref;
//      pcBlock->message.action = message_DATA_LOAD_ACK;
//
//      xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
//        pcBlock->message.sender);
//
//      FileLoaded (pcLoadedFile, nSize);
//    }
//  }
//}

//////////////////////////////////////////////////////////////////
// Copy the data from here to the external program
// Reply with RamTransmit
void RamFetch (wimp_block *pcBlock)
{
  wimp_t                      nDestHandle;
  int                         nSize;
  int                         nSendLen;

  switch (geSaveType)
  {
    case SAVETYPE_FILE:
    case SAVETYPE_EMAILS:
      RamFetchEmails (pcBlock);
      break;
    case SAVETYPE_ATTACHMENT:
      RamFetchAttachment (pcBlock);
      break;
    default:
      nSize = pcBlock->message.data.ram_xfer.size;
      nDestHandle = pcBlock->message.sender;

      if (gnRamTransRef != pcBlock->message.your_ref)
      {
        // First in a series of RAM transfers
        CloseMenu ();
        switch (geSaveType)
        {
          case SAVETYPE_EMAILS:
          case SAVETYPE_FILE:
            // Dealt with in RamFetchEmails ()
            break;
          case SAVETYPE_ICONTEXT:
            gpcRamTransPos = gszSaveString;
            gnRamTransLeft = (int)strlen (gszSaveString);
            gnRamTransRef = pcBlock->message.your_ref;
            break;
          case SAVETYPE_SELECTSAVE:
            if (gpcCopySelect)
            {
              gpcRamTransPos = gpcCopySelect;
              gnRamTransLeft = gnCopySelectSize;
              gnRamTransRef = pcBlock->message.your_ref;
            }
            break;
          case SAVETYPE_CLIPBOARD:
            if (gpcClipboard)
            {
              gpcRamTransPos = gpcClipboard;
              gnRamTransLeft = gnClipboardSize;
              gnRamTransRef = pcBlock->message.your_ref;
            }
            break;
          case SAVETYPE_ATTACHMENT:
            // Dealt with in RamFetchAttachment ()
            break;
          default:
            gnRamTransRef = -1;
            break;
        }
      }

      if ((gnRamTransRef == pcBlock->message.your_ref) && (gpcRamTransPos))
      {
        // Continue with a previously started RAM transfer
        if (gnRamTransLeft < nSize)
        {
          // This will be the last transfer
          nSendLen = gnRamTransLeft;
        }
        else
        {
          // There will be more to transfer after this
          nSendLen = nSize;
        }

        if (nSendLen > 0)
        {
          xwimp_transfer_block (gnTaskHandle, gpcRamTransPos, nDestHandle,
            pcBlock->message.data.ram_xfer.addr, nSendLen);
        }

        pcBlock->message.size = 28;
        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_RAM_TRANSMIT;
        pcBlock->message.data.ram_xfer.size = nSendLen;

        xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
          pcBlock->message.sender);

        gpcRamTransPos += nSendLen;
        gnRamTransLeft -= nSendLen;

        if (nSendLen < nSize)
        {
          gnRamTransRef = -1;
        }
        else
        {
          gnRamTransRef = pcBlock->message.my_ref;
        }
      }
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Copy the data from here to the external program
// Reply with RamTransmit
void RamFetchEmails (wimp_block *pcBlock)
{
  wimp_t                      nDestHandle;
  int                         nSize;
  int                         nSendLen;
  int                         nThisSendLeft;
  char                        *pcRamTransPos;
  int                         nMemTransfer;
  int                         nTransferToPos;

  nSize = pcBlock->message.data.ram_xfer.size;
  nDestHandle = pcBlock->message.sender;

  if (gnRamTransRef != pcBlock->message.your_ref)
  {
    // First in a series of RAM transfers
    if (geSaveType == SAVETYPE_FILE)
    {
      IconTextIncrement (gwhSave, 2);
    }
    CloseMenu ();
    gnRamTransEmailPos = 0;
    gnRamTransLeft = EmailSaveSize ();
    gnRamTransRef = pcBlock->message.your_ref;
    gnEmailSavePos = 0;
  }

  if ((gnRamTransRef == pcBlock->message.your_ref)
    && (gnRamTransEmailPos >= 0))
  {
    // Continue with a previously started RAM transfer
    if (gnRamTransLeft < nSize)
    {
      // This will be the last transfer
      nSendLen = gnRamTransLeft;
    }
    else
    {
      // There will be more to transfer after this
      nSendLen = nSize;
    }

    if (nSendLen > 0)
    {
      // Copy as many emails as we can
      nThisSendLeft = nSendLen;
      nTransferToPos = 0;

      if (gboEditSave)
      {
        while ((nThisSendLeft > 0) && (gnEmailSavePos < gnEmailSaveNum))
        {
          if (gnRamTransEmailPos >=
            gasEdit[ganEmailSave[gnEmailSavePos]].nSize)
          {
            // Get next email
            gnEmailSavePos++;
            gnRamTransEmailPos = 0;
          }

          if (gnEmailSavePos < gnEmailSaveNum)
          {
            pcRamTransPos
              = gasEdit[ganEmailSave[gnEmailSavePos]].szRawEmail
              + gnRamTransEmailPos;

            nMemTransfer = gasEdit[ganEmailSave[gnEmailSavePos]].nSize;

            if (nMemTransfer > nThisSendLeft)
            {
              nMemTransfer = nThisSendLeft;
            }

            xwimp_transfer_block (gnTaskHandle, pcRamTransPos, nDestHandle,
              pcBlock->message.data.ram_xfer.addr + nTransferToPos,
              nMemTransfer);

            nThisSendLeft -= nMemTransfer;
            gnRamTransEmailPos += nMemTransfer;
            nTransferToPos += nMemTransfer;
          }
        }
      }
      else
      {
        while ((nThisSendLeft > 0) && (gnEmailSavePos < gnEmailSaveNum))
        {
          if (((gasDetails[ganEmailSave[gnEmailSavePos]].szPreMIMEEmail)
            && (gnRamTransEmailPos
            >= gasDetails[ganEmailSave[gnEmailSavePos]].nPreMIMESize))
            || ((!gasDetails[ganEmailSave[gnEmailSavePos]].szPreMIMEEmail)
            && (gnRamTransEmailPos
            >= gasDetails[ganEmailSave[gnEmailSavePos]].nSize)))
          {
            // Get next email
            gnEmailSavePos++;
            gnRamTransEmailPos = 0;
          }

          if (gnEmailSavePos < gnEmailSaveNum)
          {
            if (gasDetails[ganEmailSave[gnEmailSavePos]].szPreMIMEEmail)
            {
              pcRamTransPos
                = gasDetails[ganEmailSave[gnEmailSavePos]].szPreMIMEEmail
                + gnRamTransEmailPos;
              nMemTransfer
                = gasDetails[ganEmailSave[gnEmailSavePos]].nPreMIMESize;
            }
            else
            {
              pcRamTransPos
                = gasDetails[ganEmailSave[gnEmailSavePos]].szRawEmail
                + gnRamTransEmailPos;
              nMemTransfer
                = gasDetails[ganEmailSave[gnEmailSavePos]].nSize;
            }

            if (nMemTransfer > nThisSendLeft)
            {
              nMemTransfer = nThisSendLeft;
            }

            xwimp_transfer_block (gnTaskHandle, pcRamTransPos, nDestHandle,
              pcBlock->message.data.ram_xfer.addr + nTransferToPos,
              nMemTransfer);

            nThisSendLeft -= nMemTransfer;
            gnRamTransEmailPos += nMemTransfer;
            nTransferToPos += nMemTransfer;
          }
        }
      }
    }

    pcBlock->message.size = 28;
    pcBlock->message.your_ref = pcBlock->message.my_ref;
    pcBlock->message.action = message_RAM_TRANSMIT;
    pcBlock->message.data.ram_xfer.size = nSendLen;

    xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
      pcBlock->message.sender);

    gnRamTransLeft -= nSendLen;

    if (nSendLen < nSize)
    {
      gnRamTransRef = -1;
      gnEmailSavePos = 0;
      gnEmailSaveNum = 0;
    }
    else
    {
      gnRamTransRef = pcBlock->message.my_ref;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Copy the data from here to the external program
// Reply with RamTransmit
void RamFetchAttachment (wimp_block *pcBlock)
{
  wimp_t                      nDestHandle;
  int                         nSize;
  int                         nSendLen;
  int                         nSizePre;
  int                         nSizePost;
  char                        *pcDecoded;
  int                         nAllocSuccess;
  int                         nStartPos;

  nSize = pcBlock->message.data.ram_xfer.size;
  nDestHandle = pcBlock->message.sender;

  // Decode the attachment
  nStartPos
    = gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].nStartPos;
  nSizePre
    = gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].nSizePre;

  // Decode the attachment if necessary and then save it to a file
  switch (gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].eEncoding)
  {
    case CTENCODING_QUOTEDPRINTABLE:
      nSizePost = nSizePre;
      nAllocSuccess = flex_alloc ((flex_ptr)(& pcDecoded), nSizePost);
      if (nAllocSuccess == 1)
      {
        DecodeQuotedPrintable (
          gasDetails[gnEmailSelected].szPreMIMEEmail + nStartPos,
          nSizePre, pcDecoded, & nSizePost);
      }
      else
      {
        ShowWarningTag ("Er35");
      }
      break;
    case CTENCODING_BASE64:
      nSizePost = ((nSizePre * 3) / 4) + 3;
      nAllocSuccess = flex_alloc ((flex_ptr)(& pcDecoded), nSizePost);
      if (nAllocSuccess == 1)
      {
        DecodeBase64 (
        gasDetails[gnEmailSelected].szPreMIMEEmail + nStartPos,
        nSizePre, pcDecoded, & nSizePost);
      }
      else
      {
        ShowWarningTag ("Er35");
      }
      break;
    case CTENCODING_PLAIN:
    default:
      nSizePost = nSizePre;
      nAllocSuccess = flex_alloc ((flex_ptr)(& pcDecoded), nSizePost);
      if (nAllocSuccess == 1)
      {
        memcpy (pcDecoded,
          gasDetails[gnEmailSelected].szPreMIMEEmail + nStartPos,
          nSizePost);
      }
      else
      {
        ShowWarningTag ("Er35");
      }
      break;
  }

  if (nAllocSuccess == 1)
  {
    if (gnRamTransRef != pcBlock->message.your_ref)
    {
      // First in a series of RAM transfers
      CloseMenu ();
      gnRamTransAttcPos = 0;
      gnRamTransLeft = nSizePost;
      gnRamTransRef = pcBlock->message.your_ref;
    }

    if (pcDecoded)
    {
      // Continue with a previously started RAM transfer
      if (gnRamTransLeft < nSize)
      {
        // This will be the last transfer
        nSendLen = gnRamTransLeft;
      }
      else
      {
        // There will be more to transfer after this
        nSendLen = nSize;
      }

      if (nSendLen > 0)
      {
        xwimp_transfer_block (gnTaskHandle, pcDecoded + gnRamTransAttcPos,
          nDestHandle, pcBlock->message.data.ram_xfer.addr, nSendLen);
      }

      pcBlock->message.size = 28;
      pcBlock->message.your_ref = pcBlock->message.my_ref;
      pcBlock->message.action = message_RAM_TRANSMIT;
      pcBlock->message.data.ram_xfer.size = nSendLen;

      xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
        pcBlock->message.sender);

      gnRamTransAttcPos += nSendLen;
      gnRamTransLeft -= nSendLen;

      if (nSendLen < nSize)
      {
        gnRamTransRef = -1;
      }
      else
      {
        gnRamTransRef = pcBlock->message.my_ref;
      }
    }

    // Free up the flex memory again
    flex_free ((flex_ptr)(& pcDecoded));
  }
}

//////////////////////////////////////////////////////////////////
// Response to a RamFetch
void RamTransmit (wimp_block *pcBlock)
{
  char                        *pcLoadedFile;
  int                         nSize;
  int                         nStartLine;
  int                         nEndLine;
  MIMEEditDetails             *psMIMEEdit;
  bool                        boSuccess;
  int                         nSuccess = 1;
  char                        *pcEditMIMEFile;

  if (gnMyRef == pcBlock->message.your_ref)
  {
    pcLoadedFile = pcBlock->message.data.ram_xfer.addr;
    nSize = pcBlock->message.data.ram_xfer.size;

    if (nSize != 0)
    {
      switch (geLoadType)
      {
        case LOADTYPE_EDITTEXT:
          if (gboDelete)
          {
            DeleteSection (gsCaret.nEditNum, & gsSelect);
          }

          InsertText (gsCaret.nEditNum, gsCaret.nPos, gsCaret.nLine,
            pcLoadedFile, nSize);
          ReFormat (gsCaret.nEditNum, gsCaret.nLine, -1,
            & nStartLine, & nEndLine);
          MoveCaretRight (nSize);
          UpdateEditWindow (gsCaret.nEditNum, nStartLine,
            nEndLine);
          EditChanged (gsCaret.nEditNum);
          ClearSelection ();
          gboDelete = FALSE;
          break;
        case LOADTYPE_EDITMIME:
          REPORT ("Load attachment piece");
          if (gnEditSaveSelected != EDIT_INVALID)
          {
            // Transfer the attachment piece into the edit memory
            psMIMEEdit = & gasEdit[gnEditSaveSelected].asAttachments
              [gasEdit[gnEditSaveSelected].nMIMEListNum];
            if (psMIMEEdit->pcFileStart == NULL)
            {
              // Create some flex memory
              nSuccess = flex_alloc ((flex_ptr)(& psMIMEEdit->pcFileStart),
                nSize);
              if (nSuccess == 1)
              {
                // Copy the data
                memcpy (psMIMEEdit->pcFileStart, pcLoadedFile, nSize);
                psMIMEEdit->nFileSize = nSize;
              }
            }
            else
            {
              // Extend the flex memory
              nSuccess = flex_extend ((flex_ptr)(& psMIMEEdit->pcFileStart),
                psMIMEEdit->nFileSize + nSize);
              if (nSuccess == 1)
              {
                // Copy the data
                memcpy (psMIMEEdit->pcFileStart + psMIMEEdit->nFileSize,
                  pcLoadedFile, nSize);
                psMIMEEdit->nFileSize += nSize;
              }
              else
              {
                // Something went wrong, so we'd better just free up the
                // memory
                flex_free ((flex_ptr)(& psMIMEEdit->pcFileStart));
                psMIMEEdit->pcFileStart = NULL;
                psMIMEEdit->nFileSize = 0;
              }
            }

            if ((nSize < RAMTRANSMIT_SIZE) && (nSuccess == 1))
            {
              // The last transfer

              nSuccess = flex_reanchor ((flex_ptr)(& pcEditMIMEFile),
                (flex_ptr)( &psMIMEEdit->pcFileStart));
              if (nSuccess == 1)
              {
                boSuccess = AddFileToAttachmentsListFlex (gnEditSaveSelected,
                  gszLoadFileName, gnLoadFileType, & pcEditMIMEFile,
                  psMIMEEdit->nFileSize, FALSE, 0u, 0u, 0u);
              }
              else
              {
                // Something went wrong, so we'd better just free up the
                // memory
                flex_free ((flex_ptr)(& psMIMEEdit->pcFileStart));
                psMIMEEdit->pcFileStart = NULL;
                psMIMEEdit->nFileSize = 0;
              }
              gnEditSaveSelected = EDIT_INVALID;
            }
          }
          break;
        default:
          break;
      }
    }

    if (nSuccess == 1)
    {
      if (nSize == RAMTRANSMIT_SIZE)
      {
        // The buffer was full, so we must ask for some more

        pcBlock->message.size = 28;
        pcBlock->message.your_ref = pcBlock->message.my_ref;
        pcBlock->message.action = message_RAM_FETCH;
        pcBlock->message.data.ram_xfer.addr = gpcRamTransBuffer;
        pcBlock->message.data.ram_xfer.size = RAMTRANSMIT_SIZE;

        xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
          pcBlock->message.sender);

        gnMyRef = pcBlock->message.my_ref;
      }
      else
      {
        // This was the final transfer
        geLoadType = LOADTYPE_INVALID;
      }
    }
    else
    {
      // There was a problem allocating memory
      ShowWarningTag ("Er42");
      geLoadType = LOADTYPE_INVALID;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Response to a Help message
void Help (wimp_block *pcBlock)
{
  wimp_w                      whWindow;
  wimp_i                      ihIcon;
  char                        szHelpText[236];
  int                         nStrLen;
  char                        szTag[256];
  int                         nWinNum = 0;
  wimp_selection              sSelection;
  int                         nEditSearch;
  int                         nEmailSearch;
  bool                        boGeneral;

  whWindow = *(wimp_w*)(pcBlock->message.data.reserved + 12);
  ihIcon = *(wimp_i*)(pcBlock->message.data.reserved + 16);

   // Icon bar
  if (whWindow == wimp_ICON_BAR)
  {
    nWinNum = 1;
  }

  // Main window
  if (whWindow == gwhMain)
  {
    nWinNum = 2;
  }

  // Warning window
  if (whWindow == gwhWarn)
  {
    nWinNum = 3;
  }

  // Information window
  if (whWindow == gawhMenuWinHandle[0])
  {
    nWinNum = 4;
  }

  // Save window
  if (whWindow == gwhSave)
  {
    nWinNum = 5;
  }

  // Query window
  if (whWindow == gwhQery)
  {
    nWinNum = 6;
  }

  // Account window
  if (whWindow == gwhAcct)
  {
    nWinNum = 7;
  }

  // Login window
  if (whWindow == gwhLogn)
  {
    nWinNum = 8;
  }

  // Unlock window
  if (whWindow == gwhUnLk)
  {
    nWinNum = 9;
  }

  // Choices window
  if (whWindow == gwhChce)
  {
    nWinNum = 10;
  }

  // Main window header
  if (whWindow == gwhMaHe)
  {
    nWinNum = 11;
  }

  // Registration window
  if (whWindow == gwhRegi)
  {
    nWinNum = 25;
  }

  // Account settings window
  if (whWindow == gwhSett)
  {
    nWinNum = 26;
  }

  // Addresses window
  if (whWindow == gwhAddr)
  {
    nWinNum = 27;
  }

  // Attachment save window
  if (whWindow == gwhAttc)
  {
    nWinNum = 29;
  }

  // Account base window
  if (whWindow == gwhAcBa)
  {
    nWinNum = 31;
  }

  // Choices base window
  if (whWindow == gwhChBa)
  {
    nWinNum = 32;
  }

  // Settings base window
  if (whWindow == gwhSeBa)
  {
    nWinNum = 33;
  }

  // Settings base window
  if (whWindow == gwhEdAt)
  {
    nWinNum = 35;
  }

  // Check for other windows
  nEditSearch = 0;
  while ((nWinNum == 0)
    && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEditOpen[nEditSearch])
    {
      nWinNum = 12;
    }
    if (whWindow == gasEdit[ganEditOpen[nEditSearch]].whHead)
    {
      nWinNum = 13;
    }
    nEditSearch++;
  }

  nEmailSearch = 0;
  while ((nWinNum == 0)
    && (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEmailsOpen[nEmailSearch])
    {
      nWinNum = 14;
    }
    if (whWindow == gasDetails[ganEmailsOpen[nEmailSearch]].whHead)
    {
      nWinNum = 15;
    }
    nEmailSearch++;
  }

  if (nWinNum)
  {
    // Window
    szHelpText[0] = 0;
    sprintf (szTag, "H%dI%d", nWinNum, ihIcon);
    strncpy (szHelpText, TagCheck (szTag), sizeof(szHelpText));
    nStrLen = strlen(szHelpText);
    if (nStrLen == 0)
    {
      sprintf (szTag, "H%d", nWinNum);
      strncpy (szHelpText, TagCheck (szTag), sizeof(szHelpText));
    }
    szHelpText[sizeof(szHelpText) - 1] = 0;
    nWinNum = -1;
  }
  else
  {
    // Menu
    wimp_get_menu_state (wimp_GIVEN_WINDOW_AND_ICON, & sSelection,
      whWindow, ihIcon);

    boGeneral = FALSE;
    if (sSelection.items[0] != -1)
    {
      // Iconbar menu
      if (gpcMenuCurrent == gpcIconBarMenu)
      {
        nWinNum = 16;
        if ((sSelection.items[0] == 1) && (sSelection.items[1] != -1))
        {
          nWinNum = 21;
          boGeneral = TRUE;
        }
      }

      // Main menu
      if (gpcMenuCurrent == gpcMainMenu)
      {
        nWinNum = 17;
      }

      // Email menu
      if (gpcMenuCurrent == gpcEmailMenu)
      {
        nWinNum = 18;
        // Attachments menu
        if (sSelection.items[0] == 1)
        {
          nWinNum = 30;
          boGeneral = TRUE;
        }
      }

      // Login menu
      if (gpcMenuCurrent == gpcLognMenu)
      {
        nWinNum = 19;
        boGeneral = TRUE;
      }

      // New email menu
      if (gpcMenuCurrent == gpcNewMenu)
      {
        nWinNum = 20;
        // Attachments menu
        if (sSelection.items[0] == 1)
        {
          nWinNum = 34;
          boGeneral = TRUE;
        }
      }

      // Default account menu
      if (gpcMenuCurrent == gpcChoiceAcctMenu)
      {
        nWinNum = 22;
        boGeneral = TRUE;
      }

      // Local email font menu
      if (gpcMenuCurrent == gpcLocalFontMenu)
      {
        nWinNum = 23;
        boGeneral = TRUE;
      }

      // Remote email font menu
      if (gpcMenuCurrent == gpcRemoteFontMenu)
      {
        nWinNum = 24;
        boGeneral = TRUE;
      }

      // Addresses menu
      if (gpcMenuCurrent == gpcAddrMenu)
      {
        nWinNum = 28;
        boGeneral = TRUE;
      }

      // Attachments menu
      if (gpcMenuCurrent == gpcAttcMenu)
      {
        nWinNum = 30;
        boGeneral = TRUE;
      }

      // Edit attachments menu
      if (gpcMenuCurrent == gpcEditAttcMenu)
      {
        nWinNum = 34;
        boGeneral = TRUE;
      }
    }
    if (nWinNum)
    {
      if (boGeneral)
      {
        sprintf (szTag, "H%d", nWinNum);
      }
      else
      {
        if (sSelection.items[1] != -1)
        {
          sprintf (szTag, "H%dI%dI%d", nWinNum, sSelection.items[0],
            sSelection.items[1]);
        }
        else
        {
          sprintf (szTag, "H%dI%d", nWinNum, sSelection.items[0]);
        }
      }

      if (gnRegistered == UNREGISTERED)
      {
        if ((nWinNum == 16) && (sSelection.items[0] == 6))
        {
          sprintf (szTag, "H%dIR", nWinNum);
        }
      }

      strncpy (szHelpText, TagCheck (szTag), sizeof(szHelpText));
      nWinNum = -1;
    }
  }

  if (nWinNum == -1)
  {
    pcBlock->message.size = WORDALIGN((24 + strlen(szHelpText)));
    pcBlock->message.your_ref = pcBlock->message.my_ref;
    pcBlock->message.action = 0x503;
    strncpy (pcBlock->message.data.reserved, szHelpText, sizeof(szHelpText));

    xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
      pcBlock->message.sender);
  }
}

//////////////////////////////////////////////////////////////////
// Obtain string from Messages file
char * Tag (char * szTag)
{
  messagetrans_lookup ((messagetrans_control_block*)gpcMessages,
    szTag, gpcTemp, 256, 0, 0, 0, 0, NULL);

  return gpcTemp;
}

//////////////////////////////////////////////////////////////////
// Obtain string from Messages file with an argument
char * TagArg (char * szTag, char * szArg0)
{
  messagetrans_lookup ((messagetrans_control_block*)gpcMessages,
    szTag, gpcTemp, 256, szArg0, 0, 0, 0, NULL);

  return gpcTemp;
}

//////////////////////////////////////////////////////////////////
// Obtain string from Messages file if it exists
char * TagCheck (char * szTag)
{
  osbool                      boMore = FALSE;
  int                         nUsed = 0;
  char                        *szResult;
  os_error                    *psError;

  xmessagetrans_enumerate_tokens ((messagetrans_control_block*)gpcMessages,
    szTag, gpcTemp, 256, 0, & boMore, & nUsed, NULL);

  if (!boMore)
  {
    strcpy (gpcTemp, "");
    szResult = gpcTemp;
  }
  else
  {
    psError = xmessagetrans_lookup ((messagetrans_control_block*)gpcMessages,
      szTag, gpcTemp, 256, NULL, NULL, NULL, NULL, & szResult, & nUsed);

    if (psError)
    {
      strcpy (gpcTemp, "");
      szResult = gpcTemp;
    }
  }

  return szResult;
}

//////////////////////////////////////////////////////////////////
// Load a file into a block of memory
char * LoadFile (char * szFilename, int * pnSize)
{
  char                        *pcMemory;
  int                         nSize;
  os_error                    *psError;
  fileswitch_object_type      eObjectType;

  xosfile_read_stamped_no_path (szFilename, & eObjectType, NULL, NULL,
    & nSize, NULL, NULL);

  if ((eObjectType != fileswitch_NOT_FOUND) && (nSize > 0))
  {
    if (pnSize)
    {
      *pnSize = nSize;
    }
    pcMemory = malloc (nSize);

    if (pcMemory)
    {
      psError = xosfile_load_stamped_no_path (szFilename, pcMemory, NULL,
        NULL, NULL, NULL, NULL);

      if (psError)
      {
        free (pcMemory);
        pcMemory = NULL;
        err (psError);
      }

    }
    else
    {
      ShowWarningTag ("Er20");
    }
  }
  else
  {
    pcMemory = NULL;
  }

  return pcMemory;
}

//////////////////////////////////////////////////////////////////
// Load a file into a block of flex memory
int LoadFileFlex (char * szFilename, char * * ppcMemory, int * pnSize)
{
  int                         nSize;
  int                         nSuccess = 0;
  fileswitch_object_type      eObjectType;
  os_error                    *psError;

  xosfile_read_stamped_no_path (szFilename, & eObjectType, NULL, NULL,
    & nSize, NULL, NULL);

  if ((eObjectType != fileswitch_NOT_FOUND) && (nSize > 0))
  {
    if (pnSize)
    {
      *pnSize = nSize;
    }
    nSuccess = flex_alloc ((flex_ptr) ppcMemory, nSize);

    if ((nSuccess == 1) && (*ppcMemory))
    {
      psError = xosfile_load_stamped_no_path (szFilename, * ppcMemory, NULL,
        NULL, NULL, NULL, NULL);

      if (psError)
      {
        flex_free ((flex_ptr) ppcMemory);
        *ppcMemory = NULL;
        nSuccess = -1;
        err (psError);
      }
    }
    else
    {
      ShowWarningTag ("Er20");
      nSuccess = 0;
      *ppcMemory = NULL;
    }
  }
  else
  {
    nSuccess = -1;
    *ppcMemory = NULL;
  }

  return nSuccess;
}

//////////////////////////////////////////////////////////////////
// Load a sprite file into a block of memory
osspriteop_area * LoadSprites (char * szFilename)
{
  osspriteop_area             *pcMemory;
  int                         nSize;

  xosfile_read_stamped_no_path (szFilename, NULL, NULL, NULL, & nSize,
    NULL, NULL);

  if (nSize > 0)
  {
    nSize += 4;
    pcMemory = (osspriteop_area*)malloc (nSize);

    if (pcMemory)
    {
      pcMemory->size = nSize;
      pcMemory->sprite_count = 0;
      pcMemory->first = 16;
      pcMemory->used = 16;
      xosspriteop_clear_sprites (osspriteop_USER_AREA, pcMemory);
      err (xosspriteop_load_sprite_file (osspriteop_USER_AREA, pcMemory,
        szFilename));
    }
  }
  else
  {
    pcMemory = NULL;
  }

  return pcMemory;
}

//////////////////////////////////////////////////////////////////
// Display an error from the Messages file with an argument in a warning box
void ShowWarningTagArg (char * szTag, char * szArg0)
{
    xos_bell  ();
    Log ("ERR : ", TagArg(szTag, szArg0));
    SetIconText (TagArg(szTag, szArg0), gwhWarn, 1);
    OpenWindowInitCentre (gwhWarn);
    CloseMenu ();

    xwimp_set_caret_position (gwhWarn, wimp_ICON_WINDOW, 0, 0, -1, -1);
}

//////////////////////////////////////////////////////////////////
// Display an error from the Messages file in a warning box
void ShowWarningTag (char * szTag)
{
    xos_bell  ();
    Log ("ERR : ", Tag(szTag));
    SetIconText (Tag(szTag), gwhWarn, 1);
    OpenWindowInitCentre (gwhWarn);
    CloseMenu ();

    xwimp_set_caret_position (gwhWarn, wimp_ICON_WINDOW, 0, 0, -1, -1);
}

//////////////////////////////////////////////////////////////////
// Display an error in a warning box
void ShowWarning (os_error * sError)
{
    xos_bell  ();
    Log ("ERR : ", sError->errmess);
    SetIconText (sError->errmess, gwhWarn, 1);
    OpenWindowInitCentre (gwhWarn);
    CloseMenu ();

    xwimp_set_caret_position (gwhWarn, wimp_ICON_WINDOW, 0, 0, -1, -1);
}

//////////////////////////////////////////////////////////////////
// Close the warning message box
void CloseWarning (void)
{
  CloseWindowHandle (gwhWarn);
}

//////////////////////////////////////////////////////////////////
// Display a query from the Messages file in a warning box
void ShowQueryTag (char * szTag, char * szContinueTag, char * szCancelTag, QUERYACTION eAction)
{
  xos_bell  ();
  SetIconText (Tag(szTag), gwhQery, 1);
  SetIconText (Tag(szContinueTag), gwhQery, 0);
  SetIconText (Tag(szCancelTag), gwhQery, 5);

  OpenWindowInitCentre (gwhQery);
  CloseMenu ();

  xwimp_set_caret_position (gwhQery, wimp_ICON_WINDOW, 0, 0, -1, -1);

  geQueryAction = eAction;
}

//////////////////////////////////////////////////////////////////
// Display a volatile query from the Messages file in a warning box
void ShowQueryTagVolatile (char * szTag, char * szContinueTag, char * szCancelTag, QUERYACTION eAction)
{
  wimp_window_state           sState;
  int                         nHeight;
  int                         nWidth;
  int                         nEigFactor;
  int                         nSize;
  int                         nXPos;
  int                         nYPos;

  xos_bell  ();
  SetIconText (Tag(szTag), gwhQery, 1);
  SetIconText (Tag(szContinueTag), gwhQery, 0);
  SetIconText (Tag(szCancelTag), gwhQery, 5);

  sState.w = gwhQery;
  xwimp_get_window_state (& sState);

  nWidth = sState.visible.x1 - sState.visible.x0;
  nHeight = sState.visible.y1 - sState.visible.y0;

  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_XEIG_FACTOR,
    & nEigFactor, NULL);
  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_XWIND_LIMIT,
    & nSize, NULL);
  nXPos = ((nSize << nEigFactor) - nWidth) / 2;

  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_YEIG_FACTOR,
    & nEigFactor, NULL);
  xos_read_mode_variable (os_CURRENT_MODE, os_MODEVAR_YWIND_LIMIT,
    & nSize, NULL);
  nYPos = ((nSize << nEigFactor) + nHeight) / 2;

//  OpenWindowInitCentre (gwhQery);
  CloseMenu ();
  xwimp_create_menu ((wimp_menu *)gwhQery, nXPos, nYPos);

  xwimp_set_caret_position (gwhQery, wimp_ICON_WINDOW, 0, 0, -1, -1);

  geQueryAction = eAction;
}


//////////////////////////////////////////////////////////////////
// Close the warning message box
void CloseQuery (void)
{
  CloseWindowHandle (gwhQery);
}


//////////////////////////////////////////////////////////////////
// Initiate a sprite drag from the contents of the given icon
void DragSprite (wimp_w whWindow, wimp_i ihIcon, char * szIconName)
{
  osspriteop_area             *pcSpriteArea;
  int                         nXinc;
  int                         nYinc;
  wimp_icon_state             sIconState;
  wimp_window_info            sWindowInfo;

  if (!gboDrag)
  {
    sIconState.w = whWindow;
    sIconState.i = ihIcon;
    xwimp_get_icon_state (& sIconState);

    if (((sIconState.icon.flags & (wimp_ICON_TEXT
      | wimp_ICON_SPRITE | wimp_ICON_INDIRECTED))
      == (wimp_ICON_SPRITE | wimp_ICON_INDIRECTED)))
    {
      pcSpriteArea = sIconState.icon.data.indirected_sprite.area;
    }
    else
    {
      pcSpriteArea = NULL;
    }

    sWindowInfo.w = whWindow;
    xwimp_get_window_info_header_only (& sWindowInfo);

    if (!pcSpriteArea)
    {
      pcSpriteArea = sWindowInfo.sprite_area;
    }

    nXinc = sWindowInfo.visible.x0 - sWindowInfo.xscroll;
    nYinc = sWindowInfo.visible.y1 - sWindowInfo.yscroll;

    sIconState.icon.extent.x0 += nXinc;
    sIconState.icon.extent.y0 += nYinc;
    sIconState.icon.extent.x1 += nXinc;
    sIconState.icon.extent.y1 += nYinc;

    xdragasprite_start ((dragasprite_HPOS_CENTRE | dragasprite_VPOS_CENTRE
      | dragasprite_BOUND_POINTER | dragasprite_DROP_SHADOW),
      pcSpriteArea, szIconName, & sIconState.icon.extent, NULL);

    gboDrag = TRUE;
  }
}

//////////////////////////////////////////////////////////////////
// Initiate an outline drag from the dimensions of the given icon
void DragBox (wimp_w whWindow, wimp_i ihIcon)
{
  int                         nXinc;
  int                         nYinc;
  wimp_icon_state             sIconState;
  wimp_window_state           sWindowState;
  wimp_drag                   sDragInfo;

  if (!gboDrag)
  {
    sIconState.w = whWindow;
    sIconState.i = ihIcon;
    xwimp_get_icon_state (& sIconState);

    sWindowState.w = whWindow;
    xwimp_get_window_state (& sWindowState);

    nXinc = sWindowState.visible.x0 - sWindowState.xscroll;
    nYinc = sWindowState.visible.y1 - sWindowState.yscroll;

    sDragInfo.w = 0;
    sDragInfo.type = wimp_DRAG_USER_FIXED;
    sDragInfo.initial.x0 = sIconState.icon.extent.x0 + nXinc;
    sDragInfo.initial.y0 = sIconState.icon.extent.y0 + nYinc;
    sDragInfo.initial.x1 = sIconState.icon.extent.x1 + nXinc;
    sDragInfo.initial.y1 = sIconState.icon.extent.y1 + nYinc;
    sDragInfo.bbox.x0 = 0;
    sDragInfo.bbox.y0 = 0;
    sDragInfo.bbox.x1 = 0;
    sDragInfo.bbox.y1 = 0;
    sDragInfo.handle = NULL;
    sDragInfo.draw = NULL;
    sDragInfo.undraw = NULL;
    sDragInfo.redraw = NULL;

    xwimp_drag_box (& sDragInfo);

    gboDrag = TRUE;
  }
}

//////////////////////////////////////////////////////////////////
// Initiate a sprite drag from the given sprite icon name
void DragCentred (int nXPos, int nYPos, char * szIconName)
{
  int              nWidth;
  int              nHeight;
  os_mode          sMode;
  int              nEigFactor;
  os_box           sBox;

  if (!gboDrag)
  {
    xwimpspriteop_read_sprite_info (szIconName, & nWidth, & nHeight,
      NULL, & sMode);

    xos_read_mode_variable (sMode, os_MODEVAR_XEIG_FACTOR, & nEigFactor,
      NULL);
    nWidth = nWidth << nEigFactor;

    xos_read_mode_variable (sMode, os_MODEVAR_YEIG_FACTOR, & nEigFactor,
      NULL);
    nHeight = nHeight << nEigFactor;

    sBox.x0 = nXPos - (nWidth >> 1);
    sBox.y0 = nYPos - (nHeight >> 1);
    sBox.x1 = sBox.x0 + nWidth;
    sBox.y1 = sBox.y0 + nHeight;

    xdragasprite_start ((dragasprite_flags)(0xc5),
      (osspriteop_area*)(1), szIconName, & sBox,
      NULL);

    gboDrag = TRUE;
  }
}

//////////////////////////////////////////////////////////////////
// Initiate a URL link
void OpenURL (char * szURL)
{
  wimp_message                sMessage;

  sMessage.your_ref = 0;
  sMessage.action = message_URL_LAUNCH;

  strcpy ((char *)sMessage.data.reserved, szURL);

  sMessage.size = WORDALIGN(strlen(szURL) + 21);

  xwimp_send_message (wimp_USER_MESSAGE_RECORDED, & sMessage,
    wimp_BROADCAST);

  gnMessageMyRef = sMessage.my_ref;
}

//////////////////////////////////////////////////////////////////
// No URL lancher responded, so we have to run one ourselves
void OpenURLReturned (wimp_block *pcBlock)
{
  char                        szAlias[255];
  char                        szVar[255];
  int                         nUsed = 1;

  if (gnMessageMyRef == pcBlock->message.my_ref)
  {
    if (strncmp (pcBlock->message.data.reserved, "mailto:", 7) == 0)
    {
      strcpy (szAlias, "URLOpen_MailTo");
    }
    else
    {
      strcpy (szAlias, "URLOpen_HTTP");
    }

    sprintf (szVar, "Alias$%s", szAlias);
    xos_read_var_val (szVar, 0, -1, 0, os_VARTYPE_STRING, & nUsed,
      NULL, NULL);

    if (nUsed != 0)
    {
      sprintf (szVar, "%s %s", szAlias, pcBlock->message.data.reserved);
      err (xwimp_start_task (szVar, NULL));
    }
  }
}

//////////////////////////////////////////////////////////////////
// Save box save button clicked
void SaveSave (void)
{
  char                        *szFilename;

  szFilename = GetIconText (gwhSave, 2);

  if (strchr(szFilename, '.'))
  {
    // Save the file
    SaveFile (szFilename);

    // Increment the filename in the icon
    SetIconTextIncrement (szFilename, gwhSave, 2);
  }
  else
  {
    ShowWarningTag ("Er1");
  }
}

//////////////////////////////////////////////////////////////////
// Attachment save box save button clicked
void AttachmentSave (void)
{
  char                        *szFilename;

  szFilename = GetIconText (gwhAttc, 2);

  if (strchr(szFilename, '.'))
  {
    // Save the file
    SaveAttachment (szFilename);
  }
  else
  {
    ShowWarningTag ("Er1");
  }
}

#if defined _DEBUG
//////////////////////////////////////////////////////////////////
// Report a debug message
void Report (char * szMessage)
{
  _kernel_swi_regs            sRegs;

  sRegs.r[0] = (int)szMessage;
  _kernel_swi (Report_Text0, & sRegs, & sRegs);
}

//////////////////////////////////////////////////////////////////
// Report a debug message with variable
void ReportVar (char * szFormat, int nVariable)
{
  _kernel_swi_regs            sRegs;
  char                        szReport[255];

  sprintf (szReport, szFormat, nVariable);
  sRegs.r[0] = (int)szReport;
  _kernel_swi (Report_Text0, & sRegs, & sRegs);
}
#endif // _DEBUG

//////////////////////////////////////////////////////////////////
// Save file routine - saves the example file out
void SaveFile (char * szFilename)
{
  os_fw                       fhFile;
  int                         nEmailPos;
  int                         nUnwritten = 0;

  err (xosfile_create_stamped (szFilename, gnSaveFileType, 0));
  err (xosfind_openoutw ((osfind_NO_PATH | osfind_ERROR_IF_DIR), szFilename,
    NULL, & fhFile));

  if (fhFile > 0)
  {
    nEmailPos = 0;
    if (gboEditSave)
    {
      while ((nEmailPos < gnEmailSaveNum) && (nUnwritten == 0))
      {
        err (xosgbpb_writew (fhFile,
          gasEdit[ganEmailSave[nEmailPos]].szRawEmail,
          gasEdit[ganEmailSave[nEmailPos]].nSize,
          & nUnwritten));
        nEmailPos++;
      }
    }
    else
    {
      while ((nEmailPos < gnEmailSaveNum) && (nUnwritten == 0))
      {
        if (gasDetails[ganEmailSave[nEmailPos]].szPreMIMEEmail)
        {
          err (xosgbpb_writew (fhFile,
            gasDetails[ganEmailSave[nEmailPos]].szPreMIMEEmail,
            gasDetails[ganEmailSave[nEmailPos]].nPreMIMESize,
            & nUnwritten));
        }
        else
        {
          err (xosgbpb_writew (fhFile,
            gasDetails[ganEmailSave[nEmailPos]].szRawEmail,
            gasDetails[ganEmailSave[nEmailPos]].nSize,
            & nUnwritten));
        }
        nEmailPos++;
      }
    }
    osfind_closew (fhFile);
    osfile_set_type (szFilename, gnSaveFileType);
  }
  gnEmailSaveNum = 0;
}

//////////////////////////////////////////////////////////////////
// Respond to a redraw window request
void RedrawWindow (wimp_block *pcBlock)
{
  osbool                boMore;
  int                   nEmailNum;
  int                   nEditNum;
  wimp_w                whWindow;

  xwimp_redraw_window (& pcBlock->redraw, & boMore);
  whWindow = pcBlock->redraw.w;

  if (whWindow == gwhMain)
  {
    while (boMore)
    {
      // Redraw the window
      RedrawMain (& pcBlock->redraw);
      xwimp_get_rectangle (& pcBlock->redraw, & boMore);
    }
  }
  else
  {
    if (whWindow == gwhMaHe)
    {
      while (boMore)
      {
        // Redraw the window
        RedrawMainHead (& pcBlock->redraw);
        xwimp_get_rectangle (& pcBlock->redraw, & boMore);
      }
    }
    else
    {
      // Find out which email window is open
      nEmailNum = 0;
      while ((gawhEmailsOpen[nEmailNum] != whWindow)
        && (gawhEmailsOpen[nEmailNum] != wimp_BACKGROUND))
      {
        nEmailNum++;
      }

      if (gawhEmailsOpen[nEmailNum] != wimp_BACKGROUND)
      {
        while (boMore)
        {
          // Redraw the window
          RedrawEmail (& pcBlock->redraw, ganEmailsOpen[nEmailNum]);
          xwimp_get_rectangle (& pcBlock->redraw, & boMore);
        }
      }
      else
      {
        // Check if it's an edit window
        nEditNum = 0;
        while ((gawhEditOpen[nEditNum] != whWindow)
          && (gawhEditOpen[nEditNum] != wimp_BACKGROUND))
        {
          nEditNum++;
        }

        if (gawhEditOpen[nEditNum] != wimp_BACKGROUND)
        {
          while (boMore)
          {
            // Redraw the window
            RedrawEdit (& pcBlock->redraw, ganEditOpen[nEditNum]);
            xwimp_get_rectangle (& pcBlock->redraw, & boMore);
          }
        }
        else
        {
          while (boMore)
          {
            // Do nothing - no window found!
            xwimp_get_rectangle (& pcBlock->redraw, & boMore);
          }
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Redraw a sequence of rows in the main window
void UpdateMain (int nRowStart, int nRowEnd)
{
  wimp_window_state     sWindowState;
  int                   nStart = 0;
  int                   nEnd = 0;

  if (nRowStart != -1)
  {
    nStart = gasDetails[nRowStart].nSortPos;
  }
  if (nRowEnd != -1)
  {
    nEnd = gasDetails[nRowEnd].nSortPos;
  }

  if ((nRowStart == -1) || (nRowEnd == -1))
  {
    sWindowState.w = gwhMain;
    xwimp_get_window_state (& sWindowState);

    if (nRowStart == -1)
    {
      nStart = ((- sWindowState.yscroll - (ROW_YOFFSET)) / gnRowHeight);
    }
    if (nRowEnd == -1)
    {
      nEnd = - (sWindowState.visible.y0 - sWindowState.visible.y1
        + sWindowState.yscroll + ROW_YOFFSET) / gnRowHeight;
    }
  }

  if (nStart <= nEnd)
  {
    xwimp_force_redraw (gwhMain, ganColWidth[0],
      -ROW_YOFFSET - (nEnd + 1) * gnRowHeight,
      ganColWidth[COLUMNS_MAX - 1],
      -ROW_YOFFSET - (nStart + 0) * gnRowHeight);
  }
  else
  {
    xwimp_force_redraw (gwhMain, ganColWidth[0],
      -ROW_YOFFSET - (nStart + 1) * gnRowHeight,
      ganColWidth[COLUMNS_MAX - 1],
      -ROW_YOFFSET - (nEnd + 0) * gnRowHeight);
  }

//  osbool                boMore;
//  wimp_draw             sRedraw;
//
//  sRedraw.w = gwhMain;
//  sRedraw.box.x0 = ganColWidth[0];
//  sRedraw.box.y0 = -ROW_YOFFSET - (nRowEnd + 1)* gnRowHeight;
//  sRedraw.box.x1 = ganColWidth[COLUMNS_MAX - 1];
//  sRedraw.box.y1 = -ROW_YOFFSET - (nRowStart + 0) * gnRowHeight;
//
//  xwimp_update_window (& sRedraw, & boMore);
//
//  while (boMore)
//  {
//    // Redraw the window
//    RedrawMain (& sRedraw);
//    xwimp_get_rectangle (& sRedraw, & boMore);
//  }
}

//////////////////////////////////////////////////////////////////
// Redraw an email window
void RedrawEmail (wimp_draw *psRedraw, int nEmailNum)
{
  int                   nVisMinX = psRedraw->box.x0;
//  int                   nVisMinY = psRedraw->box.y0;
//  int                   nVisMaxX = psRedraw->box.x1;
  int                   nVisMaxY = psRedraw->box.y1;

  int                   nRedMinX = psRedraw->clip.x0;
  int                   nRedMinY = psRedraw->clip.y0;
  int                   nRedMaxX = psRedraw->clip.x1;
  int                   nRedMaxY = psRedraw->clip.y1;

  int                   nScrollX = psRedraw->xscroll;
  int                   nScrollY = psRedraw->yscroll;

  int                   nLine;
  int                   nStartLine;
  int                   nEndLine;
  int                   nXPos;
  int                   nYPos;
  int                   nXSelStart;
  int                   nXSelEnd;
  int                   nLineHide;

  // Fill in the background
  xwimp_set_colour (wimp_COLOUR_VERY_LIGHT_GREY);
  xos_plot (os_PLOT_POINT | os_MOVE_TO, nRedMinX, nRedMinY);
  xos_plot (os_PLOT_RECTANGLE | os_PLOT_TO, nRedMaxX, nRedMaxY);

  if (nEmailNum != EMAIL_INVALID)
  {
    xwimp_set_font_colours (wimp_COLOUR_VERY_LIGHT_GREY,
      wimp_COLOUR_BLACK);
    xfont_set_font (ghEmailFont);

    nStartLine = ((-EMAIL_TEXT_Y_OFFSET - gnEmailTextYOffset + nVisMaxY
      - nScrollY - nRedMaxY) / gnEmailRowHeight);
    nEndLine = ((-EMAIL_TEXT_Y_OFFSET - gnEmailTextYOffset + nVisMaxY
      - nScrollY - nRedMinY) / gnEmailRowHeight) + 1;

    nLineHide = gasDetails[nEmailNum].nLineHide;
    nStartLine += nLineHide;
    nEndLine += nLineHide;

    RANGE (nStartLine, gasDetails[nEmailNum].nLineHide,
      gasDetails[nEmailNum].nLineMax);
    RANGE (nEndLine, gasDetails[nEmailNum].nLineHide,
      gasDetails[nEmailNum].nLineMax);

    // Draw the whole lot, a line at a time
    nXPos = nVisMinX - nScrollX + EMAIL_TEXT_X_OFFSET;
    for (nLine = nStartLine; nLine < nEndLine; nLine++)
    {
      nYPos = nVisMaxY - nScrollY
        - ((nLine + 1 - nLineHide) * gnEmailRowHeight) - EMAIL_TEXT_Y_OFFSET;

      xfont_paint (ghEmailFont, gasDetails[nEmailNum].szFormEmail
        + gasDetails[nEmailNum].anLine[nLine],
        (font_OS_UNITS),
        nXPos, nYPos, NULL, NULL, 0);

      nYPos -= gnEmailTextYOffset;

      if (gboEmoticons)
      {
        PlotSmileys(ghEmailFont, gasDetails[nEmailNum].szFormEmail
          + gasDetails[nEmailNum].anLine[nLine], nXPos, nYPos,
          gasDetails[nEmailNum].anLine[nLine + 1]
          - gasDetails[nEmailNum].anLine[nLine]);
      }

      // Invert if selected
      if ((nEmailNum == gsSelect.nEmailNum)
        && (nLine >= gsSelect.nLineStart) && (nLine <= gsSelect.nLineEnd)
        && (gsSelect.nLineStart != -1))
      {
        if (nLine == gsSelect.nLineStart)
        {
          xfont_scan_string (ghEmailFont, gasDetails[nEmailNum].szFormEmail
            + gasDetails[nEmailNum].anLine[nLine],
            (font_GIVEN_FONT | font_GIVEN_LENGTH),
            MILLIPOINT * gnEmailTextWidth,
            MILLIPOINT * gnEmailRowHeight, NULL, NULL, gsSelect.nCharStart,
            NULL, & nXSelStart, NULL, NULL);
          nXSelStart /= MILLIPOINT;
        }
        else
        {
          nXSelStart = 0;
        }
        if (nLine == gsSelect.nLineEnd)
        {
          xfont_scan_string (ghEmailFont, gasDetails[nEmailNum].szFormEmail
            + gasDetails[nEmailNum].anLine[nLine],
            (font_GIVEN_FONT | font_GIVEN_LENGTH),
            MILLIPOINT * gnEmailTextWidth,
            MILLIPOINT * gnEmailRowHeight, NULL, NULL, gsSelect.nCharEnd,
            NULL, & nXSelEnd, NULL, NULL);
          nXSelEnd /= MILLIPOINT;
        }
        else
        {
          nXSelEnd = gnEmailTextWidth;
        }
        if (nXSelStart != nXSelEnd)
        {
          xwimp_set_colour (wimp_COLOUR_BLACK);
          xos_plot (os_PLOT_POINT | os_MOVE_TO, nXPos + nXSelStart, nYPos);
          xos_plot (os_PLOT_RECTANGLE | os_PLOT_INVERSE_TO,
            nXPos + nXSelEnd - 1, nYPos + gnEmailRowHeight - 1);
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Change the selection and update the window
void ChangeSelection (Selection * psNew)
{
  int                   nLineStart;
  int                   nLineEnd;
  osbool                boMore;
  wimp_draw             sRedraw;
  bool                  boPost;
  Selection             sSelectPre;
  Selection             sSelectPost;
  int                   nOffset;
  int                   nLineHide;

  SelectReOrder (psNew);

  if ((psNew->boEdit == gsSelect.boEdit)
    && (psNew->nEmailNum == gsSelect.nEmailNum)
    && (psNew->nEmailNum != EMAIL_INVALID))
  {
    // Change selection on same email
    if ((psNew->nLineStart != gsSelect.nLineStart)
      || (psNew->nCharStart != gsSelect.nCharStart)
      || (psNew->nLineEnd != gsSelect.nLineEnd)
      || (psNew->nCharEnd != gsSelect.nCharEnd))
    {
      nLineStart = MIN (gsSelect.nLineStart, psNew->nLineStart);
      nLineEnd = MIN (gsSelect.nLineEnd, psNew->nLineEnd);

      if (gsSelect.nLineStart == -1)
      {
        boPost = FALSE;
        nLineStart = psNew->nLineStart;
        nLineEnd = psNew->nLineEnd;
        sSelectPre = *psNew;
      }
      else
      {
        if (psNew->nLineStart == -1)
        {
          boPost = FALSE;
          nLineStart = gsSelect.nLineStart;
          nLineEnd = gsSelect.nLineEnd;
          sSelectPre = gsSelect;
        }
        else
        {
          boPost = TRUE;
          sSelectPre = gsSelect;
          sSelectPost = gsSelect;

          sSelectPre.nLineStart = gsSelect.nLineStart;
          sSelectPre.nCharStart = gsSelect.nCharStart;
          sSelectPre.nLineEnd = psNew->nLineStart;
          sSelectPre.nCharEnd = psNew->nCharStart;

          sSelectPost.nLineStart = gsSelect.nLineEnd;
          sSelectPost.nCharStart = gsSelect.nCharEnd;
          sSelectPost.nLineEnd = psNew->nLineEnd;
          sSelectPost.nCharEnd = psNew->nCharEnd;

          SelectReOrder (& sSelectPre);
          SelectReOrder (& sSelectPost);
          nLineStart = sSelectPre.nLineStart;
          nLineEnd = sSelectPost.nLineEnd;
        }
      }

      if (psNew->boEdit)
      {
        nOffset = gasEdit[psNew->nEmailNum].nTextOffset;
        nLineHide = 0;
      }
      else
      {
        nOffset = EMAIL_TEXT_Y_OFFSET;
        nLineHide = gasDetails[psNew->nEmailNum].nLineHide;
      }

      sRedraw.w = gsSelect.whWindow;
      sRedraw.box.x0 = EMAIL_TEXT_X_OFFSET;
      sRedraw.box.y0 = - ((nLineEnd - nLineHide) * gnEmailRowHeight)
        - nOffset - gnEmailTextYOffset - gnEmailRowHeight;
      sRedraw.box.x1 = EMAIL_TEXT_X_OFFSET + gnEmailTextWidth;
      sRedraw.box.y1 = - ((nLineStart - nLineHide) * gnEmailRowHeight)
        - nOffset - gnEmailTextYOffset;

      xwimp_update_window (& sRedraw, & boMore);

      while (boMore)
      {
        InvertSelection (& sSelectPre, & sRedraw);
        if (boPost)
        {
          InvertSelection (& sSelectPost, & sRedraw);
        }
        xwimp_get_rectangle (& sRedraw, & boMore);
      }
      gsSelect = *psNew;
    }
  }
  else
  {
    // Change selection on different email

    // Remove previous selection
    if ((gsSelect.whWindow != wimp_BACKGROUND)
      && (gsSelect.nLineStart != -1))
    {
      nLineStart = gsSelect.nLineStart;
      nLineEnd = gsSelect.nLineEnd;

      if (gsSelect.boEdit)
      {
        nOffset = gasEdit[gsSelect.nEmailNum].nTextOffset;
        nLineHide = 0;
      }
      else
      {
        nOffset = EMAIL_TEXT_Y_OFFSET;
        nLineHide = gasDetails[gsSelect.nEmailNum].nLineHide;
      }

      sRedraw.w = gsSelect.whWindow;
      sRedraw.box.x0 = EMAIL_TEXT_X_OFFSET;
      sRedraw.box.y0 = - ((nLineEnd - nLineHide) * gnEmailRowHeight)
        - nOffset - gnEmailTextYOffset - gnEmailRowHeight;
      sRedraw.box.x1 = EMAIL_TEXT_X_OFFSET + gnEmailTextWidth;
      sRedraw.box.y1 = - ((nLineStart - nLineHide) * gnEmailRowHeight)
        - nOffset - gnEmailTextYOffset;

      xwimp_update_window (& sRedraw, & boMore);

      while (boMore)
      {
        InvertSelection (& gsSelect, & sRedraw);
        xwimp_get_rectangle (& sRedraw, & boMore);
      }
    }

    // Draw new selection
    if ((psNew->whWindow != wimp_BACKGROUND)
      && (psNew->nLineStart != -1))
    {
      nLineStart = psNew->nLineStart;
      nLineEnd = psNew->nLineEnd;

      if (psNew->boEdit)
      {
        nOffset = gasEdit[psNew->nEmailNum].nTextOffset;
        nLineHide = 0;
      }
      else
      {
        nOffset = EMAIL_TEXT_Y_OFFSET;
        nLineHide = gasDetails[psNew->nEmailNum].nLineHide;
      }

      sRedraw.w = psNew->whWindow;
      sRedraw.box.x0 = EMAIL_TEXT_X_OFFSET;
      sRedraw.box.y0 = - ((nLineEnd - nLineHide) * gnEmailRowHeight)
        - nOffset - gnEmailTextYOffset - gnEmailRowHeight;
      sRedraw.box.x1 = EMAIL_TEXT_X_OFFSET + gnEmailTextWidth;
      sRedraw.box.y1 = - ((nLineStart - nLineHide) * gnEmailRowHeight)
        - nOffset - gnEmailTextYOffset;

      xwimp_update_window (& sRedraw, & boMore);

      while (boMore)
      {
        InvertSelection (psNew, & sRedraw);
        xwimp_get_rectangle (& sRedraw, & boMore);
      }
    }
    gsSelect = *psNew;
  }
}

//////////////////////////////////////////////////////////////////
// Reorder the start and end of a Select structure to be increasing
void SelectReOrder (Selection *psSelection)
{
  int                   nTemp;

  if ((psSelection->nLineStart > psSelection->nLineEnd)
    || ((psSelection->nLineStart == psSelection->nLineEnd)
    && (psSelection->nCharStart > psSelection->nCharEnd)))
  {
    // Switch the start and end positions
    nTemp = psSelection->nLineStart;
    psSelection->nLineStart = psSelection->nLineEnd;
    psSelection->nLineEnd = nTemp;
    nTemp = psSelection->nCharStart;
    psSelection->nCharStart = psSelection->nCharEnd;
    psSelection->nCharEnd = nTemp;
  }
}

//////////////////////////////////////////////////////////////////
// Invert a selected area of text
void InvertSelection (Selection * psSelect, wimp_draw *psRedraw)
{
  int                   nVisMinX = psRedraw->box.x0;
  int                   nVisMaxY = psRedraw->box.y1;
  int                   nRedMinY = psRedraw->clip.y0;
  int                   nRedMaxY = psRedraw->clip.y1;
  int                   nScrollX = psRedraw->xscroll;
  int                   nScrollY = psRedraw->yscroll;

  int                   nLine;
  int                   nStartLine;
  int                   nEndLine;
  int                   nXPos;
  int                   nYPos;
  int                   nXSelStart;
  int                   nXSelEnd;
  char                  *szEmailText;
  int                   *anLine;
  int                   nOffset;
  int                   nLineHide;

  if ((psSelect->nLineStart != psSelect->nLineEnd)
    || (psSelect->nCharStart != psSelect->nCharEnd))
  {
    if (psSelect->boEdit)
    {
      nOffset = gasEdit[psSelect->nEmailNum].nTextOffset;
      nStartLine = ((-nOffset - gnEmailTextYOffset + nVisMaxY - nScrollY
        - nRedMaxY) / gnEmailRowHeight);

      nEndLine = ((-nOffset - gnEmailTextYOffset + nVisMaxY - nScrollY
        - nRedMinY) / gnEmailRowHeight);

      RANGE (nStartLine, 0, gasEdit[psSelect->nEmailNum].nLineMax);
      RANGE (nEndLine, 0, gasEdit[psSelect->nEmailNum].nLineMax);
      szEmailText = gasEdit[psSelect->nEmailNum].szRawEmail;
      anLine = gasEdit[psSelect->nEmailNum].anLine;
      nLineHide = 0;
    }
    else
    {
      nOffset = EMAIL_TEXT_Y_OFFSET;
      nStartLine = ((-nOffset - gnEmailTextYOffset + nVisMaxY - nScrollY
        - nRedMaxY) / gnEmailRowHeight);
      nEndLine = ((-nOffset - gnEmailTextYOffset + nVisMaxY - nScrollY
        - nRedMinY) / gnEmailRowHeight);

      nLineHide = gasDetails[psSelect->nEmailNum].nLineHide;
      nStartLine += nLineHide;
      nEndLine += nLineHide;

      RANGE (nStartLine, nLineHide,
        gasDetails[psSelect->nEmailNum].nLineMax);
      RANGE (nEndLine, nLineHide,
        gasDetails[psSelect->nEmailNum].nLineMax);
      szEmailText = gasDetails[psSelect->nEmailNum].szFormEmail;
      anLine = gasDetails[psSelect->nEmailNum].anLine;
    }

    if (nStartLine < psSelect->nLineStart)
    {
      nStartLine = psSelect->nLineStart;
    }
    if (nEndLine > (psSelect->nLineEnd))
    {
      nEndLine = (psSelect->nLineEnd);
    }

    // Draw the whole lot, a line at a time
    nXPos = nVisMinX - nScrollX + EMAIL_TEXT_X_OFFSET;
    for (nLine = nStartLine; nLine <= nEndLine; nLine++)
    {
      nYPos = nVisMaxY - nScrollY
        - ((nLine + 1 - nLineHide) * gnEmailRowHeight)
        - nOffset - gnEmailTextYOffset;

      // Invert if selected
      if ((nLine >= psSelect->nLineStart) && (nLine <= psSelect->nLineEnd))
      {
        if (nLine == psSelect->nLineStart)
        {
          xfont_scan_string (ghEmailFont, szEmailText + anLine[nLine],
            (font_GIVEN_FONT | font_GIVEN_LENGTH),
            MILLIPOINT * gnEmailTextWidth,
            MILLIPOINT * gnEmailRowHeight, NULL, NULL,
              psSelect->nCharStart, NULL, & nXSelStart, NULL, NULL);
          nXSelStart /= MILLIPOINT;
        }
        else
        {
          nXSelStart = 0;
        }
        if (nLine == psSelect->nLineEnd)
        {
          xfont_scan_string (ghEmailFont, szEmailText + anLine[nLine],
            (font_GIVEN_FONT | font_GIVEN_LENGTH),
            MILLIPOINT * gnEmailTextWidth,
            MILLIPOINT * gnEmailRowHeight, NULL, NULL, psSelect->nCharEnd,
            NULL, & nXSelEnd, NULL, NULL);
          nXSelEnd /= MILLIPOINT;
        }
        else
        {
          nXSelEnd = gnEmailTextWidth;
        }
        if (nXSelStart != nXSelEnd)
        {
          xwimp_set_colour (wimp_COLOUR_BLACK);
          xos_plot (os_PLOT_POINT | os_MOVE_TO, nXPos + nXSelStart, nYPos);
          xos_plot (os_PLOT_RECTANGLE | os_PLOT_INVERSE_TO,
            nXPos + nXSelEnd - 1, nYPos + gnEmailRowHeight - 1);
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Redraw the email list
void RedrawMain (wimp_draw *psRedraw)
{
  int                   nVisMinX = psRedraw->box.x0;
//  int                   nVisMinY = psRedraw->box.y0;
//  int                   nVisMaxX = psRedraw->box.x1;
  int                   nVisMaxY = psRedraw->box.y1;

//  int                   nRedMinX = psRedraw->clip.x0;
  int                   nRedMinY = psRedraw->clip.y0;
//  int                   nRedMaxX = psRedraw->clip.x1;
  int                   nRedMaxY = psRedraw->clip.y1;

  int                   nScrollX = psRedraw->xscroll;
  int                   nScrollY = psRedraw->yscroll;

  int                   nColumn;
  int                   nRow;
  char                  szCellText[1024];
  int                   nXPos;
  int                   nYPos;
  int                   nRowStart;
  int                   nRowEnd;
  char                  *szSplit;
  int                   nStrLen;
  font_f                hFont;
  int                   nEllipsisWidth;
  bool                  boSprite;
  wimp_icon             sIcon;
  char                  szSpriteName[32];
  int                   nMinWidth = 0;

  sIcon.flags = wimp_ICON_SPRITE | wimp_ICON_VCENTRED
    | wimp_ICON_INDIRECTED
    | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT)
    | (wimp_COLOUR_VERY_LIGHT_GREY << wimp_ICON_BG_COLOUR_SHIFT)
    | (wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT);

  sIcon.data.indirected_sprite.id = (osspriteop_id)(szSpriteName);
  sIcon.data.indirected_sprite.area = gpcSprites;
  sIcon.data.indirected_sprite.size = sizeof(szSpriteName);

  nRowStart = ((-ROW_YOFFSET + nVisMaxY - nScrollY - nRedMaxY)
    / gnRowHeight) - 1;
  nRowEnd = ((-ROW_YOFFSET + nVisMaxY - nScrollY - nRedMinY)
    / gnRowHeight) + 1;

  RANGE (nRowStart, 0, DETAILS_MAX);
  RANGE (nRowEnd, 0, DETAILS_MAX);

  xwimp_set_font_colours (wimp_COLOUR_VERY_LIGHT_GREY,
    wimp_COLOUR_BLACK);

  // Plot the columns
  for (nRow = nRowStart;
    ((nRow < nRowEnd) && (gasDetails[ganSort[nRow]].nSize >= 0)
    && (ganSort[nRow] != EMAIL_INVALID)); nRow++)
  {
    if (gasDetails[ganSort[nRow]].szRawEmail != NULL)
    {
      hFont = ghFont;
      nEllipsisWidth = gnEllipsisWidth;
    }
    else
    {
      hFont = ghFontB;
      nEllipsisWidth = gnEllipsisWidthB;
    }

    for (nColumn = 0; nColumn < COLUMNS_MAX - 1; nColumn++)
    {
      // Draw a boundary box
/*
      xwimp_set_colour (wimp_COLOUR_BLACK);
      xos_plot (os_PLOT_POINT | os_MOVE_TO,
        COLUMN_XOFFSET + nVisMinX - nScrollX + ganColWidth[nColumn],
        -ROW_YOFFSET + nVisMaxY - nScrollY - (nRow + 0) * gnRowHeight);
      xos_plot (os_PLOT_DOTTED | os_PLOT_TO,
        COLUMN_XOFFSET + nVisMinX - nScrollX + ganColWidth[nColumn],
        -ROW_YOFFSET + nVisMaxY - nScrollY - (nRow + 1) * gnRowHeight);
      xos_plot (os_PLOT_DOTTED | os_PLOT_TO,
        COLUMN_XOFFSET + nVisMinX - nScrollX + ganColWidth[nColumn + 1],
        -ROW_YOFFSET + nVisMaxY - nScrollY - (nRow + 1) * gnRowHeight);
*/
      boSprite = FALSE;

      switch (nColumn)
      {
        case 0:
          switch (gasDetails[ganSort[nRow]].eMailState)
          {
            case MAILSTATE_LOCAL:
              strncpy (szSpriteName, "local", sizeof (szSpriteName));
              break;
            case MAILSTATE_REMOTE:
              strncpy (szSpriteName, "remote", sizeof (szSpriteName));
              break;
            case MAILSTATE_GETTING:
              strncpy (szSpriteName, "getting", sizeof (szSpriteName));
              break;
            case MAILSTATE_DELETING:
              strncpy (szSpriteName, "deleted", sizeof (szSpriteName));
              break;
            default:
              strncpy (szSpriteName, "", sizeof (szSpriteName));
              break;
          }
          nMinWidth = 44;
          boSprite = TRUE;
          break;
        case 1:
          sprintf (szCellText, "%d", gasDetails[ganSort[nRow]].nMsgNum);
          break;
        case 2:
          CopySize (gasDetails[ganSort[nRow]].nServerSize, szCellText);
          break;
        case 3:
          strncpy (szCellText, gasDetails[ganSort[nRow]].szSenderDisplay,
            sizeof (szCellText));
          break;
        case 4:
          strncpy (szCellText, gasDetails[ganSort[nRow]].szSubject,
            sizeof (szCellText));
          break;
        case 5:
          DateToText (gasDetails[ganSort[nRow]].pcDate, szCellText,
            sizeof (szCellText));
          break;
        default:
          strncpy (szCellText, "Error", sizeof (szCellText));
          break;
      }

      if (!boSprite)
      {
        // Plot text
        nXPos = COLUMN_XOFFSET + nVisMinX - nScrollX + ganColWidth[nColumn]
          + TEXT_X_OFFSET;
        nYPos = -ROW_YOFFSET + nVisMaxY - nScrollY - (nRow + 1) * gnRowHeight
          + gnTextYOffset;

        nStrLen = strlen (szCellText);
        xfont_scan_string (hFont, szCellText, (font_GIVEN_FONT
          | font_GIVEN_LENGTH), MILLIPOINT * (ganColWidth[nColumn + 1]
          - ganColWidth[nColumn] - TEXT_X_OFFSET) - nEllipsisWidth,
          MILLIPOINT * gnRowHeight, NULL,
          NULL, nStrLen, & szSplit, NULL, NULL, NULL);

        if ((szSplit >= szCellText) && (szSplit < (szCellText + nStrLen)))
        {
          * szSplit = '';
          * (szSplit + 1) = 0;
        }
        if ((MILLIPOINT * (ganColWidth[nColumn + 1] - ganColWidth[nColumn]
          - TEXT_X_OFFSET)) < nEllipsisWidth)
        {
          * szCellText = 0;
        }

        xfont_paint (hFont, szCellText, font_OS_UNITS | font_GIVEN_FONT,
          nXPos, nYPos, NULL, NULL, 18);
      }
      else
      {
        // Plot sprite
        if ((ganColWidth[nColumn + 1] - ganColWidth[nColumn]) >= nMinWidth)
        {
          sIcon.extent.x0 = COLUMN_XOFFSET + ganColWidth[nColumn];
          sIcon.extent.y0 = - ROW_YOFFSET - (nRow + 1) * gnRowHeight;
          sIcon.extent.x1 = COLUMN_XOFFSET + ganColWidth[nColumn + 1];
          sIcon.extent.y1 = - ROW_YOFFSET - (nRow + 1) * gnRowHeight
            + gnRowHeight;
          xwimp_plot_icon (& sIcon);
        }
      }
    }

    if (gasDetails[ganSort[nRow]].boSelected)
    {
      xwimp_set_colour (wimp_COLOUR_BLACK);
      xos_plot (os_PLOT_POINT | os_MOVE_TO,
        COLUMN_XOFFSET + nVisMinX - nScrollX + ganColWidth[0],
        - 1 - ROW_YOFFSET + nVisMaxY - nScrollY - (nRow + 0) * gnRowHeight);
      xos_plot (os_PLOT_RECTANGLE | os_PLOT_INVERSE_TO,
        COLUMN_XOFFSET + nVisMinX - nScrollX + ganColWidth[COLUMNS_MAX - 1],
        -ROW_YOFFSET + nVisMaxY - nScrollY - (nRow + 1) * gnRowHeight);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Redraw the email list button bar
void RedrawMainHead (wimp_draw *psRedraw)
{
//  int                   nVisMinX = psRedraw->box.x0;
//  int                   nVisMinY = psRedraw->box.y0;
//  int                   nVisMaxX = psRedraw->box.x1;
//  int                   nVisMaxY = psRedraw->box.y1;

//  int                   nRedMinX = psRedraw->clip.x0;
//  int                   nRedMinY = psRedraw->clip.y0;
//  int                   nRedMaxX = psRedraw->clip.x1;
//  int                   nRedMaxY = psRedraw->clip.y1;

//  int                   nScrollX = psRedraw->xscroll;
//  int                   nScrollY = psRedraw->yscroll;
  int                   nColumn;
  wimp_icon             sIcon;
  wimp_icon             sSpriteIcon;
  char                  szInd[] = "R1";
  char                  szHeading[32];
  char                  szTag[8];
  char                  szSpriteInd[32] = "R1;Smailstate";
  char                  szEmpty[2] = "";

  psRedraw = psRedraw;

  sIcon.flags = wimp_ICON_TEXT | wimp_ICON_VCENTRED | wimp_ICON_FILLED
    | wimp_ICON_INDIRECTED | wimp_ICON_BORDER
    | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT)
    | (wimp_COLOUR_VERY_LIGHT_GREY << wimp_ICON_BG_COLOUR_SHIFT)
    | (wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT);

  sIcon.data.indirected_text.validation = szInd;
  sIcon.data.indirected_text.text = szHeading;
  sIcon.data.indirected_text.size = sizeof(szHeading);

  sSpriteIcon.flags = wimp_ICON_TEXT | wimp_ICON_SPRITE | wimp_ICON_FILLED
    | wimp_ICON_INDIRECTED | wimp_ICON_BORDER | wimp_ICON_VCENTRED
    | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT)
    | (wimp_COLOUR_VERY_LIGHT_GREY << wimp_ICON_BG_COLOUR_SHIFT)
    | (wimp_BUTTON_CLICK << wimp_ICON_BUTTON_TYPE_SHIFT);

  sSpriteIcon.data.indirected_text_and_sprite.text = szEmpty;
  sSpriteIcon.data.indirected_text_and_sprite.validation = szSpriteInd;
  sSpriteIcon.data.indirected_text_and_sprite.size = sizeof(szEmpty);

  // Plot the headers
  for (nColumn = 0; nColumn < COLUMNS_MAX - 1; nColumn++)
  {
    // Draw the headings
    if (nColumn != 0)
    {
      sIcon.extent.x0 = COLUMN_XOFFSET + ganColWidth[nColumn];
      sIcon.extent.y0 = - BUTTON_YOFFSET - HEADER_HEIGHT;
      sIcon.extent.x1 = COLUMN_XOFFSET + ganColWidth[nColumn + 1];
      sIcon.extent.y1 = - BUTTON_YOFFSET;

      sprintf (szTag, "Col%d", nColumn + 1);
      strncpy (szHeading, Tag(szTag), 12);

      xwimp_plot_icon (& sIcon);
    }
    else
    {
      sSpriteIcon.extent.x0 = COLUMN_XOFFSET + ganColWidth[nColumn];
      sSpriteIcon.extent.y0 = - BUTTON_YOFFSET - HEADER_HEIGHT;
      sSpriteIcon.extent.x1 = COLUMN_XOFFSET + ganColWidth[nColumn + 1];
      sSpriteIcon.extent.y1 = - BUTTON_YOFFSET;

      xwimp_plot_icon (& sSpriteIcon);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Update the size of the main window
void SetMainExtent (int nEmailMax)
{
  int                   nWidth;
  int                   nHeight;
  os_box                sSize;
  wimp_window_state     sWindowState;
  wimp_window_state     sPaneState;

  if (nEmailMax < 0)
  {
    nEmailMax = gnDetailsNum;
  }

  nWidth = ganColWidth[COLUMNS_MAX - 1];
  nHeight = ROW_YOFFSET + gnRowHeight * nEmailMax;
  if (nHeight < MAIN_WIN_MIN_HEIGHT)
  {
    nHeight = MAIN_WIN_MIN_HEIGHT;
  }

  sSize.x0 = 0;
  sSize.y0 = - nHeight;
  sSize.x1 = nWidth;
  sSize.y1 = 0;

  xwimp_set_extent (gwhMain, & sSize);

  sSize.x0 = 0;
  sSize.y0 = -ROW_YOFFSET;
  sSize.x1 = nWidth;
  sSize.y1 = 0;
  xwimp_set_extent (gwhMaHe, & sSize);

  sWindowState.w = gwhMain;
  xwimp_get_window_state (& sWindowState);

  if ((sWindowState.flags & wimp_WINDOW_OPEN) != 0)
  {
    xwimp_open_window ((wimp_open *)(& sWindowState));
    sPaneState.w = gwhMaHe;
    xwimp_get_window_state (& sPaneState);
    sWindowState.w = gwhMaHe;
    sWindowState.next = sPaneState.next;
    xwimp_open_window ((wimp_open *)(& sWindowState));
  }
}

//////////////////////////////////////////////////////////////////
// Clear all of the selected emails
void ClearAllSelected (void)
{
  int                   nCount;

  for (nCount = 0; nCount < gnDetailsNum; nCount++)
  {
    if (gasDetails[ganSort[nCount]].boSelected)
    {
      ToggleSelectRow (nCount);
    }

    gasDetails[ganSort[nCount]].boSelected = FALSE;
  }
}

//////////////////////////////////////////////////////////////////
// Returns the email number of the screen y position
int EmailRow (int nYPos)
{
  int                   nEmailNum;

  nEmailNum = ((ROW_YOFFSET + nYPos) / (-gnRowHeight));
  if (nEmailNum < 0)
  {
    nEmailNum = EMAIL_INVALID;
  }
  if (nEmailNum >= gnDetailsNum)
  {
    nEmailNum = EMAIL_INVALID;
  }

  return nEmailNum;
}

//////////////////////////////////////////////////////////////////
// Redraws an email row
void ToggleSelectRow (int nRow)
{
  osbool                boMore;
  wimp_draw             sRedraw;

  if (nRow != EMAIL_INVALID)
  {
    gasDetails[ganSort[nRow]].boSelected =
      !gasDetails[ganSort[nRow]].boSelected;

    sRedraw.w = gwhMain;
    sRedraw.box.x0 = ganColWidth[0];
    sRedraw.box.y0 = -ROW_YOFFSET - (nRow + 1) * gnRowHeight;
    sRedraw.box.x1 = ganColWidth[COLUMNS_MAX - 1];
    sRedraw.box.y1 = -ROW_YOFFSET - (nRow + 0) * gnRowHeight;

    xwimp_update_window (& sRedraw, & boMore);

    while (boMore)
    {
      // Redraw the window
      xwimp_set_colour (wimp_COLOUR_BLACK);
      xos_plot (os_PLOT_POINT | os_MOVE_TO,
        sRedraw.box.x1 - 1, sRedraw.box.y1);
      xos_plot (os_PLOT_RECTANGLE | os_PLOT_INVERSE_TO,
        sRedraw.box.x0, sRedraw.box.y0);

      xwimp_get_rectangle (& sRedraw, & boMore);
    }
  }
  gboTentativeSelection = FALSE;
}

//////////////////////////////////////////////////////////////////
// Create and open a new email window
void CreateEmailWindow (int nEmailNum)
{
  wimp_WINDOW_INFO(20)        sWindow;
  wimp_window_info            *psWindow = (wimp_window_info*)&sWindow;
  int                         nCount;
  int                         nAllocSuccess;
  int                         nFirstMIMEText;
  int                         nHeaderEnd;
  bool                        boHeaderFound;
  Details                     *psDetails;
  int                         nSize;
  bool                        boAttachments;

  if (gasDetails[nEmailNum].whWindow != wimp_BACKGROUND)
  {
    // Email is already open
    OpenWindowInitPane (gasDetails[nEmailNum].whWindow,
      gasDetails[nEmailNum].whHead, PANE_TOP);
  }
  else
  {
    nAllocSuccess = 1;
    boAttachments = FALSE;

    // Decode any MIME headers
    CheckMIME (nEmailNum);

    // If there are MIME attachments, we need to recreate the email
    // for formatting from the first section
    if ((gasDetails[nEmailNum].nMIMEListNum > 1)
      || ((gasDetails[nEmailNum].nMIMEListNum == 1)
      && (!gasDetails[nEmailNum].asMIMEList[0].boText))
      || ((gasDetails[nEmailNum].nMIMEListNum == 1)
      && (gasDetails[nEmailNum].asMIMEList[0].eEncoding
      != CTENCODING_PLAIN)))
    {
      nAllocSuccess = flex_reanchor(
        (flex_ptr)(& gasDetails[nEmailNum].szPreMIMEEmail),
        (flex_ptr)(& gasDetails[nEmailNum].szRawEmail));
      if (nAllocSuccess != 0)
      {
        gasDetails[nEmailNum].szRawEmail = NULL;
        gasDetails[nEmailNum].nPreMIMESize = gasDetails[nEmailNum].nSize;

        // Find the header size
        boHeaderFound = FALSE;
        nHeaderEnd = 0;
        psDetails = & gasDetails[nEmailNum];
        while ((!boHeaderFound)
          && (nHeaderEnd < psDetails->nSize))
        {
          if ((psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0a)
            || (psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0d))
          {
            if (nHeaderEnd < (psDetails->nSize - 3))
            {
              if ((psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0a)
                || (psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0d))
              {
                nHeaderEnd++;
                if ((psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0a)
                  || (psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0d))
                {
                  boHeaderFound = TRUE;
                  nHeaderEnd++;

                  if ((psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0a)
                    || (psDetails->szPreMIMEEmail[nHeaderEnd] == 0x0d))
                  {
                    nHeaderEnd++;
                  }
                }
              }
            }
          }
          nHeaderEnd++;
        }
        nHeaderEnd--;

        // Find the first piece of MIME text
        nFirstMIMEText = 0;
        while ((!psDetails->asMIMEList[nFirstMIMEText].boText)
          && (nFirstMIMEText < psDetails->nMIMEListNum))
        {
          nFirstMIMEText++;
        }
        // If we found a piece of text we can continue
        if (nFirstMIMEText < psDetails->nMIMEListNum)
        {
          // Calculate the preliminary size
          switch (psDetails->asMIMEList[nFirstMIMEText].eEncoding)
          {
            case CTENCODING_BASE64:
              nSize = nHeaderEnd
                + ((psDetails->asMIMEList[nFirstMIMEText].nSizePre * 3) / 4)
                + 3;
              break;
            case CTENCODING_QUOTEDPRINTABLE:
            case CTENCODING_PLAIN:
            default:
              nSize = nHeaderEnd
                + psDetails->asMIMEList[nFirstMIMEText].nSizePre;
              break;
          }
        }
        else
        {
          nSize = nHeaderEnd + 2;
        }

//        REPORTVAR ("Size allocated = %d", nSize);
        nAllocSuccess = flex_alloc (
          (flex_ptr)(& gasDetails[nEmailNum].szRawEmail), nSize);

        if (nAllocSuccess != 0)
        {
          psDetails->nSize = nSize;

          // Transfer the header
          memcpy (gasDetails[nEmailNum].szRawEmail,
            gasDetails[nEmailNum].szPreMIMEEmail, nHeaderEnd);

          if (nFirstMIMEText < psDetails->nMIMEListNum)
          {
            nSize -= nHeaderEnd;
            // Decode the attachment
            switch (psDetails->asMIMEList[nFirstMIMEText].eEncoding)
            {
              case CTENCODING_BASE64:
                DecodeBase64 (psDetails->szPreMIMEEmail
                  + psDetails->asMIMEList[nFirstMIMEText].nStartPos,
                  psDetails->asMIMEList[nFirstMIMEText].nSizePre,
                  psDetails->szRawEmail + nHeaderEnd, & nSize);
                break;
              case CTENCODING_QUOTEDPRINTABLE:
                DecodeQuotedPrintable (psDetails->szPreMIMEEmail
                  + psDetails->asMIMEList[nFirstMIMEText].nStartPos,
                  psDetails->asMIMEList[nFirstMIMEText].nSizePre,
                  psDetails->szRawEmail + nHeaderEnd, & nSize);
                break;
              case CTENCODING_PLAIN:
              default:
                memcpy (psDetails->szRawEmail + nHeaderEnd,
                  psDetails->szPreMIMEEmail
                  + psDetails->asMIMEList[nFirstMIMEText].nStartPos,
                  psDetails->asMIMEList[nFirstMIMEText].nSizePre);
                break;
            }

            boAttachments = TRUE;

            // Resize the flex memory
            nSize += nHeaderEnd + 2;
//            REPORTVAR ("Size needed = %d", nSize);
            nAllocSuccess = flex_extend (
              (flex_ptr)(& gasDetails[nEmailNum].szRawEmail), nSize);
            if (nAllocSuccess != 0)
            {
              psDetails->nSize = nSize;
              // Add two new lines just in case
              gasDetails[nEmailNum].szRawEmail[nSize - 2] = 0x0a;
              gasDetails[nEmailNum].szRawEmail[nSize - 1] = 0x0a;
            }
            else
            {
              // A flex_alloc failed, so we need to sort things out
              flex_free ((flex_ptr)(& gasDetails[nEmailNum].szRawEmail));
              // If this fails, there's not much we can do about it!
              flex_reanchor(
                (flex_ptr)(& gasDetails[nEmailNum].szRawEmail),
                (flex_ptr)(& gasDetails[nEmailNum].szPreMIMEEmail));
              gasDetails[nEmailNum].nSize
                = gasDetails[nEmailNum].nPreMIMESize;
              gasDetails[nEmailNum].szPreMIMEEmail = NULL;
              gasDetails[nEmailNum].nPreMIMESize = 0;
            }
          }
          else
          {
            // There is no body to the email (just a header)
            boAttachments = TRUE;
            psDetails->nSize = nSize;
            // Add two new lines just in case
            gasDetails[nEmailNum].szRawEmail[nSize - 2] = 0x0a;
            gasDetails[nEmailNum].szRawEmail[nSize - 1] = 0x0a;
          }
        }
        else
        {
          // A flex_alloc failed, so we need to return the anchor
          // If this fails, there's not much we can do about it!
          flex_reanchor(
            (flex_ptr)(& gasDetails[nEmailNum].szRawEmail),
            (flex_ptr)(& gasDetails[nEmailNum].szPreMIMEEmail));
          gasDetails[nEmailNum].szPreMIMEEmail = NULL;
          gasDetails[nEmailNum].nPreMIMESize = 0;
        }
      }
    }


    if (nAllocSuccess != 0)
    {
      nAllocSuccess = CreateFormattedEmail (nEmailNum);
    }

    if (nAllocSuccess != 0)
    {
      sWindow.w = gwhText;
      xwimp_get_window_info (psWindow);

//      gnOpenOffset = (OPENWIN_OFFSET_MAX + gnOpenOffset + OPENWIN_OFFSET)
//        % OPENWIN_OFFSET_MAX;

//      sWindow.visible.x0 -= gnOpenOffset;
//      sWindow.visible.y0 += gnOpenOffset;
//      sWindow.visible.x1 -= gnOpenOffset;
//      sWindow.visible.y1 += gnOpenOffset;

      sWindow.extent.x0 = 0;
      sWindow.extent.x1 = gnEmailTextWidth + (2 * EMAIL_TEXT_X_OFFSET);

      sWindow.extent.y0 = - ((gasDetails[nEmailNum].nLineMax + 1)
        * gnEmailRowHeight) - EMAIL_TEXT_Y_OFFSET;
      sWindow.extent.y1 = 0;

      xwimp_create_window ((wimp_window *)((char *)(psWindow)
        + sizeof(wimp_w)), & gasDetails[nEmailNum].whWindow);

      sWindow.w = gwhEmHe;
      xwimp_get_window_info (psWindow);

      sWindow.extent.x0 = 0;
      sWindow.extent.x1 = gnEmailTextWidth + (2 * EMAIL_TEXT_X_OFFSET);

      // Update the 'From:' (0)  and 'Subject:' (1) icons
      psWindow->icons[0].data.indirected_text.text
        = gasDetails[nEmailNum].szSender;
      psWindow->icons[0].data.indirected_text.size
        = sizeof (gasDetails[nEmailNum].szSender);
      gasDetails[nEmailNum].ihSenderIcon = 0;

      psWindow->icons[1].data.indirected_text.text
        = gasDetails[nEmailNum].szSubject;
      psWindow->icons[1].data.indirected_text.size
        = sizeof (gasDetails[nEmailNum].szSubject);
      gasDetails[nEmailNum].ihSubjectIcon = 1;

      // Set the attachments details
      if (boAttachments)
      {
        if (gasDetails[nEmailNum].nMIMEListNum < 100)
        {
          sprintf (gasDetails[nEmailNum].szAttachNum, "%d",
            gasDetails[nEmailNum].nMIMEListNum);
        }
        else
        {
          strcpy (gasDetails[nEmailNum].szAttachNum, "99+");
        }
      }
      else
      {
        strcpy (gasDetails[nEmailNum].szAttachNum, "0");
      }
      psWindow->icons[11].data.indirected_text.text
        = gasDetails[nEmailNum].szAttachNum;
      psWindow->icons[11].data.indirected_text.size
        = sizeof (gasDetails[nEmailNum].szAttachNum);
      gasDetails[nEmailNum].ihAttNumIcon = 11;

      xwimp_create_window ((wimp_window *)((char *)(psWindow)
        + sizeof(wimp_w)), & gasDetails[nEmailNum].whHead);

      SetIconGreyness (!boAttachments, gasDetails[nEmailNum].whHead, 11);

//      // Set the 'From' and 'Subject' icons
//      SetIconText (gasDetails[nEmailNum].szSender,
//        gasDetails[nEmailNum].whHead, 0);
//      SetIconText (gasDetails[nEmailNum].szSubject,
//        gasDetails[nEmailNum].whHead, 1);

      OpenWindowInitPaneNew (gasDetails[nEmailNum].whWindow,
        gasDetails[nEmailNum].whHead, PANE_TOP);

      // Add this to the list of email windows
      nCount = 0;
      while ((gawhEmailsOpen[nCount] != wimp_BACKGROUND)
        && (nCount < DETAILS_MAX))
      {
        nCount++;
      }
      if (nCount < DETAILS_MAX)
      {
        gawhEmailsOpen[nCount] = gasDetails[nEmailNum].whWindow;
        ganEmailsOpen[nCount] = nEmailNum;
      }
    }
    else
    {
      // Free up the MIME memory if it's been allocated
      if (gasDetails[nEmailNum].asMIMEList)
      {
        flex_free ((flex_ptr)(& gasDetails[nEmailNum].asMIMEList));
        gasDetails[nEmailNum].asMIMEList = NULL;
        gasDetails[nEmailNum].nMIMEListNum = 0;
      }
      ShowWarningTag ("Er7");
    }
  }
}

//////////////////////////////////////////////////////////////////
// Insert colour codes in to an email line
void InsertEmailColour (char *szFormatted, int * pnMemory, os_colour uCol, os_colour uBack)
{
  szFormatted[*pnMemory + 0] = 19;
  szFormatted[*pnMemory + 1] = (uBack >>  8) & 0xff;
  szFormatted[*pnMemory + 2] = (uBack >> 16) & 0xff;
  szFormatted[*pnMemory + 3] = (uBack >> 24) & 0xff;
  szFormatted[*pnMemory + 4] = (uCol >>  8) & 0xff;
  szFormatted[*pnMemory + 5] = (uCol >> 16) & 0xff;
  szFormatted[*pnMemory + 6] = (uCol >> 24) & 0xff;
  szFormatted[*pnMemory + 7] = 14;
  *pnMemory += 8;
}

//////////////////////////////////////////////////////////////////
// Format an email with new lines and colouring etc..
int CreateFormattedEmail (int nEmailNum)
{
  char                  *szCurrentPos;
  char                  *szLineEnd;
  char                  *szEndPos;
  font_scan_block       sScanBlock;
  int                   nLine;
  int                   nMemory;
  char                  *szFormatted;
  bool                  boNewLine;
  int                   nIndent;
  char                  *szIndentCheck;
  os_colour             uCol;
  int                   nAllocSuccess;

  nAllocSuccess = 0;
  szCurrentPos = gasDetails[nEmailNum].szRawEmail;

  if (szCurrentPos)
  {
    // First remove any control characters
    szEndPos = szCurrentPos + gasDetails[nEmailNum].nSize;

    while (szCurrentPos < szEndPos)
    {
      if ((szCurrentPos[0] < 0x20) && (szCurrentPos[0] != 0x00)
        && (szCurrentPos[0] != 0x0a) && (szCurrentPos[0] != 0x0d))
      {
        szCurrentPos[0] = 0x20;
      }
      szCurrentPos++;
    }
    szCurrentPos = gasDetails[nEmailNum].szRawEmail;

    sScanBlock.space.x = 0;
    sScanBlock.space.y = 0;
    sScanBlock.letter.x = 0;
    sScanBlock.letter.y = 0;
    sScanBlock.split_char = 32;

    uCol = os_COLOUR_BLACK;
    nMemory = 0;
    nLine = 0;
    boNewLine = TRUE;
    nIndent = 0;
    gasDetails[nEmailNum].nHeaderEndLine = 0;
    while (szCurrentPos < szEndPos)
    {
      if (boNewLine)
      {
        // Check indent
        szIndentCheck = szCurrentPos;
        while (strchr(" >", *szIndentCheck))
        {
          if (strchr(">", *szIndentCheck))
          {
            nIndent++;
          }
          szIndentCheck++;
        }
        // Are we at the end of the header?
        if ((gasDetails[nEmailNum].nHeaderEndLine == 0)
          && ((szCurrentPos[0] == 0x0a) || (szCurrentPos[0] == 0x0d)))
        {
          gasDetails[nEmailNum].nHeaderEndLine = nLine + 1;
        }
      }
      if (nIndent > 0)
      {
        // Add additional colouring bytes
        uCol = gauIndCol[nIndent % INDENT_CYCLE];
        nMemory += 8;
      }
      else
      {
        if (gasDetails[nEmailNum].nHeaderEndLine == 0)
        {
          uCol = os_COLOUR_DARK_GREY;
          nMemory += 8;
        }
      }

      // Read in a line of the email
      xfont_scan_string (ghEmailFont, szCurrentPos, (font_GIVEN_FONT
        | font_GIVEN_BLOCK),
        MILLIPOINT * gnEmailTextWidth,
        MILLIPOINT * gnEmailRowHeight, & sScanBlock,
        NULL, 0, & szLineEnd, NULL, NULL, NULL);

      if (szLineEnd == szCurrentPos)
      {
        // Could not split at a space
        xfont_scan_string (ghEmailFont, szCurrentPos, (font_GIVEN_FONT),
          MILLIPOINT * gnEmailTextWidth,
          MILLIPOINT * gnEmailRowHeight, NULL,
          NULL, 0, & szLineEnd, NULL, NULL, NULL);
      }

      // We now have the formatted start and end of the next line
      // We must add colours and styles

      // Pretent to copy the line to the newly formatted version
      nMemory += CopyFormatted (szCurrentPos, NULL,
        (szLineEnd - szCurrentPos), uCol, os_COLOUR_VERY_LIGHT_GREY);

      // Calculate the size
      nMemory++;

      if (uCol != os_COLOUR_BLACK)
      {
        // Add additional colouring bytes
        uCol = os_COLOUR_BLACK;
        nMemory += 8;
      }

      szCurrentPos = szLineEnd;
      if ((szCurrentPos[0] == 0x0a) || (szCurrentPos[0] == 0x0d))
      {
        szCurrentPos++;
        boNewLine = TRUE;
      }
      else
      {
        if (szCurrentPos[0] <= 0x20)
        {
          szCurrentPos++;
        }
        boNewLine = FALSE;
      }
      nLine++;
    }

    nLine++;

    // Allocate the memory for the formatted email

    nAllocSuccess = flex_alloc (
      (flex_ptr)(& gasDetails[nEmailNum].szFormEmail),
      nMemory);

    if (nAllocSuccess != 0)
    {
      nAllocSuccess = flex_alloc (
        (flex_ptr)(& gasDetails[nEmailNum].anLine),
        nLine * sizeof(int*));

      if (nAllocSuccess != 0)
      {
        nAllocSuccess = flex_alloc (
          (flex_ptr)(& gasDetails[nEmailNum].anRawLine),
          nLine * sizeof(int*));
      }
    }

    if (nAllocSuccess != 0)
    {
      // Now copy the text over
      uCol = os_COLOUR_BLACK;
      szFormatted = gasDetails[nEmailNum].szFormEmail;
      szCurrentPos = gasDetails[nEmailNum].szRawEmail;
      szEndPos = szCurrentPos + gasDetails[nEmailNum].nSize;
      nLine = 0;
      nMemory = 0;
      gasDetails[nEmailNum].nHeaderEndLine = 0;
      while (szCurrentPos < szEndPos)
      {
        gasDetails[nEmailNum].anLine[nLine] = nMemory;
        gasDetails[nEmailNum].anRawLine[nLine] = szCurrentPos
          - gasDetails[nEmailNum].szRawEmail;
        if (boNewLine)
        {
          // Check indent
          nIndent = 0;
          szIndentCheck = szCurrentPos;
          while (strchr (" >", *szIndentCheck))
          {
            if (strchr (">", *szIndentCheck))
            {
              nIndent++;
            }
            szIndentCheck++;
          }
          // Are we at the end of the header?
          if ((gasDetails[nEmailNum].nHeaderEndLine == 0)
            && ((szCurrentPos[0] == 0x0a) || (szCurrentPos[0] == 0x0d)))
          {
            gasDetails[nEmailNum].nHeaderEndLine = nLine + 1;
            gasDetails[nEmailNum].nLineHide = nLine + 1;
          }
        }
        if (nIndent > 0)
        {
          // Add additional colouring bytes
          uCol = gauIndCol[nIndent % INDENT_CYCLE];
          InsertEmailColour (szFormatted, & nMemory, uCol,
            os_COLOUR_VERY_LIGHT_GREY);
        }
        else
        {
          if (gasDetails[nEmailNum].nHeaderEndLine == 0)
          {
            uCol = os_COLOUR_DARK_GREY;
            InsertEmailColour (szFormatted, & nMemory, uCol,
              os_COLOUR_VERY_LIGHT_GREY);
          }
        }

        // Read in a line of the email
        xfont_scan_string (ghEmailFont, szCurrentPos, (font_GIVEN_FONT
          | font_GIVEN_BLOCK),
          MILLIPOINT * gnEmailTextWidth,
          MILLIPOINT * gnEmailRowHeight, & sScanBlock,
          NULL, 0, & szLineEnd, NULL, NULL, NULL);

        if (szLineEnd == szCurrentPos)
        {
          // Could not split at a space
          xfont_scan_string (ghEmailFont, szCurrentPos, (font_GIVEN_FONT),
            MILLIPOINT * gnEmailTextWidth,
            MILLIPOINT * gnEmailRowHeight, NULL,
            NULL, 0, & szLineEnd, NULL, NULL, NULL);
        }

        // We now have the formatted start and end of the next line
        // We must add colours and styles

        // Copy the line to the newly formatted version
        nMemory += CopyFormatted (szCurrentPos, szFormatted + nMemory,
          (szLineEnd - szCurrentPos), uCol, os_COLOUR_VERY_LIGHT_GREY);

        if (uCol != os_COLOUR_BLACK)
        {
          // Add additional colouring bytes
          uCol = os_COLOUR_BLACK;
          InsertEmailColour (szFormatted, & nMemory, uCol,
            os_COLOUR_VERY_LIGHT_GREY);
        }

        szFormatted[nMemory] = 0;
        nMemory++;

        szCurrentPos = szLineEnd;
        if ((szCurrentPos[0] == 0x0a) || (szCurrentPos[0] == 0x0d))
        {
          szCurrentPos++;
          boNewLine = TRUE;
        }
        else
        {
          if (szCurrentPos[0] <= 0x20)
          {
            szCurrentPos++;
          }
          boNewLine = FALSE;
        }
        nLine++;
      }

      gasDetails[nEmailNum].nLineMax = nLine;
    }
    gasDetails[nEmailNum].anLine[nLine] = nMemory;
    gasDetails[nEmailNum].anRawLine[nLine] = szCurrentPos
      - gasDetails[nEmailNum].szRawEmail;
  }
  else
  {
    gasDetails[nEmailNum].szFormEmail = NULL;
    gasDetails[nEmailNum].anLine = NULL;
    gasDetails[nEmailNum].anRawLine = NULL;
  }
  return nAllocSuccess;
}

//////////////////////////////////////////////////////////////////
// Copy a string and add formatting
int CopyFormatted (char * szFrom, char * szTo, int nLen, os_colour uCol, os_colour uBack)
{
  int                   nCopied;
  int                   nWordStart;
  int                   nWordEnd;
  font_f                hFont = ghEmailIFont;
  int                   nMemory;
  unsigned int          uStyles;
  int                   nSmiley;

  nMemory = nLen;
  uStyles = 0;
  nCopied = 0;
  while (nCopied < nLen)
  {
    if (((nCopied == 0) || (szFrom[nCopied - 1] == ' '))
      && (szFrom[nCopied] != ' '))
    {
      // Establish the start and end of the current word
      nWordStart = nCopied;
      nWordEnd = nCopied;
      do
      {
        nWordEnd++;
      } while ((nWordEnd <= nLen) && (szFrom[nWordEnd] > ' '));
      nWordEnd--;

      // Now do some checks on the word

      // Styles
      if (strchr ("*/_-", szFrom[nCopied]))
      {
        CheckStyles (szFrom + nWordStart, szFrom + nWordEnd, & uStyles);

        if (uStyles & STYLE_BOLD)
        {
          hFont = ghEmailBFont;
        }
        if (uStyles & STYLE_ITALIC)
        {
          hFont = ghEmailIFont;
        }
        if ((uStyles & STYLE_BOLD) && (uStyles & STYLE_ITALIC))
        {
          hFont = ghEmailBIFont;
        }

        if (uStyles & (STYLE_BOLD | STYLE_ITALIC))
        {
          if (szTo)
          {
            szTo[nCopied] = 26;
            szTo[nCopied + 1] = hFont;
            szTo += 2;
          }
          nMemory += 2;
        }

        if (uStyles & STYLE_UNDERLINE)
        {
          if (szTo)
          {
            szTo[nCopied] = 25;
            szTo[nCopied + 1] = 220;
            szTo[nCopied + 2] = 25;
            szTo += 3;
          }
          nMemory += 3;
        }
        else
        {
          if (uStyles & STYLE_STRIKE)
          {
            if (szTo)
            {
              szTo[nCopied] = 25;
              szTo[nCopied + 1] = 80;
              szTo[nCopied + 2] = 25;
              szTo += 3;
            }
            nMemory += 3;
          }
        }
      }
      // Check for other styles
      if (WordIsLink (szFrom + nWordStart, szFrom + nWordEnd))
      {
        uStyles |= STYLE_LINK;
      }

      if (uStyles & STYLE_LINK)
      {
        if (szTo)
        {
          szTo[nCopied + 0] = 19;
          szTo[nCopied + 1] = (uBack >>  8) & 0xff;
          szTo[nCopied + 2] = (uBack >> 16) & 0xff;
          szTo[nCopied + 3] = (uBack >> 24) & 0xff;
          szTo[nCopied + 4] = (os_COLOUR_LIGHT_GREEN >>  8) & 0xff;
          szTo[nCopied + 5] = (os_COLOUR_LIGHT_GREEN >> 16) & 0xff;
          szTo[nCopied + 6] = (os_COLOUR_LIGHT_GREEN >> 24) & 0xff;
          szTo[nCopied + 7] = 14;
          szTo += 8;
        }
        nMemory += 8;
      }

      if (gboEmoticons)
      {
        nSmiley = WordIsSmiley (szFrom + nWordStart, szFrom + nWordEnd);
        if (nSmiley != 0)
        {
          uStyles |= STYLE_HIDDEN;

          if (szTo)
          {
            szTo[nCopied + 0] = 19;
            szTo[nCopied + 1] = (uBack >>  8) & 0xff;
            szTo[nCopied + 2] = (uBack >> 16) & 0xff;
            szTo[nCopied + 3] = (uBack >> 24) & 0xff;
            szTo[nCopied + 4] = (uBack >>  8) & 0xff;
            szTo[nCopied + 5] = (uBack >> 16) & 0xff;
            szTo[nCopied + 6] = (uBack >> 24) & 0xff;
            szTo[nCopied + 7] = 14;
            szTo[nCopied + 8] = 21;
            szTo[nCopied + 9] = 255;
            szTo[nCopied + 10] = nSmiley;
            szTo += 11;
          }
          nMemory += 11;
        }
      }
    }

    // Copy the character across
    if (szTo)
    {
      szTo[nCopied] = szFrom[nCopied];
    }
    nCopied++;


    // Reset the styles after a word
    if ((nCopied == nLen) || (szFrom[nCopied] == ' '))
    {
      // End of word, we may need to reset the styles
      if (uStyles & (STYLE_BOLD | STYLE_ITALIC))
      {
        if (szTo)
        {
          szTo[nCopied] = 26;
          szTo[nCopied + 1] = ghEmailFont;
          szTo += 2;
        }
        nMemory += 2;

        uStyles &= ~(STYLE_BOLD | STYLE_ITALIC);
      }

      if (uStyles & (STYLE_UNDERLINE | STYLE_STRIKE))
      {
        if (szTo)
        {
          szTo[nCopied] = 25;
          szTo[nCopied + 1] = 0;
          szTo[nCopied + 2] = 0;
          szTo += 3;
        }
        nMemory += 3;
        uStyles &= ~(STYLE_UNDERLINE | STYLE_STRIKE);
      }
      if (uStyles & (STYLE_LINK | STYLE_HIDDEN))
      {
        if (szTo)
        {
          szTo[nCopied + 0] = 19;
          szTo[nCopied + 1] = (uBack >>  8) & 0xff;
          szTo[nCopied + 2] = (uBack >> 16) & 0xff;
          szTo[nCopied + 3] = (uBack >> 24) & 0xff;
          szTo[nCopied + 4] = (uCol >>  8) & 0xff;
          szTo[nCopied + 5] = (uCol >> 16) & 0xff;
          szTo[nCopied + 6] = (uCol >> 24) & 0xff;
          szTo[nCopied + 7] = 14;
          szTo += 8;
        }
        nMemory += 8;
        uStyles &= ~(STYLE_LINK | STYLE_HIDDEN);
      }
    }
  }

  return nMemory;
}

//////////////////////////////////////////////////////////////////
// Check the style settings for a particular word
void CheckStyles (char * szWordStart, char * szWordEnd, unsigned int * puStyles)
{
  bool                  boStyleStop;

  boStyleStop = FALSE;
  while ((szWordStart < szWordEnd) && (!boStyleStop))
  {
    if (*szWordStart == *szWordEnd)
    {
      switch (*szWordStart)
      {
        case '*':
          *puStyles |= STYLE_BOLD;
          break;
        case '/':
          *puStyles |= STYLE_ITALIC;
          break;
        case '_':
          *puStyles |= STYLE_UNDERLINE;
          break;
        case '-':
          *puStyles |= STYLE_STRIKE;
          break;
        default:
          boStyleStop = TRUE;
          break;
      }
    }
    else
    {
      boStyleStop = TRUE;
    }
    szWordStart++;
    szWordEnd--;
  }
}

//////////////////////////////////////////////////////////////////
// Initiate a outline drag from the dimensions of the given icon
void DragSelectionBox (bool boEdit, int nEmailNum, int nXPos, int nYPos)
{
  int                         nXinc;
  int                         nYinc;
  wimp_window_state           sWindowState;
  wimp_drag                   sDragInfo;
  Selection                   sSelect;
  wimp_auto_scroll_info       sScrollInfo;
  wimp_w                      whWindow;

  if (!gboDrag)
  {
    if (boEdit)
    {
      whWindow = gasEdit[nEmailNum].whWindow;
      FindEditCoords (nEmailNum, nXPos, nYPos, & sSelect.nLineEnd,
        & sSelect.nCharEnd);
    }
    else
    {
      whWindow = gasDetails[nEmailNum].whWindow;
      FindEmailCoords (nEmailNum, nXPos, nYPos, & sSelect.nLineEnd,
        & sSelect.nCharEnd);
    }

    sSelect.boEdit = boEdit;
    sSelect.nLineStart = gnSelectLineStart;
    sSelect.nCharStart = gnSelectCharStart;
//    sSelect.nLineEnd = gnSelectLineStart;
//    sSelect.nCharEnd = gnSelectCharStart;
    sSelect.whWindow = whWindow;
    sSelect.nEmailNum = nEmailNum;

    ChangeSelection (& sSelect);

    sScrollInfo.w = whWindow;
    sScrollInfo.pause_zone_sizes.x0 = 80;
    sScrollInfo.pause_zone_sizes.y0 = 80;
    sScrollInfo.pause_zone_sizes.x1 = 80;
    sScrollInfo.pause_zone_sizes.y1 = 80;
    sScrollInfo.pause_duration = 0;
    sScrollInfo.state_change = NULL;
    sScrollInfo.handle = NULL;
    xwimp_auto_scroll ((wimp_AUTO_SCROLL_ENABLE_HORIZONTAL
      | wimp_AUTO_SCROLL_ENABLE_VERTICAL), & sScrollInfo, NULL);

    sWindowState.w = whWindow;
    xwimp_get_window_state (& sWindowState);

    nXinc = sWindowState.visible.x0 - sWindowState.xscroll;
    nYinc = sWindowState.visible.y1 - sWindowState.yscroll;

    sDragInfo.w = 0;
    sDragInfo.type = wimp_DRAG_USER_POINT;
    sDragInfo.initial.x0 = nXPos;
    sDragInfo.initial.y0 = nYPos;
    sDragInfo.initial.x1 = nXPos;
    sDragInfo.initial.y1 = nYPos;
    sDragInfo.bbox = sWindowState.visible;
    sDragInfo.handle = NULL;
    sDragInfo.draw = NULL;
    sDragInfo.undraw = NULL;
    sDragInfo.redraw = NULL;

    xwimp_drag_box (& sDragInfo);

    gboDrag = TRUE;
  }
}

//////////////////////////////////////////////////////////////////
// Returns the line and char positions of a point in an email
void FindEmailCoords (int nEmailNum, int nXPos, int nYPos, int * pnLine, int * pnChar)
{
  wimp_window_state           sWindowState;
  int                         nXWin;
  int                         nYWin;
  int                         nLine;
  char                        *szChar;
  char                        *szLineStart;


  sWindowState.w = gasDetails[nEmailNum].whWindow;
  xwimp_get_window_state (& sWindowState);

  nXWin = nXPos - sWindowState.visible.x0 + sWindowState.xscroll
    - EMAIL_TEXT_X_OFFSET;
  nYWin = nYPos - sWindowState.visible.y1 + sWindowState.yscroll;

  nLine = (nYWin + EMAIL_TEXT_Y_OFFSET + gnEmailTextYOffset)
    / (-gnEmailRowHeight);

  nLine += gasDetails[nEmailNum].nLineHide;

  if (nLine >= gasDetails[nEmailNum].nLineMax)
  {
    nLine = gasDetails[nEmailNum].nLineMax - 1;
  }
  if (nLine < gasDetails[nEmailNum].nLineHide)
  {
    nLine = gasDetails[nEmailNum].nLineHide;
  }

  if (pnLine)
  {
    *pnLine = nLine;
  }

  if (pnChar)
  {
    szLineStart = gasDetails[nEmailNum].szFormEmail
      + gasDetails[nEmailNum].anLine[nLine];
    xfont_scan_string (ghEmailFont,
      szLineStart,
      (font_GIVEN_FONT | font_RETURN_CARET_POS),
      MILLIPOINT * nXWin,
      MILLIPOINT * gnEmailRowHeight / 2, NULL, NULL, 0,
      & szChar, NULL, NULL, NULL);

    if (szChar)
    {
      *pnChar = szChar - szLineStart;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Null Poll code
void NullPoll (wimp_block *pcBlock)
{
  wimp_pointer                sPointer;
  Selection                   sSelect;
  char                        *szWordStart;
  char                        *szWordEnd;
  bool                        boLink;

  pcBlock = pcBlock;

  xwimp_get_pointer_info (& sPointer);

  if (gboDrag)
  {
    switch (geSaveType)
    {
      case SAVETYPE_SELECTCHOOSE:
        if (gsSelect.boEdit)
        {
          FindEditCoords (gsSelect.nEmailNum, sPointer.pos.x, sPointer.pos.y,
            & sSelect.nLineEnd, & sSelect.nCharEnd);
          SetCaretPos (gsSelect.nEmailNum, sSelect.nLineEnd,
            sSelect.nCharEnd);
          gsCaret.nCharPref = gsCaret.nChar;
        }
        else
        {
          FindEmailCoords (gsSelect.nEmailNum, sPointer.pos.x,
            sPointer.pos.y,
            & sSelect.nLineEnd, & sSelect.nCharEnd);
        }
        sSelect.boEdit = gsSelect.boEdit;
        sSelect.nLineStart = gnSelectLineStart;
        sSelect.nCharStart = gnSelectCharStart;
        sSelect.whWindow = gsSelect.whWindow;
        sSelect.nEmailNum = gsSelect.nEmailNum;
        ChangeSelection (& sSelect);
        break;
      case SAVETYPE_COLUMN:
        SetColumnFromScreen (gnDragColumn, sPointer.pos.x);
        break;
      default:
        break;
    }
  }
  else
  {
    if (gnPointerEmail != EMAIL_INVALID)
    {
      FindWordAtCoords (gboPointerEdit, gnPointerEmail,
        sPointer.pos.x, sPointer.pos.y, & szWordStart, & szWordEnd);
      boLink = FALSE;
      if (szWordStart)
      {
        boLink = WordIsLink (szWordStart, szWordEnd);
      }
      if ((!boLink) && gboLinkPointer)
      {
        // Remove hand pointer
        gboLinkPointer = FALSE;
        xwimpspriteop_set_pointer_shape ("ptr_default", 97, 0, 0, NULL,
          NULL);
      }
      if (boLink && (!gboLinkPointer))
      {
        // Invoke hand pointer
        gboLinkPointer = TRUE;
        xwimpspriteop_set_pointer_shape ("ptr_point", 97, 0, 0, NULL,
          NULL);
      }
    }
    if (sPointer.w == gwhMaHe)
    {
      CheckColumnEdgePointer (sPointer.pos.x, sPointer.pos.y);
    }
  }

  CheckNetCom (NET_INVALID);
  NetworkLoop (geNetCom);
  CheckTimeout ();

}

//////////////////////////////////////////////////////////////////
// Find position of pount relative to a selecton (before/within/after)
RELPOS PointRelativeSelection (bool boEdit, int nEmailNum, int nXPos, int nYPos, Selection * psSelect, int * pnLine, int * pnChar)
{
  int                         nLine;
  int                         nChar;
  RELPOS                      eReturn;

  if (boEdit)
  {
    FindEditCoords (nEmailNum, nXPos, nYPos, & nLine, & nChar);
  }
  else
  {
    FindEmailCoords (nEmailNum, nXPos, nYPos, & nLine, & nChar);
  }

  if ((boEdit != psSelect->boEdit)
    || (nEmailNum != psSelect->nEmailNum)
    || (psSelect->nLineStart == -1))
  {
    eReturn = RELPOS_OTHEREMAIL;
  }
  else
  {
    eReturn = RELPOS_INVALID;
    if ((nLine < psSelect->nLineStart)
      || ((nLine == psSelect->nLineStart) && (nChar < psSelect->nCharStart)))
    {
      eReturn = RELPOS_BEFORE;
    }
    if ((nLine > psSelect->nLineEnd)
      || ((nLine == psSelect->nLineEnd) && (nChar > psSelect->nCharEnd)))
    {
      eReturn = RELPOS_AFTER;
    }
    if (eReturn == RELPOS_INVALID)
    {
      eReturn = RELPOS_WITHINSTART;
      if ((nLine - psSelect->nLineStart) > (psSelect->nLineEnd - nLine))
      {
        eReturn = RELPOS_WITHINEND;
      }
      else
      {
        if (((nLine - psSelect->nLineStart) == (psSelect->nLineEnd - nLine))
          && ((nChar - psSelect->nCharStart) > (psSelect->nCharEnd - nChar)))
        {
          eReturn = RELPOS_WITHINEND;
        }
      }
    }
  }

  if (pnLine)
  {
    *pnLine = nLine;
  }
  if (pnChar)
  {
    *pnChar = nChar;
  }
  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Create and open a new edit window
int CreateEditWindow (void)
{
  wimp_WINDOW_INFO(20)        sWindow;
  wimp_window_info            *psWindow = (wimp_window_info*)&sWindow;

  int                         nCount;
  int                         nEditNum;
  int                         nAllocSuccess;
  char                        szNumber[4];
  int                         nSignature;
  char                        szSignature[SIG_LINE_LENGTH
                                * (SIG_LINE_NUM + 1)];

  nEditNum = 0;
  while ((gasEdit[nEditNum].whWindow != wimp_BACKGROUND)
    && (nEditNum < EDIT_MAX))
  {
    nEditNum++;
  }

  if (nEditNum < EDIT_MAX)
  {
    nAllocSuccess = flex_alloc ((flex_ptr)(& gasEdit[nEditNum].szRawEmail),
      (EDIT_CHARS_MAX * sizeof(char)));

    if ((nAllocSuccess != 0) && (gasEdit[nEditNum].szRawEmail != NULL))
    {
      gasEdit[nEditNum].nEmailMem = (EDIT_CHARS_MAX * sizeof(char));

      for (nCount = 0; nCount < EDIT_CHARS_MAX; nCount++)
      {
        gasEdit[nEditNum].szRawEmail[nCount] = 0;
      }
      // Create space for formatting info
      nAllocSuccess = flex_alloc ((flex_ptr)(& gasEdit[nEditNum].anLine),
        (EDIT_LINE_MAX * sizeof(int)));

      if ((nAllocSuccess != 0) && (gasEdit[nEditNum].anLine != NULL))
      {
        gasEdit[nEditNum].nLineMem = (EDIT_LINE_MAX * sizeof(int));

        for (nCount = 0; nCount < EDIT_LINE_MAX; nCount++)
        {
          gasEdit[nEditNum].anLine[nCount] = 0;
        }

        sWindow.w = gwhEdit;
        err (xwimp_get_window_info (psWindow));

        gnOpenOffset = (OPENWIN_OFFSET_MAX + gnOpenOffset + OPENWIN_OFFSET)
          % OPENWIN_OFFSET_MAX;

        sWindow.visible.x0 -= gnOpenOffset;
        sWindow.visible.y0 += gnOpenOffset;
        sWindow.visible.x1 -= gnOpenOffset;
        sWindow.visible.y1 += gnOpenOffset;

        sWindow.extent.x0 = 0;
        sWindow.extent.x1 = gnEmailTextWidth + (2 * EMAIL_TEXT_X_OFFSET);

        sWindow.title_data.indirected_text.text =
          gasEdit[nEditNum].szWinTitle;
        sWindow.title_data.indirected_text.size = EDIT_TITLE_LEN;
        strncpy (gasEdit[nEditNum].szWinTitle, Tag("EditTitle"),
          EDIT_TITLE_LEN);

        err (xwimp_create_window ((wimp_window *)((char *)(psWindow)
          + sizeof(wimp_w)), & gasEdit[nEditNum].whWindow));

        gasEdit[nEditNum].szRawEmail[0] = 0x0a;
        gasEdit[nEditNum].nSize = 1;
        gasEdit[nEditNum].anLine[0] = 0;
        gasEdit[nEditNum].anLine[1] = 1;

        // Reset the attachments details
        gasEdit[nEditNum].nMIMEListNum = 0;
        for (nCount = 0; nCount < ATTACHMENT_EDIT_MAX; nCount++)
        {
          ClearMIMEEditDetails (& gasEdit[nEditNum].asAttachments[nCount]);
        }
        sprintf (gasEdit[nEditNum].szAttachNum, "%d",
          gasEdit[nEditNum].nMIMEListNum);

        sWindow.w = gwhEdHe;
        err (xwimp_get_window_info (psWindow));

        // Set the header window extent
        gasEdit[nEditNum].boAdvanced = gasAccount[gnAccount].boCCBCC;

        sWindow.extent.x0 = 0;
        sWindow.extent.x1 = gnEmailTextWidth + (2 * EMAIL_TEXT_X_OFFSET);
        if (gasEdit[nEditNum].boAdvanced)
        {
          gasEdit[nEditNum].nTextOffset = EDIT_TEXT_Y_OFFSET_MAX;
          sWindow.extent.y0 = - EDIT_HEAD_EXTENT_MAX;
          sWindow.icons[9].flags &= ~wimp_ICON_SHADED;
          sWindow.icons[12].flags &= ~wimp_ICON_SHADED;
          sWindow.icons[14].flags |= wimp_ICON_SELECTED;
        }
        else
        {
          gasEdit[nEditNum].nTextOffset = EDIT_TEXT_Y_OFFSET_MIN;
          sWindow.extent.y0 = - EDIT_HEAD_EXTENT_MIN;
          sWindow.icons[9].flags |= wimp_ICON_SHADED;
          sWindow.icons[12].flags |= wimp_ICON_SHADED;
          sWindow.icons[14].flags &= ~wimp_ICON_SELECTED;
        }
        sWindow.extent.y1 = 0;

        // Set the 'BCC to self' (13) icon
        if (gasAccount[gnAccount].boBCCToSelf)
        {
          sWindow.icons[13].flags |= wimp_ICON_SELECTED;
        }
        else
        {
          sWindow.icons[13].flags &= ~wimp_ICON_SELECTED;
        }

        // Update the 'To:' (0)  and 'Subject:' (1) icons
        psWindow->icons[0].data.indirected_text.text
          = gasEdit[nEditNum].szTo;
        psWindow->icons[0].data.indirected_text.size
          = sizeof (gasEdit[nEditNum].szTo);

        psWindow->icons[1].data.indirected_text.text
          = gasEdit[nEditNum].szSubject;
        psWindow->icons[1].data.indirected_text.size
          = sizeof (gasEdit[nEditNum].szSubject);

        // Update the 'CC:' (9)  and 'BCC:' (12) icons
        psWindow->icons[9].data.indirected_text.text
          = gasEdit[nEditNum].szCC;
        psWindow->icons[9].data.indirected_text.size
          = sizeof (gasEdit[nEditNum].szCC);

        psWindow->icons[12].data.indirected_text.text
          = gasEdit[nEditNum].szBCC;
        psWindow->icons[12].data.indirected_text.size
          = sizeof (gasEdit[nEditNum].szBCC);

        // Update the 'attachments' (18) icon
        psWindow->icons[18].data.indirected_text.text
          = gasEdit[nEditNum].szAttachNum;
        psWindow->icons[18].data.indirected_text.size
          = sizeof (gasEdit[nEditNum].szAttachNum);

        if (gasEdit[nEditNum].nMIMEListNum > 0)
        {
          sWindow.icons[18].flags &= ~wimp_ICON_SHADED;
        }
        else
        {
          sWindow.icons[18].flags |= wimp_ICON_SHADED;
        }

        err (xwimp_create_window ((wimp_window *)((char *)(psWindow)
          + sizeof(wimp_w)), & gasEdit[nEditNum].whHead));

        gasEdit[nEditNum].nLineMax = 1;
        gasEdit[nEditNum].nFormattedTo = 0;
        gasEdit[nEditNum].boInsert = FALSE;
        gasEdit[nEditNum].boLineChange = FALSE;
        gasEdit[nEditNum].boChanged = FALSE;

        // Is there a signature?
        nSignature = 0;
        for (nCount = 0; nCount < SIG_LINE_NUM; nCount++)
        {
          if (strlen (gasAccount[gnAccount].szSigLine[nCount]) > 0)
          {
            nSignature = (nCount + 1);
          }
        }

        strcpy (szSignature, "\n-- \n");
        for (nCount = 0; nCount < nSignature; nCount++)
        {
          strcat (szSignature, gasAccount[gnAccount].szSigLine[nCount]);
          strcat (szSignature, "\n");
        }

        if (nSignature > 0)
        {
          InsertText (nEditNum, 0, 0, szSignature, strlen (szSignature));
          ReFormat (nEditNum, -1, -1, NULL, NULL);
        }

        // Reformat everything
    //    ReFormat (nEditNum, -1, -1, NULL, NULL);

        OpenWindowInitPaneNew (gasEdit[nEditNum].whWindow,
          gasEdit[nEditNum].whHead, PANE_TOP);

        // Add this to the list of email windows
        nCount = 0;
        while ((gawhEditOpen[nCount] != wimp_BACKGROUND)
          && (nCount < EDIT_MAX))
        {
          nCount++;
        }
        if (nCount < EDIT_MAX)
        {
          gawhEditOpen[nCount] = gasEdit[nEditNum].whWindow;
          ganEditOpen[nCount] = nEditNum;
        }
        xwimp_set_caret_position (gasEdit[nEditNum].whHead,
          (wimp_i)0, 0, 0, -1, -1);
      }
      else
      {
        ShowWarningTag ("Er4");

        flex_free ((flex_ptr)(& gasEdit[nEditNum].szRawEmail));
        gasEdit[nEditNum].szRawEmail = NULL;
        nEditNum = -1;
      }
    }
    else
    {
      ShowWarningTag ("Er4");
      nEditNum = -1;
    }
  }
  else
  {
    sprintf(szNumber, "%d", EDIT_MAX);
    ShowWarningTagArg ("Er5", szNumber);
    nEditNum = -1;
  }

  return nEditNum;
}

//////////////////////////////////////////////////////////////////
// Destroy an Edit window and all of its associated data
void DestroyEditWindow (int nEditNum)
{
  int                         nEditSearch;
  bool                        boWinFound;
  int                         nCount;

  gasEdit[nEditNum].nSize = -1;
  strcpy (gasEdit[nEditNum].szTo, "");
  strcpy (gasEdit[nEditNum].szSubject, "");
  strcpy (gasEdit[nEditNum].szCC, "");
  strcpy (gasEdit[nEditNum].szBCC, "");

  if (gsCaret.whWindow == gasEdit[nEditNum].whWindow)
  {
    gboCaretLost = TRUE;
  }

  err (xwimp_delete_window (gasEdit[nEditNum].whWindow));
  gasEdit[nEditNum].whWindow = wimp_BACKGROUND;

  err (xwimp_delete_window (gasEdit[nEditNum].whHead));
  gasEdit[nEditNum].whHead = wimp_BACKGROUND;

  if (gasEdit[nEditNum].szRawEmail != NULL)
  {
    flex_free ((flex_ptr)(& gasEdit[nEditNum].szRawEmail));
    gasEdit[nEditNum].szRawEmail = NULL;
  }
  if (gasEdit[nEditNum].szFormEmail != NULL)
  {
    flex_free ((flex_ptr)(& gasEdit[nEditNum].szFormEmail));
    gasEdit[nEditNum].szFormEmail = NULL;
  }
  if (gasEdit[nEditNum].anLine != NULL)
  {
    flex_free ((flex_ptr)(& gasEdit[nEditNum].anLine));
    gasEdit[nEditNum].anLine = NULL;
  }

  gasEdit[nEditNum].boInsert = FALSE;
  gasEdit[nEditNum].boLineChange = FALSE;
  gasEdit[nEditNum].boAdvanced = FALSE;
  gasEdit[nEditNum].nTextOffset = EDIT_TEXT_Y_OFFSET_MIN;
  gasEdit[nEditNum].boChanged = FALSE;

  // Reset the attachments details
  for (nCount = 0; nCount < gasEdit[nEditNum].nMIMEListNum; nCount++)
  {
    FreeMIMEEditDetails (& gasEdit[nEditNum].asAttachments[nCount]);
  }
  gasEdit[nEditNum].nMIMEListNum = 0;
  sprintf (gasEdit[nEditNum].szAttachNum, "%d",
    gasEdit[nEditNum].nMIMEListNum);

  // Find and remove its reference
  boWinFound = FALSE;
  nEditSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
  {
    if (nEditNum == ganEditOpen[nEditSearch])
    {
      nCount = nEditSearch;
      while (gawhEditOpen[nCount] != wimp_BACKGROUND)
      {
        gawhEditOpen[nCount] = gawhEditOpen[nCount + 1];
        ganEditOpen[nCount] = ganEditOpen[nCount + 1];
        nCount++;
      }
      boWinFound = TRUE;
    }
    nEditSearch++;
  }
}

//////////////////////////////////////////////////////////////////
// Forgets all body data and frees memory from the given email
void DestroyEmailWindow (int nEmailNum)
{
  int                         nEmailSearch;
  bool                        boWinFound;
  int                         nCount;

  if (gasDetails[nEmailNum].whWindow != wimp_BACKGROUND)
  {
    err (xwimp_delete_window (gasDetails[nEmailNum].whWindow));
    gasDetails[nEmailNum].whWindow = wimp_BACKGROUND;
  }

  if (gasDetails[nEmailNum].whHead != wimp_BACKGROUND)
  {
    err (xwimp_delete_window (gasDetails[nEmailNum].whHead));
    gasDetails[nEmailNum].whHead = wimp_BACKGROUND;
  }

  if (gasDetails[nEmailNum].szRawEmail != NULL)
  {
    flex_free ((flex_ptr)(& gasDetails[nEmailNum].szRawEmail));
    gasDetails[nEmailNum].szRawEmail = NULL;

    if (gasDetails[nEmailNum].eMailState != MAILSTATE_GETTING)
    {
      gasDetails[nEmailNum].eMailState = MAILSTATE_REMOTE;
    }
  }

  if (gasDetails[nEmailNum].szFormEmail != NULL)
  {
    flex_free ((flex_ptr)(& gasDetails[nEmailNum].szFormEmail));
    gasDetails[nEmailNum].szFormEmail = NULL;
  }
  gasDetails[nEmailNum].nHeaderEndLine = 0;
  gasDetails[nEmailNum].nLineHide = 0;

  if (gasDetails[nEmailNum].anLine != NULL)
  {
    flex_free ((flex_ptr)(& gasDetails[nEmailNum].anLine));
    gasDetails[nEmailNum].anLine = NULL;
  }

  if (gasDetails[nEmailNum].anRawLine != NULL)
  {
    flex_free ((flex_ptr)(& gasDetails[nEmailNum].anRawLine));
    gasDetails[nEmailNum].anRawLine = NULL;
  }
  gasDetails[nEmailNum].nLineMax = 0;
  gasDetails[nEmailNum].boOpenOnLoad = FALSE;

  if (gasDetails[nEmailNum].asMIMEList != NULL)
  {
    flex_free ((flex_ptr)(& gasDetails[nEmailNum].asMIMEList));
    gasDetails[nEmailNum].asMIMEList = NULL;
    gasDetails[nEmailNum].nMIMEListNum = 0;
  }

  if (gasDetails[nEmailNum].szPreMIMEEmail != NULL)
  {
    flex_free ((flex_ptr)(& gasDetails[nEmailNum].szPreMIMEEmail));
    gasDetails[nEmailNum].szPreMIMEEmail = NULL;
    gasDetails[nEmailNum].nPreMIMESize = 0;
  }

  // Find and remove its reference
  boWinFound = FALSE;
  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (nEmailNum == ganEmailsOpen[nEmailSearch])
    {
      nCount = nEmailSearch;
      while (gawhEmailsOpen[nCount] != wimp_BACKGROUND)
      {
        gawhEmailsOpen[nCount] = gawhEmailsOpen[nCount + 1];
        ganEmailsOpen[nCount] = ganEmailsOpen[nCount + 1];
        nCount++;
      }
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }

  // Update the main window
  UpdateMain (nEmailNum, nEmailNum);
}

//////////////////////////////////////////////////////////////////
// Reformat to a given point
void ReFormat (int nEditNum, int nChangedLine, int nLineEnd, int * psStartLine, int * psEndLine)
{
  int                   nLineStart = 0;
  int                   nReturn = 0;
  int                   nLineEndFull;

  if (nLineEnd == -1)
  {
    // Reformat everything
    nLineEndFull = (gasEdit[nEditNum].nLineMem / sizeof(int));
  }
  else
  {
    nLineEndFull = nLineEnd;
  }

  if ((nChangedLine != -1)
    || (nLineEndFull > gasEdit[nEditNum].nFormattedTo))
  {
    if ((gasEdit[nEditNum].nFormattedTo < nChangedLine)
      || (nChangedLine == -1))
    {
      nLineStart = gasEdit[nEditNum].nFormattedTo;
    }
    else
    {
      nLineStart = nChangedLine - 1;
      if (nLineStart < 0)
      {
        nLineStart = 0;
      }
    }

    if (nLineStart < nLineEndFull)
    {
      nReturn = FormatLines (nEditNum, nLineStart, nLineEnd);
    }
    else
    {
      if (nChangedLine < gasEdit[nEditNum].nFormattedTo)
      {
        gasEdit[nEditNum].nFormattedTo = nChangedLine;
      }
    }
  }

  if (psStartLine)
  {
    *psStartLine = nLineStart;
  }
  if (psEndLine)
  {
    {
      *psEndLine = nLineStart + nReturn;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Reformat between points
//int FormatLines (int nEditNum, int nLineStart, int nLineEnd)
//{
//  char                  *szRawEmail;
//  char                  *szLineEnd;
//  char                  *szCurrentPos;
//  char                  *szEditEnd;
//  bool                  boFormatted;
//  int                   nLine;
//  font_scan_block       sScanBlock;
//  int                   nPos;
//  int                   nReturn;
//  int                   nAllocSuccess;
//  int                   nLineLength;
//  int                   nCurrentPos;
//  int                   nEditEnd;
//  int                   nLineEndShift;
//
//  sScanBlock.space.x = 0;
//  sScanBlock.space.y = 0;
//  sScanBlock.letter.x = 0;
//  sScanBlock.letter.y = 0;
//  sScanBlock.split_char = 32;
//
//  if (nLineEnd == -1)
//  {
//    // Reformat everything
//    nLineEnd = (gasEdit[nEditNum].nLineMem / sizeof(int));
//  }
//
//  // Draw the whole lot, a line at a time
//  szRawEmail = gasEdit[nEditNum].szRawEmail;
//  szCurrentPos = szRawEmail + gasEdit[nEditNum].anLine[nLineStart];
//  nLine = nLineStart;
//  szEditEnd = szRawEmail + gasEdit[nEditNum].nSize;
//  boFormatted = FALSE;
//  while ((szCurrentPos < szEditEnd) && (!boFormatted) && (nLine < nLineEnd))
//  {
//    // Find out how much to plot
//    xfont_scan_string (ghEmailFont, szCurrentPos, (font_GIVEN_FONT
//      | font_GIVEN_BLOCK),
//      MILLIPOINT * gnEmailTextWidth,
//      MILLIPOINT * gnEmailRowHeight, & sScanBlock,
//      NULL, 0, & szLineEnd, NULL, NULL, NULL);
//
//    if (szLineEnd == szCurrentPos)
//    {
//      // Could not split at a space
//      xfont_scan_string (ghEmailFont, szCurrentPos, (font_GIVEN_FONT),
//        MILLIPOINT * gnEmailTextWidth,
//        MILLIPOINT * gnEmailRowHeight, NULL,
//        NULL, 0, & szLineEnd, NULL, NULL, NULL);
//    }
//
//    nPos = szCurrentPos - szRawEmail;
//
//    szCurrentPos = szLineEnd;
//    nLineLength = szLineEnd - szRawEmail;
//
//    nLine++;
//    if ((szCurrentPos[0] == 0x0a) || (szCurrentPos[0] == 0x0d)
//      || (szCurrentPos[0] == 0x20))
//    {
//      szCurrentPos++;
//    }
//
//    if (nLine >= (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
//    {
//      nCurrentPos = szCurrentPos - szRawEmail;
//      nEditEnd = szEditEnd - szCurrentPos;
//      nLineEndShift = szLineEnd - szCurrentPos;
//      nAllocSuccess = ExtendLineMem (nEditNum);
//      szRawEmail = gasEdit[nEditNum].szRawEmail;
//      szCurrentPos = szRawEmail + nCurrentPos;
//      szEditEnd = szCurrentPos + nEditEnd;
//      szLineEnd = szCurrentPos + nLineEndShift;
//
//      if (nAllocSuccess == 0)
//      {
//        REPORT ("Reformatting error when extending line memory");
//        boFormatted = TRUE;
//      }
//    }
//
//    if (((szCurrentPos - szRawEmail) == gasEdit[nEditNum].anLine[nLine])
//      && (nLine < gasEdit[nEditNum].nFormattedTo)
//      && (nLine > (nLineStart + 1)))
//    {
//      boFormatted = TRUE;
//    }
//
//    gasEdit[nEditNum].anLine[nLine] = szCurrentPos - szRawEmail;
//
//    if ((gsCaret.nEditNum == nEditNum) && (gsCaret.nPos >= nPos)
//      && (gsCaret.nPos < nLineLength))
//    {
//      SetCaretPos (nEditNum, nLine - 1, gsCaret.nPos - nPos);
//    }
//  }
//
//  if (nLine > gasEdit[nEditNum].nFormattedTo)
//  {
//    gasEdit[nEditNum].nFormattedTo = nLine;
//  }
//
//  nReturn = nLine - nLineStart;
//
//  if ((szCurrentPos >= szEditEnd) || (nLine >= gasEdit[nEditNum].nLineMax))
//  {
//    gasEdit[nEditNum].nLineMax = nLine;
//    gasEdit[nEditNum].anLine[nLine] = gasEdit[nEditNum].nSize;
//    // Set the window size
//    SetEditHeight (nEditNum, nLine);
//  }
//
//  return nReturn;
//
//}

//////////////////////////////////////////////////////////////////
// Reformat between points
int FormatLines (int nEditNum, int nLineStart, int nLineEnd)
{
  char                  *szLineEnd;
  char                  *szCurrentPos;
  bool                  boFormatted;
  int                   nLine;
  font_scan_block       sScanBlock;
  int                   nPos;
  int                   nReturn;
  int                   nAllocSuccess;
  int                   nLineLength;
  int                   nCurrentPos;
  int                   nEditEnd;
  int                   nLineEndShift;
  char                  cLineEndChar;
  int                   nLineEndFull;

  sScanBlock.space.x = 0;
  sScanBlock.space.y = 0;
  sScanBlock.letter.x = 0;
  sScanBlock.letter.y = 0;
  sScanBlock.split_char = 32;

  if (nLineEnd == -1)
  {
    // Reformat everything
    nLineEndFull = (gasEdit[nEditNum].nLineMem / (int)sizeof(int));
  }
  else
  {
    nLineEndFull = nLineEnd;
  }

  // Draw the whole lot, a line at a time
  nCurrentPos = gasEdit[nEditNum].anLine[nLineStart];
  nLine = nLineStart;
  nEditEnd = gasEdit[nEditNum].nSize;
  boFormatted = FALSE;
  while ((nCurrentPos < nEditEnd) && (!boFormatted)
    && (nLine < nLineEndFull))
  {
    // Find out how much to plot
    szCurrentPos = gasEdit[nEditNum].szRawEmail + nCurrentPos;
    xfont_scan_string (ghEmailFont, szCurrentPos,
      (font_GIVEN_FONT | font_GIVEN_BLOCK),
      MILLIPOINT * gnEmailTextWidth,
      MILLIPOINT * gnEmailRowHeight, & sScanBlock,
      NULL, 0, & szLineEnd, NULL, NULL, NULL);

    if (szLineEnd == szCurrentPos)
    {
      // Could not split at a space
      xfont_scan_string (ghEmailFont, szCurrentPos, (font_GIVEN_FONT),
        MILLIPOINT * gnEmailTextWidth,
        MILLIPOINT * gnEmailRowHeight, NULL,
        NULL, 0, & szLineEnd, NULL, NULL, NULL);
    }

    nPos = nCurrentPos;
    nCurrentPos = szLineEnd - gasEdit[nEditNum].szRawEmail;
    nLineLength = nCurrentPos;

    nLine++;
    cLineEndChar = gasEdit[nEditNum].szRawEmail[nCurrentPos];
    if ((cLineEndChar == 0x0a) || (cLineEndChar == 0x0d)
      || (cLineEndChar == 0x20))
    {
      nCurrentPos++;
    }

    if (nLine >= (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
    {
      nAllocSuccess = ExtendLineMem (nEditNum);
      if (nLineEnd == -1)
      {
        // Reformat everything
        nLineEndFull = (gasEdit[nEditNum].nLineMem / (int)sizeof(int));
      }

      if (nAllocSuccess == 0)
      {
        REPORT ("Reformatting error when extending line memory");
        boFormatted = TRUE;
      }
    }

    if ((nLine < gasEdit[nEditNum].nFormattedTo)
      && (nLine > (nLineStart + 1))
      && (nCurrentPos == gasEdit[nEditNum].anLine[nLine]))
    {
      boFormatted = TRUE;
    }

    gasEdit[nEditNum].anLine[nLine] = nCurrentPos;

    if ((gsCaret.nEditNum == nEditNum) && (gsCaret.nPos >= nPos)
      && (gsCaret.nPos < nLineLength))
    {
      SetCaretPos (nEditNum, nLine - 1, gsCaret.nPos - nPos);
    }
  }

  if (nLine > gasEdit[nEditNum].nFormattedTo)
  {
    gasEdit[nEditNum].nFormattedTo = nLine;
  }

  nReturn = nLine - nLineStart;

  if ((nCurrentPos >= nEditEnd) || (nLine >= gasEdit[nEditNum].nLineMax))
  {
    gasEdit[nEditNum].nLineMax = nLine;
    gasEdit[nEditNum].anLine[nLine] = gasEdit[nEditNum].nSize;
    // Set the window size
    SetEditHeight (nEditNum, nLine);
  }

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Redraw an edit window
void RedrawEdit (wimp_draw *psRedraw, int nEditNum)
{
  int                   nVisMinX = psRedraw->box.x0;
//  int                   nVisMinY = psRedraw->box.y0;
//  int                   nVisMaxX = psRedraw->box.x1;
  int                   nVisMaxY = psRedraw->box.y1;

  int                   nRedMinX = psRedraw->clip.x0;
  int                   nRedMinY = psRedraw->clip.y0;
  int                   nRedMaxX = psRedraw->clip.x1;
  int                   nRedMaxY = psRedraw->clip.y1;

  int                   nScrollX = psRedraw->xscroll;
  int                   nScrollY = psRedraw->yscroll;

  int                   nLine;
  char                  *szCurrentPos;
  char                  *szEditEnd;
  int                   nXPos;
  int                   nYPos;
//  os_colour_number      nColour;
//  os_colour_number      nCaretColour;
  int                   nLineLen;
  int                   nLineStart;
  int                   nLineEnd;
  int                   nXSelStart;
  int                   nXSelEnd;
  char                  szPlotLine[1024*2];
  int                   nIndent;
  int                   nIndentCheck;
  os_colour             uCol;
  int                   nIndentPos;
  int                   nPlotLen;

  if (nEditNum != EDIT_INVALID)
  {
    xfont_set_font (ghEmailFont);

    nLineStart = ((-gasEdit[nEditNum].nTextOffset - gnEmailTextYOffset
      + nVisMaxY - nScrollY - nRedMaxY) / gnEmailRowHeight);
    nLineEnd = ((-gasEdit[nEditNum].nTextOffset - gnEmailTextYOffset
      + nVisMaxY - nScrollY - nRedMinY) / gnEmailRowHeight) + 1;

    RANGE (nLineStart, 0, gasEdit[nEditNum].nLineMax);
    RANGE (nLineEnd, 0, gasEdit[nEditNum].nLineMax);

    ReFormat (nEditNum, -1, nLineEnd, NULL, NULL);

    // Draw the whole lot, a line at a time
    nXPos = nVisMinX - nScrollX + EMAIL_TEXT_X_OFFSET;
    nLine = nLineStart;
    szCurrentPos = gasEdit[nEditNum].szRawEmail;
    szEditEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize;

      // Fill in the background
    xwimp_set_colour (wimp_COLOUR_WHITE);
    xos_plot (os_PLOT_POINT | os_MOVE_TO, nRedMinX, nRedMinY);
    xos_plot (os_PLOT_RECTANGLE | os_PLOT_TO, nRedMaxX, nRedMaxY);

    while ((nLine < nLineEnd) && (szCurrentPos < szEditEnd))
    {
      nYPos = nVisMaxY - nScrollY - ((nLine + 1) * gnEmailRowHeight)
        - gasEdit[nEditNum].nTextOffset;

      if (gasEdit[nEditNum].anLine[nLine + 1] != 0)
      {
        uCol = os_COLOUR_BLACK;
        nLineLen = gasEdit[nEditNum].anLine[nLine + 1]
          - gasEdit[nEditNum].anLine[nLine];

        RANGE (nLineLen, 0, (int)sizeof(szPlotLine));

        // Check indent
        nIndent = 0;
        szCurrentPos = gasEdit[nEditNum].szRawEmail
          + gasEdit[nEditNum].anLine[nLine];
        nIndentCheck = 0;
        while ((strchr (" >", szCurrentPos[nIndentCheck]))
          && (nIndentCheck < nLineLen))
        {
          if (strchr (">", szCurrentPos[nIndentCheck]))
          {
            nIndent++;
          }
          nIndentCheck++;
        }
        nIndentPos = 0;
        if (nIndent > 0)
        {
          // Add additional colouring bytes
          uCol = gauIndCol[nIndent % INDENT_CYCLE];
          InsertEmailColour (szPlotLine, & nIndentPos, uCol,
            os_COLOUR_WHITE);
        }

        // Check for colourings and fonts
        nPlotLen = nIndentPos + CopyFormatted (gasEdit[nEditNum].szRawEmail
          + gasEdit[nEditNum].anLine[nLine], szPlotLine + nIndentPos,
          nLineLen, uCol, os_COLOUR_WHITE);

        xwimp_set_font_colours (wimp_COLOUR_WHITE, wimp_COLOUR_BLACK);

        xfont_paint (ghEmailFont, szPlotLine,
          (font_OS_UNITS | font_GIVEN_LENGTH),
          nXPos, nYPos, NULL, NULL, nPlotLen);

        if (gboEmoticons)
        {
          PlotSmileys(ghEmailFont, szPlotLine, nXPos,
            nYPos - gnEmailTextYOffset, nPlotLen);
        }

        szCurrentPos += nLineLen;
      }

      nYPos -= gnEmailTextYOffset;

      // Invert if selected
      if ((gsSelect.boEdit) && (nEditNum == gsSelect.nEmailNum)
        && (nLine >= gsSelect.nLineStart) && (nLine <= gsSelect.nLineEnd)
        && (gsSelect.nLineStart != -1))
      {
        if (nLine == gsSelect.nLineStart)
        {
          xfont_scan_string (ghEmailFont, gasEdit[nEditNum].szRawEmail
            + gasEdit[nEditNum].anLine[nLine],
            (font_GIVEN_FONT | font_GIVEN_LENGTH),
            MILLIPOINT * gnEmailTextWidth,
            MILLIPOINT * gnEmailRowHeight, NULL, NULL, gsSelect.nCharStart,
            NULL, & nXSelStart, NULL, NULL);
          nXSelStart /= MILLIPOINT;
        }
        else
        {
          nXSelStart = 0;
        }
        if (nLine == gsSelect.nLineEnd)
        {
          xfont_scan_string (ghEmailFont, gasEdit[nEditNum].szRawEmail
            + gasEdit[nEditNum].anLine[nLine],
            (font_GIVEN_FONT | font_GIVEN_LENGTH),
            MILLIPOINT * gnEmailTextWidth,
            MILLIPOINT * gnEmailRowHeight, NULL, NULL, gsSelect.nCharEnd,
            NULL, & nXSelEnd, NULL, NULL);
          nXSelEnd /= MILLIPOINT;
        }
        else
        {
          nXSelEnd = gnEmailTextWidth;
        }
        if (nXSelStart != nXSelEnd)
        {
          xwimp_set_colour (wimp_COLOUR_BLACK);
          xos_plot (os_PLOT_POINT | os_MOVE_TO, nXPos + nXSelStart, nYPos);
          xos_plot (os_PLOT_RECTANGLE | os_PLOT_INVERSE_TO,
            nXPos + nXSelEnd - 1, nYPos + gnEmailRowHeight - 1);
        }
      }

      szCurrentPos++;
      nLine++;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Plot any smileys on screen
void PlotSmileys(font_f hFont, char *szPlotLine, int nXPos, int nYPos, int nPlotLen)
{
  char                        *szSmiley;
  int                         nSmileyXOffset;
  int                         nSmileyNum;

  nSmileyXOffset = nSmileyXOffset;
  hFont = hFont;
  nXPos = nXPos;
  nYPos = nYPos;

  nPlotLen--;
  szSmiley = strnzchr (szPlotLine, 21, nPlotLen - 1);
  while (szSmiley)
  {
    if (szSmiley[1] == 255)
    {
      nSmileyNum = (int)szSmiley[2] - 1;

      xfont_scan_string (hFont, szPlotLine,
        (font_GIVEN_FONT | font_GIVEN_LENGTH),
        MILLIPOINT * gnEmailTextWidth,
        MILLIPOINT * gnEmailRowHeight, NULL, NULL, szSmiley - szPlotLine,
        NULL, & nSmileyXOffset, NULL, NULL);
      nSmileyXOffset /= MILLIPOINT;

      osspriteop_put_sprite_scaled (osspriteop_PTR,
        gpcEmoticons,
//        (osspriteop_id)((char*)gpcEmoticons + gasSmileys[0].nOffset),
        (osspriteop_id)((char*)gpcEmoticons
        + gasSmileys[nSmileyNum].nOffset),
        nXPos + nSmileyXOffset, nYPos,
        osspriteop_USE_MASK, 0, gpsTransTable);

        szSmiley += 2;
    }
    szSmiley = strnzchr (szSmiley + 1, 21,
      nPlotLen + szPlotLine - szSmiley - 1);
  }
}

//////////////////////////////////////////////////////////////////
// Populate the Smiley structure from the Emoticons file
void PopulateSmileys (void)
{
  int                         nSpriteNum;
  osspriteop_header           *psHeader;
  int                         nHeaderOffset;
  int                         nCopy;
  int                         nCopyTo;
  char                        szName[SMILEY_NAME_LEN];
  int                         nNameLen;

  gnSmileyNum = gpcEmoticons->sprite_count;
  if (gnSmileyNum > SMILEY_MAX)
  {
    gnSmileyNum = SMILEY_MAX;
  }

  if (gnSmileyNum > 0)
  {
    nHeaderOffset = gpcEmoticons->first;
    psHeader = ((osspriteop_header*)
      ((char*)gpcEmoticons + (gpcEmoticons->first)));

    for (nSpriteNum = 0; nSpriteNum < gnSmileyNum; nSpriteNum++)
    {
      strncpy (szName, (((osspriteop_header*)
        ((char*)gpcEmoticons + nHeaderOffset))->name), SMILEY_NAME_LEN);
      szName[SMILEY_NAME_LEN - 1] = 0;
      nNameLen = strlen(szName);

      gasSmileys[nSpriteNum].nOffset = nHeaderOffset;

      nCopyTo = 0;
      for (nCopy = 0; nCopy <= nNameLen; nCopy++)
      {
        if (szName[nCopy] == 0xa0)
        {
          if ((nCopy + 1) <= nNameLen)
          {
            nCopy++;
            gasSmileys[nSpriteNum].szName[nCopyTo] = szName[nCopy] - 32;
          }
        }
        else
        {
          gasSmileys[nSpriteNum].szName[nCopyTo] = szName[nCopy];
        }
        nCopyTo++;
      }
      gasSmileys[nSpriteNum].szName[nCopyTo - 1] = 0;

      gasSmileys[nSpriteNum].nNameLength = nCopyTo - 1;

      nHeaderOffset += (((osspriteop_header*)
        ((char*)gpcEmoticons + nHeaderOffset))->size);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Returns the line and char positions of a point in an edit window
void FindEditCoords (int nEditNum, int nXPos, int nYPos, int * pnLine, int * pnChar)
{
  wimp_window_state           sWindowState;
  int                         nXWin;
  int                         nYWin;
  int                         nLine;
  char                        *szChar;
  char                        *szLineStart;

  sWindowState.w = gasEdit[nEditNum].whWindow;
  xwimp_get_window_state (& sWindowState);

  nXWin = nXPos - sWindowState.visible.x0 + sWindowState.xscroll
    - EMAIL_TEXT_X_OFFSET;
  nYWin = nYPos - sWindowState.visible.y1 + sWindowState.yscroll;

  nLine = (nYWin + gasEdit[nEditNum].nTextOffset + gnEmailTextYOffset)
    / (-gnEmailRowHeight);

  if (nLine >= gasEdit[nEditNum].nLineMax)
  {
    nLine = gasEdit[nEditNum].nLineMax - 1;
  }
  if (nLine < 0)
  {
    nLine = 0;
  }

  if (pnLine)
  {
    *pnLine = nLine;
  }

  if (pnChar)
  {
    szLineStart = gasEdit[nEditNum].szRawEmail
      + gasEdit[nEditNum].anLine[nLine];
    xfont_scan_string (ghEmailFont,
      szLineStart,
      (font_GIVEN_FONT | font_RETURN_CARET_POS),
      MILLIPOINT * nXWin,
      MILLIPOINT * gnEmailRowHeight / 2, NULL, NULL, 0,
      & szChar, NULL, NULL, NULL);

    if (szChar)
    {
      *pnChar = szChar - szLineStart;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Set caret position
void SetCaretPos (int nEditNum, int nLine, int nChar)
{
  char                        *szLineStart;
  int                         nXWin;
  int                         nYWin;
  char                        cChar;

  nYWin = ((nLine + 1) * (-gnEmailRowHeight)) - gasEdit[nEditNum].nTextOffset
    - gnEmailTextYOffset;

  szLineStart = gasEdit[nEditNum].szRawEmail
    + gasEdit[nEditNum].anLine[nLine];

  if (nChar > (gasEdit[nEditNum].anLine[nLine + 1]
    - gasEdit[nEditNum].anLine[nLine]))
  {
    nChar = (gasEdit[nEditNum].anLine[nLine + 1]
    - gasEdit[nEditNum].anLine[nLine]);
    cChar = gasEdit[nEditNum].szRawEmail[gasEdit[nEditNum].anLine[nLine]
      + nChar - 1];
    if (cChar == ' ')
    {
      nChar--;
    }
  }

  cChar = gasEdit[nEditNum].szRawEmail[gasEdit[nEditNum].anLine[nLine]
    + nChar - 1];
  if ((cChar == 0x0a) || (cChar == 0x0d))
  {
    nChar--;
  }

  if (nChar < 0)
  {
    nChar = 0;
  }

  xfont_scan_string (ghEmailFont, szLineStart,
    (font_GIVEN_FONT | font_GIVEN_LENGTH),
    MILLIPOINT * gnEmailTextWidth,
    MILLIPOINT * gnEmailRowHeight, NULL, NULL, nChar,
    NULL, & nXWin, NULL, NULL);
  nXWin /= MILLIPOINT;
  nXWin += EMAIL_TEXT_X_OFFSET;

  if ((gboCaretLost)
    || (gsCaret.whWindow != gasEdit[nEditNum].whWindow)
    || (gsCaret.nEditNum != nEditNum)
    || (gsCaret.nXPos != nXWin)
    || (gsCaret.nYPos != nYWin))
  {
    xwimp_set_caret_position (gasEdit[nEditNum].whWindow, -1, nXWin, nYWin,
      gnEmailRowHeight, 0);
    gboCaretLost = FALSE;
  }

  gsCaret.whWindow = gasEdit[nEditNum].whWindow;
  gsCaret.nEditNum = nEditNum;
  gsCaret.nLine = nLine;
  gsCaret.nChar = nChar;
  gsCaret.nPos = gasEdit[nEditNum].anLine[nLine] + nChar;
  gsCaret.nXPos = nXWin;
  gsCaret.nYPos = nYWin;

  ScrollWindowToCaret ();
}

//////////////////////////////////////////////////////////////////
// Insert a character into an edit email
void InsertChar (int nEditNum, int nPos, int nLine, char cChar)
{
  char                        *szStart;
  char                        *szEnd;
  char                        *szChar;
  int                         nAllocSuccess;

  if (gasEdit[nEditNum].boInsert)
  {
    gasEdit[nEditNum].szRawEmail[nPos] = cChar;
  }
  else
  {
    if ((gasEdit[nEditNum].nSize + 1) >= gasEdit[nEditNum].nEmailMem)
    {
      nAllocSuccess = ExtendEmailMem (nEditNum);
    }

    if (gasEdit[nEditNum].nSize < gasEdit[nEditNum].nEmailMem)
    {
      // Shift everything after the character up
      szStart = gasEdit[nEditNum].szRawEmail + nPos;
      if ((cChar == 0x0a) || (cChar == 0x0d))
      {
        if (gasEdit[nEditNum].nLineMax >=
          (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
        {
          nAllocSuccess = ExtendLineMem (nEditNum);
          szStart = gasEdit[nEditNum].szRawEmail + nPos;
        }

        if ((gasEdit[nEditNum].nLineMax <
          ((gasEdit[nEditNum].nLineMem / (int)sizeof(int)) - 1)))
        {
          ShiftLines (nEditNum, nLine, 1, 1);
          szEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize;
          for (szChar = szEnd; szChar >= szStart; szChar--)
          {
            szChar[1] = szChar[0];
          }
          szStart[0] = cChar;
          gasEdit[nEditNum].nSize++;
        }
      }
      else
      {
        ShiftLines (nEditNum, nLine, 0, 1);
        szEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize;
        for (szChar = szEnd; szChar >= szStart; szChar--)
        {
          szChar[1] = szChar[0];
        }
        szStart[0] = cChar;
        gasEdit[nEditNum].nSize++;
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Remove a character from an edit email
void DeleteChar (int nEditNum, int nPos, int nLine)
{
  char                        *szStart;
  char                        *szEnd;
  char                        *szChar;

  // Shift everything down
  if ((nPos < (gasEdit[nEditNum].nSize - 1)) && (nPos >= 0))
  {
    szStart = gasEdit[nEditNum].szRawEmail + nPos;
    if ((szStart[0] == 0x0a) || (szStart[0] == 0x0d))
    {
      ShiftLines (nEditNum, nLine, -1, -1);
    }
    else
    {
      ShiftLines (nEditNum, nLine, 0, -1);
    }

    szEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize - 1;
    for (szChar = szStart; szChar < szEnd; szChar++)
    {
      szChar[0] = szChar[1];
    }

    gasEdit[nEditNum].nSize--;
  }
}

//////////////////////////////////////////////////////////////////
// Remove a section of characters from an edit email
bool DeleteSection (int nEditNum, Selection * psSelect)
{
  char                        *szStart;
  char                        *szEnd;
  char                        *szChar;
  int                         nShift;
  bool                        boReturn = FALSE;

  if ((psSelect->boEdit)
    && (nEditNum == psSelect->nEmailNum)
    && (psSelect->nLineStart !=-1)
    && ((psSelect->nLineStart != psSelect->nLineEnd)
    || (psSelect->nCharStart != psSelect->nCharEnd)))
  {
    SelectReOrder (psSelect);

    // Shift everything down
    szEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize;

    szStart = gasEdit[nEditNum].szRawEmail
      + gasEdit[nEditNum].anLine[psSelect->nLineEnd]
      + psSelect->nCharEnd;

    if (szStart >= (szEnd - 1))
    {
      szStart = szEnd - 1;
    }

    // nShift is *negative*
    nShift = gasEdit[nEditNum].szRawEmail
      + gasEdit[nEditNum].anLine[psSelect->nLineStart]
      + psSelect->nCharStart - szStart;

    if (nShift < 0)
    {
      for (szChar = szStart; szChar < szEnd; szChar++)
      {
        szChar[nShift] = szChar[0];
      }

      gasEdit[nEditNum].nSize += nShift;

      // Preliminary reformatting
      ShiftLines (nEditNum, psSelect->nLineStart,
        psSelect->nLineStart - psSelect->nLineEnd, nShift);
    }

    SetCaretPos (nEditNum, psSelect->nLineStart, psSelect->nCharStart);
    gsCaret.nCharPref = gsCaret.nChar;

    ClearSelection ();

    boReturn = TRUE;
  }
  return boReturn;
}

//////////////////////////////////////////////////////////////////
// Update an edit window display
void UpdateEditWindow (int nEditNum, int nStartLine, int nEndLine)
{
  wimp_window_state           sWindowState;
  int                         nTopLine;
  int                         nBaseLine;
  wimp_draw                   sRedraw;
  bool                        boMore;

  sWindowState.w = gasEdit[nEditNum].whWindow;
  xwimp_get_window_state (& sWindowState);

  nTopLine = (sWindowState.yscroll + gasEdit[nEditNum].nTextOffset
    + gnEmailTextYOffset) / (-gnEmailRowHeight) - 1;

  nBaseLine = (sWindowState.yscroll - (sWindowState.visible.y1
    - sWindowState.visible.y0) + gasEdit[nEditNum].nTextOffset
    + gnEmailTextYOffset) / (-gnEmailRowHeight) + 1;

  if (nTopLine > nStartLine)
  {
    nStartLine = nTopLine;
  }
  if ((nBaseLine < nEndLine) || gasEdit[nEditNum].boLineChange)
  {
    nEndLine = nBaseLine;
    gasEdit[nEditNum].boLineChange = FALSE;
  }

  sRedraw.w = gasEdit[nEditNum].whWindow;
  sRedraw.box.x0 = EMAIL_TEXT_X_OFFSET;
  sRedraw.box.y0 = - (nEndLine * gnEmailRowHeight)
    - gasEdit[nEditNum].nTextOffset - gnEmailTextYOffset;
  sRedraw.box.x1 = EMAIL_TEXT_X_OFFSET + gnEmailTextWidth;
  sRedraw.box.y1 = - (nStartLine * gnEmailRowHeight)
    - gasEdit[nEditNum].nTextOffset - gnEmailTextYOffset;

  xwimp_update_window (& sRedraw, & boMore);

  while (boMore)
  {
    RedrawEdit ( & sRedraw, nEditNum);

    xwimp_get_rectangle (& sRedraw, & boMore);
  }
}

//////////////////////////////////////////////////////////////////
// Move the caret right the given number of characters
void MoveCaretRight (int nRight)
{
  int                         nPos;
  int                         nLine;
  int                         nChar;

  nPos = gsCaret.nPos + nRight;
  nLine = gsCaret.nLine;

  while ((nPos >= gasEdit[gsCaret.nEditNum].anLine[nLine])
    && (nLine < gasEdit[gsCaret.nEditNum].nLineMax))
  {
    nLine++;
  }

  nLine--;
  if (nLine < 0)
  {
    nLine = 0;
  }
  nChar = nPos - gasEdit[gsCaret.nEditNum].anLine[nLine];
  SetCaretPos (gsCaret.nEditNum, nLine, nChar);
  gsCaret.nCharPref = gsCaret.nChar;
}

//////////////////////////////////////////////////////////////////
// Move the caret left the given number of characters
void MoveCaretLeft (int nLeft)
{
  int                         nPos;
  int                         nLine;
  int                         nChar;

  nPos = gsCaret.nPos - nLeft;
  nLine = gsCaret.nLine;

  while ((nPos < gasEdit[gsCaret.nEditNum].anLine[nLine])
    && (nLine > 0))
  {
    nLine--;
  }

  if (nLine < 0)
  {
    nLine = 0;
  }
  nChar = nPos - gasEdit[gsCaret.nEditNum].anLine[nLine];
  SetCaretPos (gsCaret.nEditNum, nLine, nChar);
  gsCaret.nCharPref = gsCaret.nChar;
}

//////////////////////////////////////////////////////////////////
// Move the caret up the given number of rows
void MoveCaretUp (int nUp)
{
  int                         nLine;
  int                         nChar;

  nLine = gsCaret.nLine - nUp;
  nChar = gsCaret.nCharPref;

  RANGE (nLine, 0, gasEdit[gsCaret.nEditNum].nLineMax - 1);

  SetCaretPos (gsCaret.nEditNum, nLine, nChar);
}

//////////////////////////////////////////////////////////////////
// Move the caret down the given number of rows
void MoveCaretDown (int nDown)
{
  int                         nLine;
  int                         nChar;

  nLine = gsCaret.nLine + nDown;
  nChar = gsCaret.nCharPref;

  RANGE (nLine, 0, gasEdit[gsCaret.nEditNum].nLineMax - 1);

  SetCaretPos (gsCaret.nEditNum, nLine, nChar);
}

//////////////////////////////////////////////////////////////////
// Update the selection if the caret moves with shift held down
void ShiftSelection (Caret * psCaretPre, Caret * psCaret)
{
  Selection                   sSelect;

  if ((gsSelect.boEdit
    && (gsSelect.nEmailNum == psCaretPre->nEditNum)
    && (gsSelect.nLineEnd == psCaretPre->nLine)
    && (gsSelect.nCharEnd == psCaretPre->nChar)))
  {
    sSelect = gsSelect;
    sSelect.nLineEnd = psCaret->nLine;
    sSelect.nCharEnd = psCaret->nChar;
    ChangeSelection (& sSelect);
  }
  else
  {
    if ((gsSelect.boEdit
      && (gsSelect.nEmailNum == psCaretPre->nEditNum)
      && (gsSelect.nLineStart == psCaretPre->nLine)
      && (gsSelect.nCharStart == psCaretPre->nChar)))
    {
      sSelect = gsSelect;
      sSelect.nLineStart = psCaret->nLine;
      sSelect.nCharStart = psCaret->nChar;
      ChangeSelection (& sSelect);
    }
    else
    {
      sSelect.boEdit = TRUE;
      sSelect.nEmailNum = psCaretPre->nEditNum;
      sSelect.whWindow = psCaretPre->whWindow;
      sSelect.nLineStart = psCaretPre->nLine;
      sSelect.nCharStart = psCaretPre->nChar;
      sSelect.nLineEnd = psCaret->nLine;
      sSelect.nCharEnd = psCaret->nChar;
      ChangeSelection (& sSelect);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Move right to the next occurence of one of the szSearch characters
void SearchCaretRight (char * szSearch)
{
  int                         nPos;
  int                         nSize;
  char                        *szRawEmail;

  szRawEmail = gasEdit[gsCaret.nEditNum].szRawEmail;
  nPos = gsCaret.nPos + 1;
  nSize = gasEdit[gsCaret.nEditNum].nSize;

  while ((nPos < nSize) && (strchr(szSearch, szRawEmail[nPos]) == NULL))
  {
    nPos++;
  }

  MoveCaretRight (nPos - gsCaret.nPos);
}

//////////////////////////////////////////////////////////////////
// Move right to the next occurence of one of the szSearch characters
void SearchCaretLeft (char * szSearch)
{
  int                         nPos;
  char                        *szRawEmail;

  szRawEmail = gasEdit[gsCaret.nEditNum].szRawEmail;
  nPos = gsCaret.nPos - 2;

  while ((nPos > 0) && (strchr(szSearch, szRawEmail[nPos]) == NULL))
  {
    nPos--;
  }

  if (nPos > 0)
  {
    MoveCaretLeft (gsCaret.nPos - nPos - 1);
  }
}

//////////////////////////////////////////////////////////////////
// Insert a string into an edit email
void InsertString (int nEditNum, int nPos, int nLine, char * szString)
{
  char                        *szStart;
  char                        *szEnd;
  char                        *szChar;
  int                         nCount;
  int                         nLength;
  int                         nLinesAdded;
  int                         nAllocSuccess;

  nLength = strlen (szString);

  if (gasEdit[nEditNum].boInsert)
  {
    memcpy (gasEdit[nEditNum].szRawEmail + nPos, szString, nLength);
  }
  else
  {
    if ((gasEdit[nEditNum].nSize + nLength) >= gasEdit[nEditNum].nEmailMem)
    {
      nAllocSuccess = ExtendEmailMemTo (nEditNum,
        gasEdit[nEditNum].nSize + nLength);
    }

    if ((gasEdit[nEditNum].nSize + nLength) < gasEdit[nEditNum].nEmailMem)
    {
      nLinesAdded = 0;
      for (nCount = 0; nCount < nLength; nCount++)
      {
        if ((szString[nCount] == 0x0a) || (szString[nCount] == 0x0d))
        {
          nLinesAdded++;
        }
      }

      if ((gasEdit[nEditNum].nLineMax + nLinesAdded)
        >= (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
      {
        nAllocSuccess = ExtendLineMemTo (nEditNum,
          (gasEdit[nEditNum].nLineMax + nLinesAdded) * sizeof(int));
      }

      if ((gasEdit[nEditNum].nLineMax + nLinesAdded)
        < (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
      {
        // Shift everything after the string up
        szStart = gasEdit[nEditNum].szRawEmail + nPos;
        szEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize;
        for (szChar = szEnd; szChar >= szStart; szChar--)
        {
          szChar[nLength] = szChar[0];
        }

        memcpy (szStart, szString, nLength);
        gasEdit[nEditNum].nSize += nLength;

        ShiftLines (nEditNum, nLine, nLinesAdded, nLength);
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Insert a chunk of flex memory into an edit email
void InsertTextFlex (int nEditNum, int nPos, int nLine, char * * pszString, int nLength)
{
  char                        *szStart;
  char                        *szEnd;
  char                        *szChar;
  int                         nCount;
  int                         nLinesAdded;
  int                         nAllocSuccess;

  if (gasEdit[nEditNum].boInsert)
  {
    if ((nPos + nLength) >= gasEdit[nEditNum].nEmailMem)
    {
      nAllocSuccess = ExtendEmailMemTo (nEditNum, (nPos + nLength));
    }

    if ((nPos + nLength) < gasEdit[nEditNum].nEmailMem)
    {
      szStart = gasEdit[nEditNum].szRawEmail + nPos;
      memcpy (szStart, * pszString, nLength);

      // Sanitize the copied text
      for (nCount = 0; nCount < nLength; nCount++)
      {
        if ((szStart[nCount] < 0x20) && (szStart[nCount] != 0x0a)
          && (szStart[nCount] != 0x0d))
        {
          szStart[nCount] = 0x20;
        }
      }
    }
  }
  else
  {
    if ((gasEdit[nEditNum].nSize + nLength) >= gasEdit[nEditNum].nEmailMem)
    {
      nAllocSuccess = ExtendEmailMemTo (nEditNum,
        (gasEdit[nEditNum].nSize + nLength));
    }

    if ((gasEdit[nEditNum].nSize + nLength) < gasEdit[nEditNum].nEmailMem)
    {
      nLinesAdded = 0;
      for (nCount = 0; nCount < nLength; nCount++)
      {
        if (((* pszString)[nCount] == 0x0a)
          || ((* pszString)[nCount] == 0x0d))
        {
          nLinesAdded++;
        }
      }

      if ((gasEdit[nEditNum].nLineMax + nLinesAdded)
        >= (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
      {
        nAllocSuccess = ExtendLineMemTo (nEditNum,
          ((gasEdit[nEditNum].nLineMax + nLinesAdded) * sizeof(int)));
      }

      if ((gasEdit[nEditNum].nLineMax + nLinesAdded)
        < (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
      {
        // Shift everything after the string up
        szStart = gasEdit[nEditNum].szRawEmail + nPos;
        szEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize;
        for (szChar = szEnd; szChar >= szStart; szChar--)
        {
          szChar[nLength] = szChar[0];
        }

        memcpy (szStart, * pszString, nLength);
        gasEdit[nEditNum].nSize += nLength;

        // Sanitize the copied text
        for (nCount = 0; nCount < nLength; nCount++)
        {
          if ((szStart[nCount] < 0x20) && (szStart[nCount] != 0x0a)
            && (szStart[nCount] != 0x0d))
          {
            szStart[nCount] = 0x20;
          }
        }

        ShiftLines (nEditNum, nLine, nLinesAdded, nLength);
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Insert a chunk of memory into an edit email
void InsertText (int nEditNum, int nPos, int nLine, char * szString, int nLength)
{
  char                        *szStart;
  char                        *szEnd;
  char                        *szChar;
  int                         nCount;
  int                         nLinesAdded;
  int                         nAllocSuccess;

  if (gasEdit[nEditNum].boInsert)
  {
    if ((nPos + nLength) >= gasEdit[nEditNum].nEmailMem)
    {
      nAllocSuccess = ExtendEmailMemTo (nEditNum, (nPos + nLength));
    }

    if ((nPos + nLength) < gasEdit[nEditNum].nEmailMem)
    {
      szStart = gasEdit[nEditNum].szRawEmail + nPos;
      memcpy (szStart, szString, nLength);

      // Sanitize the copied text
      for (nCount = 0; nCount < nLength; nCount++)
      {
        if ((szStart[nCount] < 0x20) && (szStart[nCount] != 0x0a)
          && (szStart[nCount] != 0x0d))
        {
          szStart[nCount] = 0x20;
        }
      }
    }
  }
  else
  {
    if ((gasEdit[nEditNum].nSize + nLength) >= gasEdit[nEditNum].nEmailMem)
    {
      nAllocSuccess = ExtendEmailMemTo (nEditNum,
        (gasEdit[nEditNum].nSize + nLength));
    }

    if ((gasEdit[nEditNum].nSize + nLength) < gasEdit[nEditNum].nEmailMem)
    {
      nLinesAdded = 0;
      for (nCount = 0; nCount < nLength; nCount++)
      {
        if ((szString[nCount] == 0x0a) || (szString[nCount] == 0x0d))
        {
          nLinesAdded++;
        }
      }

      if ((gasEdit[nEditNum].nLineMax + nLinesAdded)
        >= (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
      {
        nAllocSuccess = ExtendLineMemTo (nEditNum,
          ((gasEdit[nEditNum].nLineMax + nLinesAdded) * sizeof(int)));
      }

      if ((gasEdit[nEditNum].nLineMax + nLinesAdded)
        < (gasEdit[nEditNum].nLineMem / (int)sizeof(int)))
      {
        // Shift everything after the string up
        szStart = gasEdit[nEditNum].szRawEmail + nPos;
        szEnd = gasEdit[nEditNum].szRawEmail + gasEdit[nEditNum].nSize;
        for (szChar = szEnd; szChar >= szStart; szChar--)
        {
          szChar[nLength] = szChar[0];
        }

        memcpy (szStart, szString, nLength);
        gasEdit[nEditNum].nSize += nLength;

        // Sanitize the copied text
        for (nCount = 0; nCount < nLength; nCount++)
        {
          if ((szStart[nCount] < 0x20) && (szStart[nCount] != 0x0a)
            && (szStart[nCount] != 0x0d))
          {
            szStart[nCount] = 0x20;
          }
        }

        ShiftLines (nEditNum, nLine, nLinesAdded, nLength);
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Do a rough reformatting of the line starts
void ShiftLines (int nEditNum, int nLineStart, int nLine, int nChar)
{
  int                         nCount;
  int                         nEnd;


  if (nLine != 0)
  {
    gasEdit[nEditNum].boLineChange = TRUE;
  }

  if (nChar < 0)
  {
    nEnd = gasEdit[nEditNum].nLineMax + nLine;
    for (nCount = nLineStart + 1; nCount <= nEnd; nCount++)
    {
      gasEdit[nEditNum].anLine[nCount]
        = gasEdit[nEditNum].anLine[nCount - nLine] + nChar;
    }
    gasEdit[nEditNum].nLineMax += nLine;
  }
  else
  {
    nEnd = gasEdit[nEditNum].nLineMax;
    for (nCount = nEnd; nCount > nLineStart; nCount--)
    {
      gasEdit[nEditNum].anLine[nCount + nLine]
        = gasEdit[nEditNum].anLine[nCount] + nChar;
    }
    for (nCount = nLineStart + 1; nCount <= nLineStart + nLine; nCount++)
    {
      gasEdit[nEditNum].anLine[nCount]
        = gasEdit[nEditNum].anLine[nLineStart];
    }
    gasEdit[nEditNum].nLineMax += nLine;
    if (nLine > 0)
    {
      gasEdit[nEditNum].nFormattedTo = nLineStart;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Caret has moved out of a window
void LoseCaret (wimp_block *pcBlock)
{
  pcBlock = pcBlock;
  gboCaretLost = TRUE;
}

//////////////////////////////////////////////////////////////////
// Clear the caret structure
void ClearCaret (void)
{
  gsCaret.whWindow = wimp_BACKGROUND;
  gsCaret.nEditNum = EDIT_INVALID;
  gsCaret.nLine = -1;
  gsCaret.nChar = -1;
  gsCaret.nPos = -1;
  gsCaret.nXPos = -1;
  gsCaret.nYPos = -1;
}

//////////////////////////////////////////////////////////////////
// Create a copy space from an edit window selection
void CreateEditSelect (int nEditNum, bool boEdit, char ** ppcMem, int * pnSize)
{
  int                         nStart;
  int                         nEnd;
  int                         nNonControl;
  int                         nAllocSuccess;
  int                         nSize;

  if ((gsSelect.nLineStart != -1) && (gsSelect.nEmailNum != EMAIL_INVALID)
    && (gsSelect.whWindow != wimp_BACKGROUND))
  {
    if (gsSelect.boEdit)
    {
      // Check that the selection is in the current window
      if ((nEditNum == gsSelect.nEmailNum) && (boEdit))
      {
        // Calculate the size
        nStart = gasEdit[nEditNum].anLine[gsSelect.nLineStart]
          + gsSelect.nCharStart;
        nEnd = gasEdit[nEditNum].anLine[gsSelect.nLineEnd]
          + gsSelect.nCharEnd;

        nSize = nEnd - nStart;
        if (nSize < SELECT_MEM_MIN)
        {
          nSize = SELECT_MEM_MIN;
        }

        if (*ppcMem != NULL)
        {
          nAllocSuccess = flex_extend ((flex_ptr)(ppcMem), nSize);
        }
        else
        {
          nAllocSuccess = flex_alloc ((flex_ptr)(ppcMem), nSize);
        }

        if ((nAllocSuccess) && (*ppcMem))
        {
          // Copy the text
          *pnSize = nEnd - nStart;
          memcpy (*ppcMem, gasEdit[nEditNum].szRawEmail
            + nStart, (nEnd - nStart));
        }
        else
        {
          ShowWarningTag ("Er2");
        }
      }
    }
    else
    {
      // Check that the selection is in the current window
      if ((nEditNum == gsSelect.nEmailNum) && (!boEdit))
      {
        // Calculate the size
        nNonControl = CountNonControl (gasDetails[nEditNum].szFormEmail
          + gasDetails[nEditNum].anLine[gsSelect.nLineStart],
          gsSelect.nCharStart);
        nStart = gasDetails[nEditNum].anRawLine[gsSelect.nLineStart]
          + nNonControl;

        nNonControl = CountNonControl (gasDetails[nEditNum].szFormEmail
          + gasDetails[nEditNum].anLine[gsSelect.nLineEnd],
          gsSelect.nCharEnd);
        nEnd = gasDetails[nEditNum].anRawLine[gsSelect.nLineEnd]
          + nNonControl;

        nSize = nEnd - nStart;
        if (nSize < SELECT_MEM_MIN)
        {
          nSize = SELECT_MEM_MIN;
        }

        if (*ppcMem != NULL)
        {
          nAllocSuccess = flex_extend ((flex_ptr)(ppcMem), nSize);
        }
        else
        {
          nAllocSuccess = flex_alloc ((flex_ptr)(ppcMem), nSize);
        }

        if ((nAllocSuccess) && (*ppcMem))
        {
          // Copy the text
          *pnSize = nEnd - nStart;
          memcpy (*ppcMem, gasDetails[nEditNum].szRawEmail
            + nStart, (nEnd - nStart));
        }
        else
        {
          ShowWarningTag ("Er2");
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Count the number of non control characters in a string
int CountNonControl (char * szString, int nLength)
{
  int                         nCount;
  int                         nReturn;

  nReturn = 0;
  for (nCount = 0; nCount < nLength; nCount++)
  {
    switch (szString[nCount])
    {
      case 19:
        nCount += 7;
        break;
      case 21:
        nCount += 1;
        break;
      case 25:
        nCount += 2;
        break;
      case 26:
        nCount += 1;
        break;
      default:
        nReturn++;
        break;
    }
  }
  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Clear the current selection
void ClearSelection (void)
{
  Selection                   sSelect;

  if (gsSelect.nLineStart != -1)
  {
    sSelect.nLineStart = -1;
    sSelect.whWindow = wimp_BACKGROUND;
    sSelect.nEmailNum = EMAIL_INVALID;
    ChangeSelection (& sSelect);
  }
}

//////////////////////////////////////////////////////////////////
// Resize the edit window to fit the given number of lines
void SetEditHeight (int nEditNum, int nLine)
{
  os_box                sExtent;
  wimp_window_state     sWindow;

  if (gasEdit[nEditNum].whWindow != wimp_BACKGROUND)
  {
    if (nLine < EDIT_WIN_LINE_MIN)
    {
      nLine = EDIT_WIN_LINE_MIN;
    }

    sWindow.w = gasEdit[nEditNum].whWindow;
    xwimp_get_window_state (& sWindow);

    sExtent.x0 = 0;
    sExtent.x1 = gnEmailTextWidth + (2 * EMAIL_TEXT_X_OFFSET);

    sExtent.y0 = - ((nLine + 1)
      * gnEmailRowHeight) - gasEdit[nEditNum].nTextOffset;
    sExtent.y1 = 0;

    if (sExtent.y0 > (sWindow.visible.y0 - sWindow.visible.y1))
    {
      sExtent.y0 = (sWindow.visible.y0 - sWindow.visible.y1);
    }

    xwimp_set_extent (gasEdit[nEditNum].whWindow, & sExtent);
  }
}

//////////////////////////////////////////////////////////////////
// Copy the current selection to the clipboard
void CopySelectToClip (void)
{
  wimp_message                sMessage;

  CreateEditSelect (gsSelect.nEmailNum, gsSelect.boEdit, & gpcClipboard,
    & gnClipboardSize);
  if (gpcClipboard)
  {
    sMessage.size = 24;
    sMessage.your_ref = 0;
    sMessage.action = message_CLAIM_ENTITY;
    sMessage.data.claim_entity.flags = wimp_CLAIM_CLIPBOARD;
    xwimp_send_message (wimp_USER_MESSAGE_RECORDED, & sMessage,
      wimp_BROADCAST);
    gboClipClaimed = TRUE;
  }
}

//////////////////////////////////////////////////////////////////
// Clears the clipboard
void ClearClipboard (void)
{
  int                         nAllocSuccess;

  if (gboClipClaimed)
  {
    gboClipClaimed = FALSE;
    if (gpcClipboard)
    {
      nAllocSuccess = flex_extend ((flex_ptr)(& gpcClipboard),
        SELECT_MEM_MIN);
    }
    else
    {
      nAllocSuccess = flex_alloc ((flex_ptr)(& gpcClipboard),
        SELECT_MEM_MIN);
    }

    gnClipboardSize = 0;
  }
}

//////////////////////////////////////////////////////////////////
// Send the clipboard to te requesting application
void DataRequest (wimp_block * pcBlock)
{
  if ((gboClipClaimed) && ((pcBlock->message.data.data_request.flags
    & wimp_DATA_REQUEST_CLIPBOARD) == wimp_DATA_REQUEST_CLIPBOARD))
  {
    strncpy (pcBlock->message.data.data_xfer.file_name,
      Tag ("SaveSel"), 211);
    pcBlock->message.data.data_xfer.file_name[211] = 0;
    pcBlock->message.data.data_xfer.est_size = gnClipboardSize;
    pcBlock->message.data.data_xfer.file_type = 0xfff;
    pcBlock->message.size = WORDALIGN((44 + 1 + 9));
    pcBlock->message.your_ref = pcBlock->message.my_ref;
    pcBlock->message.action = message_DATA_SAVE;

    xwimp_send_message (wimp_USER_MESSAGE, & pcBlock->message,
      pcBlock->message.sender);

    geSaveType = SAVETYPE_CLIPBOARD;
  }
}

//////////////////////////////////////////////////////////////////
// Clear the clipboard unless the message was sent by us
void ClaimEntity (wimp_block * pcBlock)
{
  if (pcBlock->message.sender != gnTaskHandle)
  {
    ClearClipboard ();
  }
}

//////////////////////////////////////////////////////////////////
// Paste the ontents of the clipboard
void PasteClipboard (void)
{
  wimp_message                sMessage;
  wimp_window_state           sWindowState;

  sWindowState.w = gsCaret.whWindow;
  xwimp_get_window_state (& sWindowState);

  sMessage.size = 48;
  sMessage.your_ref = 0;
  sMessage.action = message_DATA_REQUEST;
  sMessage.data.data_request.w = gsCaret.whWindow;
  sMessage.data.data_request.i = -1;
  sMessage.data.data_request.pos.x = gsCaret.nXPos + sWindowState.visible.x0
    - sWindowState.xscroll;
  sMessage.data.data_request.pos.y = gsCaret.nYPos + sWindowState.visible.y1
    - sWindowState.yscroll + gnEmailRowHeight;
  sMessage.data.data_request.file_types[0] = 0xfff;
  sMessage.data.data_request.file_types[1] = -1;
  sMessage.data.data_request.flags = wimp_DATA_REQUEST_CLIPBOARD;
  xwimp_send_message (wimp_USER_MESSAGE, & sMessage,
    wimp_BROADCAST);
  geSaveType = SAVETYPE_CLIPBOARD;
}

//////////////////////////////////////////////////////////////////
// Scroll the window if the caret is not visible
void ScrollWindowToCaret (void)
{
  wimp_window_state           sWindowState;
  int                         nWidth;
  int                         nHeight;

  if (gsCaret.whWindow != wimp_BACKGROUND)
  {
    sWindowState.w = gsCaret.whWindow;
    xwimp_get_window_state (& sWindowState);

    nWidth = sWindowState.visible.x1 - sWindowState.visible.x0;
    nHeight = sWindowState.visible.y1 - sWindowState.visible.y0;

    if (gsCaret.nXPos < sWindowState.xscroll)
    {
      sWindowState.xscroll = gsCaret.nXPos - EMAIL_TEXT_X_SCROLL;
      xwimp_open_window ((wimp_open*)(& sWindowState));
    }
    if (gsCaret.nXPos > (sWindowState.xscroll + nWidth))
    {
      sWindowState.xscroll = gsCaret.nXPos - nWidth + EMAIL_TEXT_X_SCROLL;
      xwimp_open_window ((wimp_open*)(& sWindowState));
    }
    if ((gsCaret.nYPos + gnEmailRowHeight)
      > (sWindowState.yscroll - gasEdit[gsCaret.nEditNum].nTextOffset))
    {
      sWindowState.yscroll = gsCaret.nYPos + (3 * gnEmailRowHeight)
        + gasEdit[gsCaret.nEditNum].nTextOffset;
      xwimp_open_window ((wimp_open*)(& sWindowState));
    }
    if (gsCaret.nYPos < (sWindowState.yscroll - nHeight))
    {
      sWindowState.yscroll = gsCaret.nYPos + nHeight
        - (2 * gnEmailRowHeight);
      xwimp_open_window ((wimp_open*)(& sWindowState));
    }
  }
}

//////////////////////////////////////////////////////////////////
// Activate or deactive the null poll
void SetNullPollActive (NULLPOLL ePollState)
{
  if (ePollState == NULLPOLL_ACTIVE_FAST)
  {
    gnFastPollAcc++;
    xos_read_monotonic_time (& gnMonotonicTime);
  }
  if (ePollState == NULLPOLL_DEACTIVE_FAST)
  {
    gnFastPollAcc--;
  }
  if (ePollState == NULLPOLL_ACTIVE_SLOW)
  {
    gnSlowPollAcc++;
    xos_read_monotonic_time (& gnMonotonicTime);
  }
  if (ePollState == NULLPOLL_DEACTIVE_SLOW)
  {
    gnSlowPollAcc--;
  }

  if (ePollState == NULLPOLL_ACTIVE_NETWORK)
  {
    gboNetworkPoll = TRUE;
  }

  if (ePollState == NULLPOLL_DEACTIVE_NETWORK)
  {
    gboNetworkPoll = FALSE;
  }

  if (gnFastPollAcc > 0)
  {
    gnTimeInc = NULL_POLL_FAST;
  }
  else
  {
    gnTimeInc = NULL_POLL_SLOW;
  }

  if ((gnFastPollAcc == 0) && (gnSlowPollAcc == 0))
  {
    gnTimeInc = NULL_POLL_SLOWEST;
  }

  if (gboNetworkPoll)
  {
#if defined MAX_SEND_LEN
    gnTimeInc = gnNullPollNetwork;
#else
    gnTimeInc = NULL_POLL_NETWORK;
#endif
  }

//  if ((gnFastPollAcc == 0) && (gnSlowPollAcc == 0))
//  {
//    guPollFlags |= wimp_MASK_NULL;
//  }
//  else
//  {
//    guPollFlags &= ~wimp_MASK_NULL;
//  }
}

//////////////////////////////////////////////////////////////////
// Pointer has entered a window
void PointerEntering (wimp_block * pcBlock)
{
  int                         nEmailSearch;
  bool                        boWinFound;
  wimp_w                      whWindow;

  boWinFound = FALSE;
  gboPointerEdit = FALSE;
  gnPointerEmail = EMAIL_INVALID;
  whWindow = pcBlock->entering.w;

  // Check for all of the email windows
  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEmailsOpen[nEmailSearch])
    {
      gnPointerEmail = ganEmailsOpen[nEmailSearch];
      gboPointerEdit = FALSE;
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }

  // Check for all of the edit windows
  nEmailSearch = 0;
  while ((!boWinFound) && (gawhEditOpen[nEmailSearch] != wimp_BACKGROUND))
  {
    if (whWindow == gawhEditOpen[nEmailSearch])
    {
      gnPointerEmail = ganEditOpen[nEmailSearch];
      gboPointerEdit = TRUE;
      boWinFound = TRUE;
    }
    nEmailSearch++;
  }

  if (gnPointerEmail != EMAIL_INVALID)
  {
    SetNullPollActive (NULLPOLL_ACTIVE_SLOW);
  }
}

//////////////////////////////////////////////////////////////////
// Pointer has left a window
void PointerLeaving (wimp_block * pcBlock)
{
  pcBlock = pcBlock;
  if (gnPointerEmail != EMAIL_INVALID)
  {
    SetNullPollActive (NULLPOLL_DEACTIVE_SLOW);
  }
  gboPointerEdit = FALSE;
  gnPointerEmail = EMAIL_INVALID;

  if (gboLinkPointer)
  {
    // Remove hand pointer
    gboLinkPointer = FALSE;
    xwimpspriteop_set_pointer_shape ("ptr_default", 97, 0, 0, NULL, NULL);
  }

  if (gboColumnPointer)
  {
    // Remove column pointer
    gboColumnPointer = FALSE;
    xwimpspriteop_set_pointer_shape ("ptr_default", 97, 0, 0, NULL, NULL);
  }
}

//////////////////////////////////////////////////////////////////
// Return the word at the given co-ordinates
void FindWordAtCoords (bool boEdit, int nEmailNum, int nXPos, int nYPos, char ** pszWordStart, char ** pszWordEnd)
{
  wimp_window_state           sWindowState;
  int                         nXWin;
  int                         nYWin;
  int                         nLine;
  char                        *szChar;
  char                        *szLineStart = NULL;
  char                        *szLineEnd = NULL;
  char                        *szWordStart;
  char                        *szWordEnd;

  szWordStart = NULL;
  szWordEnd = NULL;
  szChar = NULL;

  if (boEdit)
  {
    sWindowState.w = gasEdit[nEmailNum].whWindow;
    xwimp_get_window_state (& sWindowState);

    nXWin = nXPos - sWindowState.visible.x0 + sWindowState.xscroll
      - EMAIL_TEXT_X_OFFSET;
    nYWin = nYPos - sWindowState.visible.y1 + sWindowState.yscroll;

    nLine = (nYWin + gasEdit[nEmailNum].nTextOffset + gnEmailTextYOffset)
      / (-gnEmailRowHeight);

    if ((nLine >= 0) && (nLine < gasEdit[nEmailNum].nLineMax))
    {
      szLineStart = gasEdit[nEmailNum].szRawEmail
        + gasEdit[nEmailNum].anLine[nLine];
      szLineEnd = gasEdit[nEmailNum].szRawEmail
        + gasEdit[nEmailNum].anLine[nLine + 1];
      xfont_scan_string (ghEmailFont,
        szLineStart,
        (font_GIVEN_FONT | font_RETURN_CARET_POS),
        MILLIPOINT * nXWin,
        MILLIPOINT * gnEmailRowHeight / 2, NULL, NULL, 0,
        & szChar, NULL, NULL, NULL);
    }
  }
  else
  {
    sWindowState.w = gasDetails[nEmailNum].whWindow;
    xwimp_get_window_state (& sWindowState);

    nXWin = nXPos - sWindowState.visible.x0 + sWindowState.xscroll
      - EMAIL_TEXT_X_OFFSET;
    nYWin = nYPos - sWindowState.visible.y1 + sWindowState.yscroll;

    nLine = (nYWin + EMAIL_TEXT_Y_OFFSET + gnEmailTextYOffset)
      / (-gnEmailRowHeight);

    nLine += gasDetails[nEmailNum].nLineHide;

    if ((nLine >= gasDetails[nEmailNum].nLineHide)
      && (nLine < gasDetails[nEmailNum].nLineMax))
    {
      szLineStart = gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nLine];
      szLineEnd = gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nLine + 1];
      xfont_scan_string (ghEmailFont,
        szLineStart,
        (font_GIVEN_FONT | font_RETURN_CARET_POS),
        MILLIPOINT * nXWin,
        MILLIPOINT * gnEmailRowHeight / 2, NULL, NULL, 0,
        & szChar, NULL, NULL, NULL);
    }
  }

  if (szChar)
  {
    // Find the word around this point
    szWordStart = szChar;
    szWordEnd = szWordStart;
    while ((szWordStart[0] > 32) && (szWordStart >= szLineStart))
    {
      szWordStart--;
    }
    szWordStart++;
    while ((szWordEnd[0] > 32) && (szWordEnd <= szLineEnd))
    {
      szWordEnd++;
    }
    szWordEnd--;
    if (szWordStart >= szWordEnd)
    {
      szWordStart = NULL;
      szWordEnd = NULL;
    }
  }

  if (pszWordStart)
  {
    *pszWordStart = szWordStart;
  }
  if (pszWordEnd)
  {
    *pszWordEnd = szWordEnd;
  }
}

//////////////////////////////////////////////////////////////////
// Check if the word at the given memory position is a smiley
int WordIsSmiley (char * szWordStart, char * szWordEnd)
{
  int                         nSmiley;
  int                         nLength;
  int                         nReturn;

  nReturn = 0;

  nLength = szWordEnd - szWordStart + 1;

  for (nSmiley = 0; (nSmiley < gnSmileyNum) && (nReturn == 0); nSmiley++)
  {
    if (nLength == gasSmileys[nSmiley].nNameLength)
    {
      if (strncmp (szWordStart, gasSmileys[nSmiley].szName, nLength) == 0)
      {
        nReturn = nSmiley + 1;
      }
    }
  }

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Check if the word at the given memory position is a link
bool WordIsLink (char * szWordStart, char * szWordEnd)
{
  bool                        boLink;
  char                        *szFind;
  int                         nLength;

  boLink = FALSE;

  if ((szWordStart[0] == '<') && (szWordEnd[0] == '>'))
  {
    szWordStart++;
    szWordEnd--;
  }

  nLength = szWordEnd - szWordStart + 1;

  if ((nLength >= 7) && (strncmp (szWordStart, "http://", 7) == 0))
  {
    boLink = TRUE;
  }
  if ((nLength >= 4) && (strncmp (szWordStart, "www.", 4) == 0))
  {
    boLink = TRUE;
  }
  if ((nLength >= 7) && (strncmp (szWordStart, "mailto:", 7) == 0))
  {
    boLink = TRUE;
  }
  if ((nLength >= 8) && (strncmp (szWordStart, "https://", 8) == 0))
  {
    boLink = TRUE;
  }
  if ((nLength >= 4) && (strncmp (szWordStart, "URL:", 4) == 0))
  {
    boLink = TRUE;
  }

  szFind = (char *)memchr (szWordStart, '@',
    szWordEnd - szWordStart + 1);

  if (szFind && (memchr (szFind, '.', szWordEnd - szFind + 1)))
  {
    boLink = TRUE;
  }

  return boLink;
}

//////////////////////////////////////////////////////////////////
// A double click occured on a window to launch a URL
void ClickOnURL (bool boEdit, int nEmailNum, int nXPos, int nYPos)
{
  char                        *szWordStart;
  char                        *szWordEnd;
  bool                        boLink;
  char                        szURL[1024];
  char                        szURLmail[1024+8];
  int                         nLength;
  bool                        boURLprefix;

  FindWordAtCoords (boEdit, nEmailNum, nXPos, nYPos,
    & szWordStart, & szWordEnd);

  boLink = FALSE;
  if (szWordStart)
  {
    boLink = WordIsLink (szWordStart, szWordEnd);
  }
  if (boLink)
  {
    if ((szWordStart[0] == '<') && (szWordEnd[0] == '>'))
    {
      szWordStart++;
      szWordEnd--;
    }
    nLength = MIN(((int)sizeof(szURL) - 8), (szWordEnd - szWordStart + 1));

    if ((nLength >= 4) && (strncmp (szWordStart, "URL:", 4) == 0))
    {
      nLength -= 4;
      strncpy (szURL, szWordStart + 4, nLength);
      boURLprefix = TRUE;
    }
    else
    {
      strncpy (szURL, szWordStart, nLength);
      boURLprefix = FALSE;
    }
    szURL[nLength] = 0;
    if ((strncmp (szURL, "http://", 7) == 0)
      || (strncmp (szURL, "www.", 4) == 0)
      || (strncmp (szURL, "mailto:", 7) == 0)
      || (strncmp (szURL, "https://", 8) == 0)
      | (boURLprefix))
    {
      OpenURL (szURL);
    }
    else
    {
      sprintf (szURLmail, "mailto:%s", szURL);
      OpenURL (szURLmail);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Show or hide the email header
void ShowHeader (int nEmailNum, bool boShow)
{
  wimp_window_state           sWindowState;
  wimp_draw                   sRedraw;
  bool                        boMore;

  if (boShow)
  {
    gasDetails[nEmailNum].nLineHide = 0;
  }
  else
  {
    gasDetails[nEmailNum].nLineHide = gasDetails[nEmailNum].nHeaderEndLine;
  }

  SetIconSelectionState (boShow, gasDetails[nEmailNum].whHead, (wimp_i)9);

  // Redraw the entire window
  sWindowState.w = gasDetails[nEmailNum].whWindow;
  xwimp_get_window_state (& sWindowState);

  sRedraw.w = gasDetails[nEmailNum].whWindow;
  sRedraw.box.x0 = sWindowState.xscroll;
  sRedraw.box.x1 = sWindowState.visible.x1 - sWindowState.visible.x0
    + sWindowState.xscroll;
  sRedraw.box.y0 = sWindowState.visible.y0 - sWindowState.visible.y1
    + sWindowState.yscroll;
  sRedraw.box.y1 = sWindowState.yscroll;
  xwimp_update_window (& sRedraw, & boMore);

  while (boMore)
  {
    RedrawEmail (& sRedraw, nEmailNum);
    xwimp_get_rectangle (& sRedraw, & boMore);
  }
}

//////////////////////////////////////////////////////////////////
// Show or hide the advanced edit options
void ShowAdvanced (int nEditNum, bool boShow)
{
  wimp_window_state           sWindowState;
  wimp_draw                   sRedraw;
  bool                        boMore;
  wimp_window_info            sWindowInfo;
  wimp_caret                  sCaret;

  gasEdit[nEditNum].boAdvanced = boShow;

  SetIconSelectionState (boShow, gasEdit[nEditNum].whHead, (wimp_i)14);

  // Change the header extent
  sWindowInfo.w = gasEdit[nEditNum].whHead;
  xwimp_get_window_info_header_only (& sWindowInfo);

  if (boShow)
  {
    gasEdit[nEditNum].nTextOffset = EDIT_TEXT_Y_OFFSET_MAX;
    sWindowInfo.extent.y0 = - EDIT_HEAD_EXTENT_MAX;
  }
  else
  {
    gasEdit[nEditNum].nTextOffset = EDIT_TEXT_Y_OFFSET_MIN;
    sWindowInfo.extent.y0 = - EDIT_HEAD_EXTENT_MIN;
  }
  xwimp_set_extent (sWindowInfo.w, & sWindowInfo.extent);

  // Open the pane in the correct place
  sWindowState.w = gasEdit[nEditNum].whWindow;
  xwimp_get_window_state (& sWindowState);
  sWindowState.w = gasEdit[nEditNum].whHead;
  xwimp_open_window ((wimp_open *)& sWindowState);

  // Set icon greyness
  xwimp_get_caret_position (& sCaret);
  if (!boShow)
  {
    if ((sCaret.w == gasEdit[nEditNum].whHead)
      && ((sCaret.i == (wimp_i)9) || (sCaret.i == (wimp_i)12)))
    {
      xwimp_set_caret_position (gasEdit[nEditNum].whHead, (wimp_i)1, 0, 0,
        -1, -1);
    }
  }

  SetIconGreyness (!boShow, gasEdit[nEditNum].whHead, (wimp_i)9);
  SetIconGreyness (!boShow, gasEdit[nEditNum].whHead, (wimp_i)12);

  // Move the caret if necessary
  if (sCaret.w == gasEdit[nEditNum].whWindow)
  {
    SetCaretPos (nEditNum, gsCaret.nLine, gsCaret.nChar);
  }

  // Redraw the entire window
  sWindowState.w = gasEdit[nEditNum].whWindow;
  xwimp_get_window_state (& sWindowState);

  sRedraw.w = gasEdit[nEditNum].whWindow;
  sRedraw.box.x0 = sWindowState.xscroll;
  sRedraw.box.x1 = sWindowState.visible.x1 - sWindowState.visible.x0
    + sWindowState.xscroll;
  sRedraw.box.y0 = sWindowState.visible.y0 - sWindowState.visible.y1
    + sWindowState.yscroll;
  sRedraw.box.y1 = sWindowState.yscroll;
  xwimp_update_window (& sRedraw, & boMore);

  while (boMore)
  {
    RedrawEdit (& sRedraw, nEditNum);
    xwimp_get_rectangle (& sRedraw, & boMore);
  }
}

//////////////////////////////////////////////////////////////////
// Transfers the selected emails into an array list
void CompileSelectedList (void)
{
  int                         nCount;

  for (nCount = 0; nCount < gnDetailsNum; nCount++)
  {
    if (gasDetails[nCount].boSelected)
    {
      AddToRETRQueue (nCount);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Destroys the windows of the selected emails
void DestroySelectedEmails (void)
{
  int                         nCount;

  for (nCount = 0; nCount < gnDetailsNum; nCount++)
  {
    if (gasDetails[nCount].boSelected)
    {
      DestroyEmailWindow (nCount);
    }
  }
}



//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
// POP3 code
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////





//////////////////////////////////////////////////////////////////
// Main POP3/SMTP program
void NetworkLoop (NET eNetCom)
{
  SOCK                        eSockError;

  switch (geState)
  {
    case STATE_DISCONNECTED:
      SetConnectStatus (CONNECTED_OFF);
      switch (eNetCom)
      {
        case NET_POP3_LIST:
        case NET_POP3_DOWNLOAD:
        case NET_POP3_DELETE:
          strcpy(gpcCommand,"");
          Log ("", "POP3 connect...");
          SendCommandReset ();
          strncpy (gszServer, gasAccount[gnAccount].szPOP3Server,
            sizeof (gszServer));
          gnPort = gasAccount[gnAccount].nPOP3Port;
          geState = STATE_CREATESOCKET;
          break;
        case NET_SMTP_SEND:
          strcpy(gpcCommand,"");
          Log ("", "SMTP connect...");
          SendCommandReset ();
          strncpy (gszServer, gasAccount[gnAccount].szSMTPServer,
            sizeof (gszServer));
          gnPort = gasAccount[gnAccount].nSMTPPort;
          geState = STATE_CREATESOCKET;
          break;
        default:
          // Do nothing
          break;
      }
      break;
    case STATE_CREATESOCKET:
      SetConnectStatus (CONNECTED_WAITING);
      eSockError = CreateSocket (& gsSocket);
      switch (eSockError)
      {
        case SOCK_FAIL:
          Cancel ();
//          geState = STATE_DISCONNECTED;
          geState = STATE_CANCEL;
          break;
        case SOCK_ERR:
          Cancel ();
//          geState = STATE_FINISHED;
          geState = STATE_CANCEL;
          break;
        default:
          geState = STATE_RESOLVING;
          break;
      }
      break;
    case STATE_RESOLVING:
      geState = Resolve (gszServer, & gnAddress);
      break;
    case STATE_CONNECT:
      geState = Connect (gnAddress, & gsSocket, gnPort);
      break;
    case STATE_CONNECTING:
      geState = CheckConnected (gsSocket);
      break;
    case STATE_CONNECTED:
      switch (eNetCom)
      {
        case NET_POP3_LIST:
        case NET_POP3_DOWNLOAD:
        case NET_POP3_DELETE:
          geState = STATE_POP3_AUTHORIZATION;
          break;
        case NET_SMTP_SEND:
          geState = STATE_SMTP_AUTHORIZATION;
          break;
        default:
          Cancel ();
//          geState = STATE_FINISHED;
          geState = STATE_CANCEL;
          REPORT ("No valid command action set");
          // Do nothing
          break;
      }
      break;

    case STATE_POP3_AUTHORIZATION:
      geState = POP3Authorization (& gsSocket);
      break;
    case STATE_POP3_TRANSACTION:
      geState = POP3Transaction (& gsSocket);
      break;
    case STATE_POP3_QUIT:
      geState = POP3Quit (& gsSocket);
      break;

    case STATE_SMTP_AUTHORIZATION:
      geState = SMTPAuthorization (& gsSocket);
      break;
    case STATE_SMTP_TRANSACTION:
      geState = SMTPTransaction (& gsSocket);
      break;
    case STATE_SMTP_QUIT:
      geState = SMTPQuit (& gsSocket);
      break;

    case STATE_CANCEL:
      geState = ImmediateUpdate (& gsSocket);
      SetConnectStatus (CONNECTED_OFF);
      Log ("", "Cancel");
      break;
    case STATE_FINISHED:
      // Close socket
      err (xsocket_close (gsSocket));
      SetConnectStatus (CONNECTED_OFF);
      gnTimeoutTime = -1;
      geNetCom = NET_INVALID;
      geState = STATE_DISCONNECTED;
#if defined _DEBUG
      char                     szReport[1024];
      sprintf (szReport, "Queued %d, sent %d", gnDebugQueued,
        gnDebugSent);
      REPORT (szReport);

      gnDebugQueued += gnSendCommandLen;
      gnDebugSent += gnSendCommandSent;
#endif
      Log ("", "Disconnected");
      break;
    default:
      REPORT ("Invalid state");
      break;
  }

#if defined _DEBUG
  if (gePrevState != geState)
  {
    PrintState (geState);
  }
  gePrevState = geState;
#endif
}

//////////////////////////////////////////////////////////////////
// Create Socket
SOCK CreateSocket (socket_s * psSocket)
{
  socket_sockaddr            sAddress;
  char                       cArg;
  os_error                   *psError;
  SOCK                       eReturn;
  int                        nArg;

  eReturn = SOCK_OK;

  if (psSocket)
  {
    psError = xsocket_creat (socket_AF_INET, socket_SOCK_STREAM,
      socket_IPPROTO_TCP, psSocket);
//      socket_IPPROTO_IP, psSocket);

    if (psError)
    {
      err (psError);
      eReturn = SOCK_FAIL;
    }
//    else
//    {
//      memset (& sAddress, 0, sizeof (sAddress));
//      sAddress.sockaddr.af = socket_AF_INET;
//      sAddress.sockaddr_in.af = socket_AF_INET;
//      sAddress.sockaddr_in.port = 0;
//      sAddress.sockaddr_in.addr = 0;
//
//      psError = xsocket_bind (*psSocket, & sAddress, 16);
//
//      if (psError)
//      {
//        err (psError);
//        eReturn = SOCK_ERR;
//      }
    else
    {
      cArg = 1;
      psError = xsocket_ioctl (*psSocket, socket_FIONBIO, & cArg);

      if (psError)
      {
        err (psError);
        eReturn = SOCK_ERR;
      }
#if defined MAX_SEND_LEN
      else
      {
        // Set the no-delay (Nagle) value for the socket
        nArg = 1;
        psError = xsocket_setsockopt (*psSocket, (socket_level)6,
          (socket_so)1, (byte*)& nArg, sizeof (nArg));

        if (psError)
        {
          err (psError);
          eReturn = SOCK_ERR;
        }
      }
#endif
    }
//    }
  }
  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Connect to the mail server
STATE Connect (int nAddress, socket_s * psSocket, int nPort)
{
  socket_sockaddr            sAddress;
  os_error                   *psError;
  STATE                      eNextState;

  memset (& sAddress, 0, sizeof (sAddress));
  sAddress.sockaddr.af = socket_AF_INET;
  sAddress.sockaddr_in.af = socket_AF_INET;

  sAddress.sockaddr_in.port = htons (nPort);
//  ((nPort & 0xff) << 8)
//    + ((nPort & 0xff00) >> 8);

  sAddress.sockaddr_in.addr = nAddress;

  psError = xsocket_connect (* psSocket, & sAddress, sizeof (sAddress));

  eNextState = STATE_CONNECTED;
  geQuitState = QUITSTATE_QUIT;
  if (psError)
  {
    if ((psError->errnum == socket_EISCONN)
      || (psError->errnum == (socket_EISCONN + IYONIX_SOCKET_ERR)))
    {
      eNextState = STATE_CONNECTED;
      geAuthState = AUTHSTATE_NOSENT;
    }
    else
    {
      if ((psError->errnum != socket_EWOULDBLOCK)
        && (psError->errnum != (socket_EWOULDBLOCK + IYONIX_SOCKET_ERR))
        && (psError->errnum != socket_EALREADY)
        && (psError->errnum != (socket_EALREADY + IYONIX_SOCKET_ERR))
        && (psError->errnum != socket_EINPROGRESS)
        && (psError->errnum != (socket_EINPROGRESS + IYONIX_SOCKET_ERR)))
      {
        REPORTVAR ("Error %d", psError->errnum);
        err (psError);
        Cancel ();
//        eNextState = STATE_FINISHED;
        eNextState = STATE_CANCEL;
      }
      else
      {
        eNextState = STATE_CONNECTING;
      }
    }
  }
  else
  {
    eNextState = STATE_CONNECTED;
    geAuthState = AUTHSTATE_NOSENT;
  }

  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Connect to the mail server
STATE CheckConnected (socket_s sSocket)
{
  os_error                   *psError;
  STATE                      eNextState;
//  socket_fdset               sRead;
  socket_fdset               sWrite;
//  socket_fdset               sExcept;
  int                        nFound;
  socket_timeval             sTimeVal;

//  FD_ZERO (& sRead);
  FD_ZERO (& sWrite);
//  FD_ZERO (& sExcept);
//  memset (& sRead, 0, sizeof (sRead));
//  memset (& sWrite, 0, sizeof (sWrite));
//  memset (& sExcept, 0, sizeof (sExcept));

//  FD_SET ((unsigned int)(sSocket), (fd_set*)(& sRead));
  FD_SET ((unsigned int)(sSocket), (fd_set*)(& sWrite));
//  FD_SET ((unsigned int)(sSocket), (fd_set*)(& sExcept));
//  sRead |= (1 << (unsigned int)sSocket);
//  sWrite |= (1 << (unsigned int)sSocket);
//  sExcept |= (1 << (unsigned int)sSocket);

  sTimeVal.sec = 0;
  sTimeVal.usec = 0;

//  psError = xsocket_select (((unsigned int)sSocket) + 1, & sRead, & sWrite,
//    & sExcept, & sTimeVal, & nFound);

  psError = xsocket_select (((unsigned int)sSocket) + 1, NULL, & sWrite,
    NULL, & sTimeVal, & nFound);

  eNextState = STATE_CONNECTING;
  if (psError)
  {
    REPORTVAR ("Error %d", psError->errnum);
    err (psError);
    Cancel ();
    eNextState = STATE_CANCEL;
  }
  else
  {
#if defined _DEBUG
//    if (FD_ISSET ((unsigned int)(sSocket), (fd_set*)(& sRead)))
//    {
//      REPORT ("Found on Read");
//    }
    if (FD_ISSET ((unsigned int)(sSocket), (fd_set*)(& sWrite)))
    {
      REPORT ("Found on Write");
    }
//    if (FD_ISSET ((unsigned int)(sSocket), (fd_set*)(& sExcept)))
//    {
//      REPORT ("Found on Except");
//    }
#endif

    if (nFound > 0)
    {
      REPORTVAR ("Pre-found %d", nFound);
//      if ((FD_ISSET ((unsigned int)(sSocket), (fd_set*)(& sRead)))
//        || (FD_ISSET ((unsigned int)(sSocket), (fd_set*)(& sWrite))))
      if (FD_ISSET ((unsigned int)(sSocket), (fd_set*)(& sWrite)))
      {
        REPORTVAR ("Found %d", nFound);
        eNextState = STATE_CONNECTED;
        geAuthState = AUTHSTATE_NOSENT;
        geQuitState = QUITSTATE_QUIT;
      }
    }

#if defined _DEBUG
    int                      nKey;
    xosbyte1 (osbyte_SCAN_KEYBOARD, (0x67 ^ 0x80), 0, & nKey); // Fullstop
    if (nKey == 0xff)
    {
      REPORT ("Key pressed");
      eNextState = STATE_CONNECTED;
      geAuthState = AUTHSTATE_NOSENT;
      geQuitState = QUITSTATE_QUIT;
    }
#endif
  }

  return eNextState;
}


#if defined _DEBUG
//////////////////////////////////////////////////////////////////
// Print the given state
void PrintState (STATE eState)
{
  switch (eState)
  {
    case STATE_DISCONNECTED:
      REPORT ("Disconnected");
      break;
    case STATE_CREATESOCKET:
      REPORT ("Creating socket");
      break;
    case STATE_RESOLVING:
      REPORT ("Resolving");
      break;
    case STATE_CONNECT:
      REPORT ("Connect");
      break;
    case STATE_CONNECTING:
      REPORT ("Connecting");
      break;
    case STATE_CONNECTED:
      REPORT ("Connected");
      break;

    case STATE_POP3_AUTHORIZATION:
      REPORT ("POP3 Authorization");
      break;
    case STATE_POP3_TRANSACTION:
      REPORT ("POP3 Transaction");
      break;
    case STATE_POP3_QUIT:
      REPORT ("POP3 Quit");
      break;

    case STATE_SMTP_AUTHORIZATION:
      REPORT ("SMTP Authorization");
      break;
    case STATE_SMTP_TRANSACTION:
      REPORT ("SMTP Transaction");
      break;
    case STATE_SMTP_QUIT:
      REPORT ("SMTP Quit");
      break;

    case STATE_CANCEL:
      REPORT ("Cancelled");
      break;
    case STATE_FINISHED:
      REPORT ("Finished");
      break;
    default:
      REPORT ("POP3 Invalid");
      break;
  }
}
#endif

//////////////////////////////////////////////////////////////////
// Resolve a host name
STATE Resolve (char * szHostName, int * pnAddress)
{
  _kernel_swi_regs           sRegs;
  STATE                      eNextState;
  os_error                   sError;

  sRegs.r[0] = (int)szHostName;
  _kernel_swi (Resolver_GetHost, & sRegs, & sRegs);

  if (sRegs.r[0] == 0)
  {
    eNextState = STATE_CONNECT;
    if (pnAddress)
    {
      *pnAddress = ***(int***)((char*)(sRegs.r[1] + 16));
    }
  }
  else
  {
    if (((int)(sRegs.r[0])) == 36)
    {
      Log ("HOST: ", szHostName);
      eNextState = STATE_RESOLVING;
    }
    else
    {
      sError.errnum = 0;
      strcpy (sError.errmess, Tag("Er9"));
      err (& sError);
      Cancel ();
//      eNextState = STATE_FINISHED;
      eNextState = STATE_CANCEL;
    }
  }

  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Read any incoming data from a socket
SOCK POP3SocketRead (socket_s * psSocket)
{
  int                        nRead;
  os_error                   *psError = NULL;
  int                        nBufferSize;
  SOCK                       eReturn = SOCK_WAIT;

  eReturn = POP3RemoveLine (gpcBuffer, gnBufferStart, & gnBufferStart);
  if (eReturn == SOCK_WAIT)
  {
    nBufferSize = BUFFERSIZE - gnBufferStart;
    if (nBufferSize > 0)
    {
      psError = xsocket_read (*psSocket, gpcBuffer + gnBufferStart,
        nBufferSize, & nRead);
    }

    if (!psError)
    {
      // Remove and print any full lines
      eReturn = POP3RemoveLine (gpcBuffer, gnBufferStart + nRead,
        & gnBufferStart);
    }

    if (psError)
    {
      if ((psError->errnum != socket_EWOULDBLOCK)
        && (psError->errnum != (socket_EWOULDBLOCK + IYONIX_SOCKET_ERR))
        && (psError->errnum != socket_EINPROGRESS)
        && (psError->errnum != (socket_EINPROGRESS + IYONIX_SOCKET_ERR)))
      {
        REPORTVAR ("POP3 Read Error %d", psError->errnum);
        err (psError);
        eReturn = SOCK_FAIL;
      }
//      if ((psError->errnum == 0)
//        || (psError->errnum == IYONIX_SOCKET_ERR))
//      {
//        eReturn = SOCK_FAIL;
//      }
    }
  }

  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Remove a line from the buffer if there is one
SOCK POP3RemoveLine (char * pcBuffer, int nLength, int * pnBufferStart)
{
  int                        nPos;
  bool                       boFound;
  int                        nCopyPos;
  int                        nComLen;
  SOCK                       eReturn = SOCK_WAIT;

  // Find the end of the line (if there is one)
  nPos = 0;
  boFound = FALSE;
  while ((nPos < nLength) && (!boFound))
  {
    if ((pcBuffer[nPos] == 0x0a) || (pcBuffer[nPos] == 0x0d))
    {
      boFound = TRUE;
    }
    nPos++;
  }

  if (boFound)
  {
    //Copy into the command buffer
    nComLen = MIN (((int)sizeof(gpcCommand) - 1), (nPos - 1));

    if ((pcBuffer[0] == '.') && (nComLen > 1))
    {
      // Remove prefixed terminating '.'
      strncpy (gpcCommand, (pcBuffer + 1), (nComLen - 1));
      // Terminate the command
      gpcCommand[nComLen - 1] = 0;
    }
    else
    {
      strncpy (gpcCommand, pcBuffer, nComLen);
      // Terminate the command
      gpcCommand[nComLen] = 0;
    }

    // Remove trailing terminators
    if ((nPos < nLength) && ((pcBuffer[nPos] == 0x0a)
      || (pcBuffer[nPos] == 0x0d)))
    {
      nPos++;
    }

    // Reset the buffer start position
    *pnBufferStart = nLength - nPos;

    // Shift the contents of the buffer down
    if (nPos > 0)
    {
      nCopyPos = 0;
      while (nPos < nLength)
      {
        pcBuffer[nCopyPos] = pcBuffer[nPos];
        nPos++;
        nCopyPos++;
      }
    }

    eReturn = SOCK_RECEIVE;
    SetConnectStatus (CONNECTED_RECEIVING);
    if (strncmp (gpcCommand, "+OK", 3) == 0)
    {
      Log ("IN  : ", gpcCommand);
      eReturn = SOCK_OK;
    }
    else
    {
      if (strncmp (gpcCommand, "-ERR", 4) == 0)
      {
        Log ("IN : ",gpcCommand);
        eReturn = SOCK_ERR;
      }
      else
      {
        if ((gpcCommand[0] == '.') && (gpcCommand[1] == 0x0)
          && (nComLen == 1))
        {
          Log ("IN  : ",".MULTIDONE\n");
          eReturn = SOCK_MULTIDONE;
        }
      }
    }
  }
  else
  {
    // Make sure the next download extends the buffer
    *pnBufferStart = nLength;
    SetConnectStatus (CONNECTED_WAITING);
  }

  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Send a message
SOCK SendCommand (char * szCommand, socket_s * psSocket)
{
  char                       szSend[256];
  int                        nLen;
  int                        nCc;
  os_error                   *psError;
  SOCK                       eReturn;

  eReturn = SOCK_OK;

  strncpy(szSend, szCommand, sizeof(szSend) - 3);

  nLen = strlen(szSend);
  szSend[nLen] = 13;
  szSend[nLen + 1] = 10;
  szSend[nLen + 2] = 0;
  nLen = strlen(szSend);

  SetConnectStatus (CONNECTED_SENDING);
  psError = xsocket_send (* psSocket, szSend, nLen, 0, & nCc);

  if (psError)
  {
    err (psError);
    eReturn = SOCK_ERR;
  }

  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Reset message sending buffers
void SendCommandReset (void)
{
  gnSendCommandLen = 0;
  gnSendCommandSent = 0;
}

//////////////////////////////////////////////////////////////////
// Start sending a message
SOCK SendCommandStart (char * szCommand, socket_s * psSocket)
{
  os_error                   *psError;
  SOCK                       eReturn;
#if defined MAX_SEND_LEN
  int                        nSendLen;
#endif

  eReturn = SOCK_OK;

  if (gnSendCommandLen != 0)
  {
    // We're already sending something!
    ShowWarningTag ("Er43");
    eReturn = SOCK_FAIL;
  }
  else
  {
    // Set up the command to be sent
    gsSendSocket = * psSocket;
    strncpy(gszSendCommand, szCommand, COMMAND_LEN_QUEUE - 3);
    gszSendCommand[COMMAND_LEN_QUEUE - 3] = 0;

    gnSendCommandLen = strlen(gszSendCommand);
    gszSendCommand[gnSendCommandLen] = 13;
    gszSendCommand[gnSendCommandLen + 1] = 10;
    gszSendCommand[gnSendCommandLen + 2] = 0;
    gnSendCommandLen += 2;

    gnSendCommandSent = 0;
    SetConnectStatus (CONNECTED_SENDING);

#if defined MAX_SEND_LEN
    nSendLen = gnSendCommandLen;
    if (nSendLen > gnMaxSendLen)
    {
      nSendLen = gnMaxSendLen;
    }
    psError = xsocket_send (gsSendSocket, gszSendCommand, nSendLen,
      0, & gnSendCommandSent);
#else
    psError = xsocket_send (gsSendSocket, gszSendCommand, gnSendCommandLen,
      0, & gnSendCommandSent);
#endif

#if defined _DEBUG
    char                     szReport[1024];
    sprintf (szReport, "Sent %d of %d (init)", gnSendCommandSent,
      gnSendCommandLen);
    REPORT (szReport);

    gnDebugQueued += gnSendCommandLen;
    gnDebugSent += gnSendCommandSent;
#endif

    if (gnSendCommandSent < gnSendCommandLen)
    {
      eReturn = SOCK_WAIT;
    }
    else
    {
      gnSendCommandLen = 0;
      gnSendCommandSent = 0;
    }

    if (psError)
    {
      if ((psError->errnum != socket_EWOULDBLOCK)
        && (psError->errnum != (socket_EWOULDBLOCK + IYONIX_SOCKET_ERR))
        && (psError->errnum != socket_EINPROGRESS)
        && (psError->errnum != (socket_EINPROGRESS + IYONIX_SOCKET_ERR)))
      {
        REPORTVAR ("Send error number %d", psError->errnum);
        err (psError);
        gnSendCommandLen = 0;
        eReturn = SOCK_FAIL;
      }
    }
  }

  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Continue sending a message if there is one
SOCK SendCommandUpdate (void)
{
  int                        nCc;
  os_error                   *psError;
  SOCK                       eReturn;
#if defined MAX_SEND_LEN
  int                        nSendLen;
#endif

  eReturn = SOCK_OK;

  if (gnSendCommandSent < gnSendCommandLen)
  {
    // Continue sending the command
    SetConnectStatus (CONNECTED_SENDING);
    nCc = 0;

#if defined MAX_SEND_LEN
    nSendLen = gnSendCommandLen - gnSendCommandSent;
    if (nSendLen > gnMaxSendLen)
    {
      nSendLen = gnMaxSendLen;
    }
    psError = xsocket_send (gsSendSocket, gszSendCommand + gnSendCommandSent,
      nSendLen, 0, & nCc);
#else
    psError = xsocket_send (gsSendSocket, gszSendCommand + gnSendCommandSent,
      gnSendCommandLen - gnSendCommandSent, 0, & nCc);
#endif

#if defined _DEBUG
    char                     szReport[1024];
    sprintf (szReport, "Sent %d of %d (update)", nCc,
      gnSendCommandLen - gnSendCommandSent);
    REPORT (szReport);

    gnDebugSent += nCc;
#endif

    gnSendCommandSent += nCc;

    if (gnSendCommandSent < gnSendCommandLen)
    {
      eReturn = SOCK_WAIT;
    }
    else
    {
      gnSendCommandLen = 0;
      gnSendCommandSent = 0;
    }

    if (psError)
    {
      if ((psError->errnum != socket_EWOULDBLOCK)
        && (psError->errnum != (socket_EWOULDBLOCK + IYONIX_SOCKET_ERR))
        && (psError->errnum != socket_EINPROGRESS)
        && (psError->errnum != (socket_EINPROGRESS + IYONIX_SOCKET_ERR)))
      {
        REPORTVAR ("Update error number %d", psError->errnum);
        err (psError);
        gnSendCommandLen = 0;
        eReturn = SOCK_FAIL;
      }
    }
  }
  else
  {
    gnSendCommandLen = 0;
    gnSendCommandSent = 0;
  }

  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Handles authorization state
STATE POP3Authorization (socket_s * psSocket)
{
  STATE                      eNextState = STATE_POP3_AUTHORIZATION;
  SOCK                       eReturnSend;
  SOCK                       eReturnRead;
  char                       szCommand[COMMAND_LEN];

  eReturnRead = POP3SocketRead (psSocket);
  eReturnSend = SendCommandUpdate ();

  switch (geAuthState)
  {
    case AUTHSTATE_NOSENT:
      if (eReturnRead == SOCK_OK)
      {
        sprintf (szCommand, "USER %s", gasAccount[gnAccount].szPOP3Username);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (POP3_TIMEOUT);
        geAuthState = AUTHSTATE_USERSENT;
      }
      if (eReturnRead == SOCK_ERR)
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_USERSENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          sprintf (szCommand, "PASS %s",
            gasAccount[gnAccount].szPOP3Password);
          Log ("OUT : ", "PASS <password>");
          eReturnSend = SendCommandStart (szCommand, psSocket);
          ResetTimeout (POP3_TIMEOUT);
          geAuthState = AUTHSTATE_PASSSENT;
        }
        if (eReturnRead == SOCK_ERR)
        {
          ShowWarningTagArg ("Er11", gpcCommand);
          Cancel ();
          eNextState = STATE_CANCEL;
        }
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_PASSSENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          gePOP3TranState = POP3_TRANSTATE_NOSENT;
          eNextState = STATE_POP3_TRANSACTION;
          geAuthState = AUTHSTATE_NOSENT;
        }
        if (eReturnRead == SOCK_ERR)
        {
          ShowWarningTagArg ("Er12", gpcCommand);
          Cancel ();
          eNextState = STATE_CANCEL;
        }
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    default:
      REPORT ("Invalid authorization state\n");
      Cancel ();
//      eNextState = STATE_FINISHED;
      eNextState = STATE_CANCEL;
      break;
  }
  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Handles transaction state
STATE POP3Transaction (socket_s * psSocket)
{
  STATE                      eNextState = STATE_POP3_TRANSACTION;
  SOCK                       eReturnRead;
  SOCK                       eReturnSend;
  int                        nMsgNum;
  int                        nSize;
  int                        nDetailsPos;
  char                       szCommand[COMMAND_LEN];
  int                        nLength;
  int                        nAllocSuccess;
  POP3_TRANSTATE             ePOP3TranState;
  char                       szUID[UID_MAX];
  char                       szWarning[16];
  int                        nCurrentSize;

  ePOP3TranState = gePOP3TranState;

  eReturnRead = POP3SocketRead (psSocket);
  eReturnSend = SendCommandUpdate ();

  switch (gePOP3TranState)
  {
    case POP3_TRANSTATE_NOSENT:
      switch (geNetCom)
      {
        case NET_POP3_LIST:
          if (eReturnSend == SOCK_OK)
          {
            // Send STAT command
            Log ("OUT : ", "STAT");
            eReturnSend = SendCommandStart ("STAT", psSocket);
            ResetTimeout (POP3_TIMEOUT);
            gePOP3TranState = POP3_TRANSTATE_STATSENT;
          }
          if (eReturnSend == SOCK_FAIL)
          {
            gePOP3TranState = POP3_TRANSTATE_DONE;
          }
          break;
        case NET_POP3_DOWNLOAD:
          gnRETRActPos = 0;
          gePOP3TranState = POP3_TRANSTATE_NEXTDOWNLOAD;
          break;
        case NET_POP3_DELETE:
          gnDELEActPos = 0;
          gePOP3TranState = POP3_TRANSTATE_NEXTDELETE;
          break;
        default:
          gePOP3TranState = POP3_TRANSTATE_DONE;
          break;
      }
      break;
    case POP3_TRANSTATE_STATSENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          sscanf (gpcCommand, "+OK %d %d", & nMsgNum, & nSize);
          if ((nMsgNum == gnDetailsNum) && (nSize == gnTotalMailSize)
            && (!gboUIDDesync))
          {
            // No new emails to collect
            gePOP3TranState = POP3_TRANSTATE_DONE;
          }
          else
          {
            if (nMsgNum < gnDetailsNum)
            {
              // Remove the excess emails from the end of the list
              DeleteMultipleEmails (nMsgNum, gnDetailsNum);
            }
            // Send LIST command
            gnTotalMailSizeTemp = nSize;
            Log ("OUT : ", "LIST");
            eReturnSend = SendCommandStart ("LIST", psSocket);
            ResetTimeout (POP3_TIMEOUT);
            gePOP3TranState = POP3_TRANSTATE_LISTSENT;
          }
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_ERR)
      {
        gePOP3TranState = POP3_TRANSTATE_LISTSENT;
      }
      break;
    case POP3_TRANSTATE_LISTSENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          ResetTimeout (POP3_TIMEOUT);
          gnCurrentMsg = MESSAGE_INVALID;
          gePOP3TranState = POP3_TRANSTATE_LIST;
        }
        if (eReturnRead == SOCK_ERR)
        {
          // Some sort of error occured
          ShowWarningTagArg ("Er13", gpcCommand);
          gePOP3TranState = POP3_TRANSTATE_DONE;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_LIST:
      if (eReturnRead == SOCK_RECEIVE)
      {
        ResetTimeout (POP3_TIMEOUT);
        gnCurrentMsg++;
        sscanf (gpcCommand, "%d %d", & nMsgNum, & nSize);
        Log ("IN  : ", gpcCommand);
        if (gnCurrentMsg < DETAILS_MAX)
        {
          if (gnCurrentMsg < gnDetailsNum)
          {
            if ((gasDetails[gnCurrentMsg].eState > DETAILS_NONE)
              && ((gasDetails[gnCurrentMsg].nMsgNum != nMsgNum)
              || (gasDetails[gnCurrentMsg].nServerSize != nSize)))
            {
              LogVar ("Desync at message %d", gnCurrentMsg);
              DeleteMultipleEmails (gnCurrentMsg, gnDetailsNum);
            }
          }

          if (gnCurrentMsg >= gnDetailsNum)
          {
            gasDetails[gnCurrentMsg].nMsgNum = nMsgNum;
            gasDetails[gnCurrentMsg].nSize = nSize;
            gasDetails[gnCurrentMsg].nServerSize = nSize;
            gasDetails[gnCurrentMsg].eState = DETAILS_SIZE;
            gasDetails[gnCurrentMsg].nSortPos = gnCurrentMsg;
            ganSort[gnCurrentMsg] = gnCurrentMsg;
            if (gasDetails[gnCurrentMsg].eMailState != MAILSTATE_GETTING)
            {
              gasDetails[gnCurrentMsg].eMailState = MAILSTATE_REMOTE;
            }
            SetMainExtent (gnCurrentMsg + 1);
            UpdateMain (gnCurrentMsg, gnCurrentMsg);
          }
        }
#if defined _DEBUG
        else
        {
          REPORT ("Too many messages!\n");
        }
#endif
      }
      if (eReturnRead == SOCK_MULTIDONE)
      {
        if (gnCurrentMsg >= (DETAILS_MAX - 1))
        {
          sprintf (szWarning, "%d", DETAILS_MAX);
          ShowWarningTagArg ("Er26", szWarning);
          gnDetailsNum = DETAILS_MAX;
        }
        else
        {
          gnDetailsNum = gnCurrentMsg + 1;
        }

        // Send UIDL command
        Log ("OUT : ", "UIDL");
        eReturnSend = SendCommandStart ("UIDL", psSocket);
        ResetTimeout (POP3_TIMEOUT);
        gePOP3TranState = POP3_TRANSTATE_UIDLLISTSENT;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_ERR)
      {
        ShowWarningTagArg ("Er13", gpcCommand);
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_UIDLLISTSENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          gnCurrentMsg = MESSAGE_INVALID;
          gePOP3TranState = POP3_TRANSTATE_UIDLLIST;
        }
        if (eReturnRead == SOCK_ERR)
        {
          // Some sort of error occured
          ShowWarningTagArg ("Er13", gpcCommand);
          gePOP3TranState = POP3_TRANSTATE_DONE;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_UIDLLIST:
      if (eReturnRead == SOCK_RECEIVE)
      {
        ResetTimeout (POP3_TIMEOUT);
        gnCurrentMsg++;
        sscanf (gpcCommand, "%d %s", & nMsgNum, szUID);
        if (gnCurrentMsg < gnDetailsNum)
        {
          if ((gasDetails[gnCurrentMsg].nMsgNum != nMsgNum)
            || ((gasDetails[gnCurrentMsg].eState >= DETAILS_UID)
            && (strncmp (gasDetails[gnCurrentMsg].szUID, szUID, UID_MAX)
            != 0)))
          {
            LogVar ("Desync at message %d", gnCurrentMsg);
            DeleteMultipleEmails (gnCurrentMsg, gnDetailsNum);
            gePOP3TranState = POP3_TRANSTATE_UIDLLISTDESYNC;
          }

          if (gasDetails[gnCurrentMsg].eState < DETAILS_UID)
          {
            strncpy (gasDetails[gnCurrentMsg].szUID, szUID, UID_MAX);
          }
        }
#if defined _DEBUG
        else
        {
          REPORT ("Too many messages!\n");
        }
#endif
      }
      if (eReturnRead == SOCK_MULTIDONE)
      {
        gnCurrentMsg = MESSAGE_INVALID;
        gePOP3TranState = POP3_TRANSTATE_NEXTDETAILS;
      }
      if (eReturnRead == SOCK_ERR)
      {
        // Some sort of error occured
        ShowWarningTagArg ("Er13", gpcCommand);
        gePOP3TranState = POP3_TRANSTATE_NEXTDETAILS;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_UIDLLISTDESYNC:
      if (eReturnRead == SOCK_MULTIDONE)
      {
        // Send LIST command
        Log ("OUT : ", "LIST");
        eReturnSend = SendCommandStart ("LIST", psSocket);
        ResetTimeout (POP3_TIMEOUT);
        gePOP3TranState = POP3_TRANSTATE_LISTSENT;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_ERR)
      {
        // Some sort of error occured
        ShowWarningTagArg ("Er13", gpcCommand);
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_NEXTDETAILS:
      if (eReturnSend == SOCK_OK)
      {
        nDetailsPos = gnCurrentMsg + 1;
        while ((nDetailsPos < gnDetailsNum)
          && (gasDetails[nDetailsPos].eState != DETAILS_SIZE))
        {
          nDetailsPos++;
        }
        if (nDetailsPos < gnDetailsNum)
        {
          gnCurrentMsg = nDetailsPos;
          sprintf (szCommand, "TOP %d 1", gasDetails[gnCurrentMsg].nMsgNum);
          Log ("OUT : ", szCommand);
          eReturnSend = SendCommandStart (szCommand, psSocket);
          ResetTimeout (POP3_TIMEOUT);
          gePOP3TranState = POP3_TRANSTATE_TOPSENT;
        }
        else
        {
          gePOP3TranState = POP3_TRANSTATE_DONE;
          gnTotalMailSize = gnTotalMailSizeTemp;
          gboUIDDesync = FALSE;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_TOPSENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          gePOP3TranState = POP3_TRANSTATE_TOPINTERPRET;
        }
        if (eReturnRead == SOCK_ERR)
        {
          ShowWarningTagArg ("Er14", gpcCommand);
          gePOP3TranState = POP3_TRANSTATE_NEXTDETAILS;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_TOPINTERPRET:
      if (eReturnRead == SOCK_RECEIVE)
      {
        ResetTimeout (POP3_TIMEOUT);
        if ((strncmp (gpcCommand, "Subject:", 8) == 0)
          || (strncmp (gpcCommand, "SUBJECT:", 8) == 0))
        {
          strncpy (gasDetails[gnCurrentMsg].szSubject, gpcCommand + 9,
            SUBJECT_MAX);
          UpdateMain (gnCurrentMsg, gnCurrentMsg);
        }
        if ((strncmp (gpcCommand, "From:", 5) == 0)
         || (strncmp (gpcCommand, "FROM:", 5) == 0))
        {
          strncpy (gasDetails[gnCurrentMsg].szSender, gpcCommand + 6,
            SENDER_MAX);
          CopySenderDisplay (gasDetails[gnCurrentMsg].szSenderDisplay,
            gpcCommand + 6);
          UpdateMain (gnCurrentMsg, gnCurrentMsg);
        }
        if ((strncmp (gpcCommand, "Date:", 5) == 0)
         || (strncmp (gpcCommand, "DATE:", 5) == 0))
        {
          InterpretDate (gpcCommand + 6, gasDetails[gnCurrentMsg].pcDate);
          UpdateMain (gnCurrentMsg, gnCurrentMsg);
        }
      }
      if (eReturnRead == SOCK_MULTIDONE)
      {
        gasDetails[gnCurrentMsg].eState = DETAILS_FULL;
        gePOP3TranState = POP3_TRANSTATE_NEXTDETAILS;
      }
      if (eReturnRead == SOCK_ERR)
      {
        ShowWarningTagArg ("Er14", gpcCommand);
        gePOP3TranState = POP3_TRANSTATE_NEXTDETAILS;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DONE;
      }
      break;
    case POP3_TRANSTATE_NEXTDOWNLOAD:
      if (eReturnSend == SOCK_OK)
      {
        // Send UIDL command
        if (gnRETRActPos < gnRETRActNum)
        {
          gnCurrentMsg = ganRETRAct[gnRETRActPos];
          sprintf (szCommand, "UIDL %d", gasDetails[gnCurrentMsg].nMsgNum);
          Log ("OUT : ", szCommand);
          eReturnSend = SendCommandStart (szCommand, psSocket);
          ResetTimeout (POP3_TIMEOUT);
          gePOP3TranState = POP3_TRANSTATE_RETRUIDL;
        }
        else
        {
          gePOP3TranState = POP3_TRANSTATE_DONE;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      break;
    case POP3_TRANSTATE_RETRUIDL:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          ResetTimeout (POP3_TIMEOUT);
          sscanf (gpcCommand, "+OK %d %s", & nMsgNum, szUID);
          if (strncmp (gasDetails[gnCurrentMsg].szUID, szUID, UID_MAX) == 0)
          {
            gePOP3TranState = POP3_TRANSTATE_SENDRETR;
          }
          else
          {
            gePOP3TranState = POP3_TRANSTATE_UIDDESYNC;
          }
        }
        if (eReturnRead == SOCK_ERR)
        {
  //        ShowWarningTagArg ("Er15", gpcCommand);
          gePOP3TranState = POP3_TRANSTATE_UIDDESYNC;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      break;
    case POP3_TRANSTATE_SENDRETR:
      if (eReturnSend == SOCK_OK)
      {
        // Send RETR command
        sprintf (szCommand, "RETR %d", gasDetails[gnCurrentMsg].nMsgNum);
        ResetTimeout (POP3_TIMEOUT);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        gePOP3TranState = POP3_TRANSTATE_RETRSENT;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      break;
    case POP3_TRANSTATE_RETRSENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          ResetTimeout (POP3_TIMEOUT);
          // Allocate memory for email, then copy the contents
          nAllocSuccess = flex_alloc ((flex_ptr)(& gpcCurrentEmail),
            gasDetails[gnCurrentMsg].nSize * sizeof(char));
          gnDownloadPos = 0;
          gePOP3TranState = POP3_TRANSTATE_RETRINTERPRET;
          if (nAllocSuccess == 0)
          {
            gpcCurrentEmail = NULL;
            ShowWarningTag ("Er30");
            ShiftRETRQueue ();
            gePOP3TranState = POP3_TRANSTATE_NEXTDOWNLOAD;
          }
        }
        if (eReturnRead == SOCK_ERR)
        {
          ShowWarningTagArg ("Er15", gpcCommand);
          ShiftRETRQueue ();
          gePOP3TranState = POP3_TRANSTATE_NEXTDOWNLOAD;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      break;
    case POP3_TRANSTATE_RETRINTERPRET:
      if (eReturnRead == SOCK_RECEIVE)
      {
        ResetTimeout (POP3_TIMEOUT);
        if (gpcCurrentEmail)
        {
          nLength = strlen (gpcCommand);
          nCurrentSize = gnDownloadPos + nLength + 1;

          if (nCurrentSize > gasDetails[gnCurrentMsg].nSize)
          {
            nAllocSuccess = flex_extend (
              (flex_ptr)(& gpcCurrentEmail), nCurrentSize);
            if (nAllocSuccess == 1)
            {
              gasDetails[gnCurrentMsg].nSize = nCurrentSize;
            }
          }

          if (nCurrentSize <= gasDetails[gnCurrentMsg].nSize)
          {
            strcpy (gpcCurrentEmail + gnDownloadPos, gpcCommand);
            gnDownloadPos += nLength;
            gpcCurrentEmail[gnDownloadPos] = 0x0a;
            gnDownloadPos++;
          }
        }
      }
      if (eReturnRead == SOCK_MULTIDONE)
      {
        nAllocSuccess = flex_reanchor(
          (flex_ptr)(& gasDetails[gnCurrentMsg].szRawEmail),
          (flex_ptr)(& gpcCurrentEmail));
        gasDetails[gnCurrentMsg].eMailState = MAILSTATE_LOCAL;
        ShiftRETRQueue ();

        if (nAllocSuccess == 0)
        {
          flex_free ((flex_ptr)(& gpcCurrentEmail));
          gpcCurrentEmail = NULL;
          ShowWarningTag ("Er6");
        }
        else
        {
          gpcCurrentEmail = NULL;
          gasDetails[gnCurrentMsg].nSize = gnDownloadPos;

//          // Refresh the main window line
//          UpdateMain (gnCurrentMsg, gnCurrentMsg);

          if (gasDetails[gnCurrentMsg].boOpenOnLoad)
          {
            // Open the email
            CreateEmailWindow (gnCurrentMsg);
            gasDetails[gnCurrentMsg].boOpenOnLoad = FALSE;
          }
        }
        gePOP3TranState = POP3_TRANSTATE_NEXTDOWNLOAD;
      }
      if (eReturnRead == SOCK_ERR)
      {
        flex_free ((flex_ptr)(& gpcCurrentEmail));
        gpcCurrentEmail = NULL;
        ShiftRETRQueue ();
        gasDetails[gnCurrentMsg].boOpenOnLoad = FALSE;
        ShowWarningTagArg ("Er15", gpcCommand);
        gePOP3TranState = POP3_TRANSTATE_NEXTDOWNLOAD;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        flex_free ((flex_ptr)(& gpcCurrentEmail));
        gpcCurrentEmail = NULL;
        gasDetails[gnCurrentMsg].boOpenOnLoad = FALSE;
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        flex_free ((flex_ptr)(& gpcCurrentEmail));
        gpcCurrentEmail = NULL;
        gasDetails[gnCurrentMsg].boOpenOnLoad = FALSE;
        gePOP3TranState = POP3_TRANSTATE_RETRFAIL;
      }
      break;
    case POP3_TRANSTATE_NEXTDELETE:
      if (eReturnSend == SOCK_OK)
      {
        // Send UIDL command
        if (gnDELEActPos < gnDELEActNum)
        {
          gnCurrentMsg = ganDELEAct[gnDELEActPos];
          sprintf (szCommand, "UIDL %d", gasDetails[gnCurrentMsg].nMsgNum);
          Log ("OUT : ", szCommand);
          eReturnSend = SendCommandStart (szCommand, psSocket);
          ResetTimeout (POP3_TIMEOUT);
          gePOP3TranState = POP3_TRANSTATE_DELEUIDL;
        }
        else
        {
          gePOP3TranState = POP3_TRANSTATE_DONE;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      break;
    case POP3_TRANSTATE_DELEUIDL:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          ResetTimeout (POP3_TIMEOUT);
          sscanf (gpcCommand, "+OK %d %s", & nMsgNum, szUID);
          if (strncmp (gasDetails[gnCurrentMsg].szUID, szUID, UID_MAX) == 0)
          {
            gePOP3TranState = POP3_TRANSTATE_SENDDELE;
          }
          else
          {
            gePOP3TranState = POP3_TRANSTATE_UIDDESYNC;
          }
        }
        if (eReturnRead == SOCK_ERR)
        {
          ShowWarningTagArg ("Er16", gpcCommand);
          ShiftDELEQueueRedraw ();
          gePOP3TranState = POP3_TRANSTATE_NEXTDELETE;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      break;
    case POP3_TRANSTATE_SENDDELE:
      if (eReturnSend == SOCK_OK)
      {
        // Send DELE command
        sprintf (szCommand, "DELE %d", gasDetails[gnCurrentMsg].nMsgNum);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (POP3_TIMEOUT);
        gePOP3TranState = POP3_TRANSTATE_DELESENT;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      break;
    case POP3_TRANSTATE_DELESENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          // Delete was successful
          ResetTimeout (POP3_TIMEOUT);
          gasDetails[gnCurrentMsg].eState = DETAILS_DELETED;
          ShiftDELEQueue ();

          DeleteEmailDetails (gnCurrentMsg);
          SetMainExtent (-1);
          UpdateMain (-1, -1);

          gePOP3TranState = POP3_TRANSTATE_NEXTDELETE;
        }
        else
        {
          if (eReturnRead == SOCK_ERR)
          {
            ShowWarningTagArg ("Er16", gpcCommand);
            gePOP3TranState = POP3_TRANSTATE_NEXTDELETE;
          }
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        gePOP3TranState = POP3_TRANSTATE_DELEFAIL;
      }
      break;
    case POP3_TRANSTATE_RETRFAIL:
      ClearPOP3Queues ();
      gePOP3TranState = POP3_TRANSTATE_DONE;
      break;
    case POP3_TRANSTATE_DELEFAIL:
      ClearPOP3Queues ();
      gePOP3TranState = POP3_TRANSTATE_DONE;
      break;
    case POP3_TRANSTATE_UIDDESYNC:
      ClearPOP3Queues ();
      ShowWarningTag ("Er8");
      gboUIDDesync = TRUE;
      gePOP3TranState = POP3_TRANSTATE_DONE;
      break;
    case POP3_TRANSTATE_DONE:
      gePOP3TranState = POP3_TRANSTATE_NOSENT;
      eNextState = STATE_POP3_QUIT;
      break;
    default:
      break;
  }

#if defined _DEBUG
  if (ePOP3TranState != gePOP3TranState)
  {
    PrintPOP3Transaction (gePOP3TranState);
  }
#endif

  return eNextState;
}

#if defined _DEBUG
//////////////////////////////////////////////////////////////////
// Print the given state
void PrintPOP3Transaction (POP3_TRANSTATE eState)
{
  switch (eState)
  {
    case POP3_TRANSTATE_NOSENT:
      REPORT ("Transaction Nothing Sent");
      break;
    case POP3_TRANSTATE_STATSENT:
      REPORT ("Transaction Status Sent");
      break;
    case POP3_TRANSTATE_LISTSENT:
      REPORT ("Transaction List Sent");
      break;
    case POP3_TRANSTATE_LIST:
      REPORT ("Transaction List");
      break;
    case POP3_TRANSTATE_UIDLLISTSENT:
      REPORT ("Transaction UID List Sent");
      break;
    case POP3_TRANSTATE_UIDLLIST:
      REPORT ("Transaction UID List");
      break;
    case POP3_TRANSTATE_UIDLLISTDESYNC:
      REPORT ("Transaction UID List Desync");
      break;
    case POP3_TRANSTATE_NEXTDETAILS:
      REPORT ("Transaction Next Details");
      break;
    case POP3_TRANSTATE_TOPSENT:
      REPORT ("Transaction Top Sent");
      break;
    case POP3_TRANSTATE_TOPINTERPRET:
      REPORT ("Transaction Top Interpret");
      break;
    case POP3_TRANSTATE_NEXTDOWNLOAD:
      REPORT ("Transaction Next Download");
      break;
    case POP3_TRANSTATE_RETRUIDL:
      REPORT ("Transaction RETR UIDL Sent");
      break;
    case POP3_TRANSTATE_SENDRETR:
      REPORT ("Transaction Send RETR");
      break;
    case POP3_TRANSTATE_RETRSENT:
      REPORT ("Transaction Retreive Sent");
      break;
    case POP3_TRANSTATE_RETRINTERPRET:
      REPORT ("Transaction Retreive Interpret");
      break;
    case POP3_TRANSTATE_NEXTDELETE:
      REPORT ("Transaction Next Delete");
      break;
    case POP3_TRANSTATE_DELEUIDL:
      REPORT ("Transaction DELE UIDL Sent");
      break;
    case POP3_TRANSTATE_SENDDELE:
      REPORT ("Transaction Send DELE");
      break;
    case POP3_TRANSTATE_DELESENT:
      REPORT ("Transaction Delete Sent");
      break;
    case POP3_TRANSTATE_UIDDESYNC:
      REPORT ("Transaction UID Desync");
    case POP3_TRANSTATE_DONE:
      REPORT ("Transaction Done");
      break;
    default:
      REPORT ("Transaction Unknown");
      break;
  }
}
#endif

//////////////////////////////////////////////////////////////////
// Finish off the POP3 transaction
STATE POP3Quit (socket_s * psSocket)
{
  STATE                      eNextState = STATE_POP3_QUIT;
  SOCK                       eReturnRead;
  SOCK                       eReturnSend;
  int                        nLoop;
  int                        nRedrawStart = -1;

  eReturnRead = POP3SocketRead (psSocket);
  eReturnSend = SendCommandUpdate ();

  switch (geQuitState)
  {
    case QUITSTATE_QUIT:
      if (eReturnSend == SOCK_OK)
      {
        Log ("OUT : ", "QUIT");
        eReturnSend = SendCommandStart ("QUIT", & gsSocket);
        ResetTimeout (TERMINATION_TIMEOUT);
        geQuitState = QUITSTATE_QUITSENT;
      }
      break;
    case QUITSTATE_QUITSENT:
      if ((eReturnSend == SOCK_OK) || (eReturnSend == SOCK_FAIL))
      {
        if ((eReturnRead == SOCK_OK) || (eReturnRead == SOCK_ERR)
          || (eReturnRead == SOCK_FAIL))
        {
          // Renumber the emails after deletions
          for (nLoop = 0; nLoop < gnDetailsNum; nLoop++)
          {
            if (gasDetails[nLoop].nMsgNum != (nLoop + 1))
            {
              if (nRedrawStart == -1)
              {
                nRedrawStart = nLoop;
              }
              gasDetails[nLoop].nMsgNum = (nLoop + 1);
            }
          }
          eNextState = STATE_FINISHED;
        }
        if (nRedrawStart != -1)
        {
          UpdateMain (nRedrawStart, -1);
        }
      }
      break;
    default:
      REPORT ("Invalid POP3 quit state\n");
      break;
  }

  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Handles update state for an error or cancel
STATE ImmediateUpdate (socket_s * psSocket)
{
  STATE                      eNextState = STATE_POP3_QUIT;
  SOCK                       eReturn;
  int                        nLoop;
  int                        nRedrawStart = -1;

  eReturn = POP3SocketRead (psSocket);

  // Renumber the emails after deletions
  for (nLoop = 0; nLoop < gnDetailsNum; nLoop++)
  {
    if (gasDetails[nLoop].nMsgNum != (nLoop + 1))
    {
      if (nRedrawStart == -1)
      {
        nRedrawStart = nLoop;
      }
      gasDetails[nLoop].nMsgNum = (nLoop + 1);
    }
  }
  eNextState = STATE_FINISHED;

  if (nRedrawStart != -1)
  {
    UpdateMain (nRedrawStart, -1);
  }

  return eNextState;
}























//////////////////////////////////////////////////////////////////
// Read any incoming data from a socket
SOCK SMTPSocketRead (socket_s * psSocket)
{
  int                        nRead;
  os_error                   *psError = NULL;
  int                        nBufferSize;
  SOCK                       eReturn = SOCK_WAIT;

  eReturn = SMTPRemoveLine (gpcBuffer, gnBufferStart, & gnBufferStart);
  if (eReturn == SOCK_WAIT)
  {
    nBufferSize = BUFFERSIZE - gnBufferStart;
    if (nBufferSize > 0)
    {
      psError = xsocket_read (*psSocket, gpcBuffer + gnBufferStart,
        nBufferSize, & nRead);
    }

    if (!psError)
    {
      // Remove and print any full lines
      eReturn = SMTPRemoveLine (gpcBuffer, gnBufferStart + nRead,
        & gnBufferStart);
    }

    if (psError)
    {
      if ((psError->errnum != socket_EWOULDBLOCK)
        && (psError->errnum != (socket_EWOULDBLOCK + IYONIX_SOCKET_ERR))
        && (psError->errnum != socket_EINPROGRESS)
        && (psError->errnum != (socket_EINPROGRESS + IYONIX_SOCKET_ERR)))
      {
        REPORTVAR ("SMTP Read Error %d", psError->errnum);
        err (psError);
        eReturn = SOCK_FAIL;
      }
//      if ((psError->errnum == 0)
//        || (psError->errnum == IYONIX_SOCKET_ERR))
//      {
//        eReturn = SOCK_FAIL;
//        Log ("", "Fail");
//      }
    }
  }

  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Remove a line from the buffer if there is one
SOCK SMTPRemoveLine (char * pcBuffer, int nLength, int * pnBufferStart)
{
  int                        nPos;
  bool                       boFound;
  int                        nCopyPos;
  int                        nComLen;
  SOCK                       eReturn = SOCK_WAIT;

#if defined _DEBUG
  if (nLength > 0)
  {
    REPORTVAR ("Receiving... (%d)", nLength);
  }
#endif

  // Find the end of the line (if there is one)
  nPos = 0;
  boFound = FALSE;
  while ((nPos < nLength) && (!boFound))
  {
    if ((pcBuffer[nPos] == 0x0a) || (pcBuffer[nPos] == 0x0d))
    {
      boFound = TRUE;
    }
    nPos++;
  }

  if (boFound)
  {
    //Copy into the command buffer
    nComLen = MIN (((int)sizeof(gpcCommand) - 1), (nPos - 1));
    strncpy (gpcCommand, pcBuffer, nComLen);
    // Terminate the command
    gpcCommand[nComLen] = 0;

    // Remove trailing terminators
    if ((nPos < nLength) && ((pcBuffer[nPos] == 0x0a)
      || (pcBuffer[nPos] == 0x0d)))
    {
      nPos++;
    }

    // Reset the buffer start position
    *pnBufferStart = nLength - nPos;

    // Shift the contents of the buffer down
    if (nPos > 0)
    {
      nCopyPos = 0;
      while (nPos < nLength)
      {
        pcBuffer[nCopyPos] = pcBuffer[nPos];
        nPos++;
        nCopyPos++;
      }
    }

    eReturn = SOCK_RECEIVE;
    SetConnectStatus (CONNECTED_RECEIVING);
    switch (gpcCommand[0])
    {
      case '2':
        if (gpcCommand[3] == '-')
        {
          Log ("IN  : ", gpcCommand);
        }
        else
        {
          Log ("IN  : ", gpcCommand);
          eReturn = SOCK_OK;
        }
        break;
      case '3':
        Log ("IN  : ", gpcCommand);
        eReturn = SOCK_OK;
        break;
      case '4':
      case '5':
        Log ("IN  : ", gpcCommand);
        eReturn = SOCK_ERR;
        break;
      default:
        Log ("IN  : ", gpcCommand);
        break;
    }
  }
  else
  {
    // Make sure the next download extends the buffer
    *pnBufferStart = nLength;
    SetConnectStatus (CONNECTED_WAITING);
  }

  return eReturn;
}

//////////////////////////////////////////////////////////////////
// Handles authorization state
STATE SMTPAuthorization (socket_s * psSocket)
{
  STATE                      eNextState = STATE_SMTP_AUTHORIZATION;
  SOCK                       eReturnRead;
  SOCK                       eReturnSend;
  char                       szCommand[COMMAND_LEN];
  char                       szEncode[COMMAND_LEN];
  int                        nBase64Size;
  int                        nEncodeSize;
  int                        nKeySize;
  char                       acDigest[16];
  int                        nPos;

  eReturnRead = SMTPSocketRead (psSocket);
  eReturnSend = SendCommandUpdate ();

  switch (geAuthState)
  {
    case AUTHSTATE_NOSENT:
      if (eReturnRead == SOCK_OK)
      {
        if (gasAccount[gnAccount].eSMTPAuth == SMTPAUTH_NONE)
        {
          sprintf (szCommand, "HELO %s", gszServer);
        }
        else
        {
          sprintf (szCommand, "EHLO %s", gszServer);
        }
        ResetTimeout (SMTP_START_TIMEOUT);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        gboSMTPAuthLOGIN = FALSE;
        gboSMTPAuthPLAIN = FALSE;
        gboSMTPAuthCRAMMD5 = FALSE;
        geAuthState = AUTHSTATE_HELOSENT;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_HELOSENT:
      if (eReturnSend == SOCK_OK)
      {
        if ((eReturnRead == SOCK_RECEIVE) || (eReturnRead == SOCK_OK))
        {
          if (strlen (gpcCommand) > 9)
          {
            if ((strncmp (gpcCommand + 4, "AUTH ", 5) == 0)
              || (strncmp (gpcCommand + 4, "AUTH=", 5) == 0))
            {
              if (strstr (gpcCommand + 8, "LOGIN"))
              {
                gboSMTPAuthLOGIN = TRUE;
                Log ("      ", "LOGIN allowed");
              }
              if (strstr (gpcCommand + 8, "PLAIN"))
              {
                gboSMTPAuthPLAIN = TRUE;
                Log ("      ", "PLAIN allowed");
              }
              if (strstr (gpcCommand + 8, "CRAM-MD5"))
              {
                gboSMTPAuthCRAMMD5 = TRUE;
                Log ("      ", "CRAM-MD5 allowed");
              }
            }
          }
        }
        if (eReturnRead == SOCK_OK)
        {
          switch (gasAccount[gnAccount].eSMTPAuth)
          {
            default:
            case SMTPAUTH_NONE:
              ResetTimeout (SMTP_GENERIC_TIMEOUT);
              geSMTPTranState = SMTP_TRANSTATE_NOSENT;
              eNextState = STATE_SMTP_TRANSACTION;
              geAuthState = AUTHSTATE_NOSENT;
              break;
            case SMTPAUTH_LOGIN:
              if (gboSMTPAuthLOGIN)
              {
                geAuthState = AUTHSTATE_AUTHLOGIN;
              }
              else
              {
                strcpy (gpcCommand, Tag("Er37"));
                Cancel ();
                eNextState = STATE_CANCEL;
              }
              break;
            case SMTPAUTH_PLAIN:
              if (gboSMTPAuthPLAIN)
              {
                geAuthState = AUTHSTATE_AUTHPLAIN;
              }
              else
              {
                strcpy (gpcCommand, Tag("Er38"));
                Cancel ();
                eNextState = STATE_CANCEL;
              }
              break;
            case SMTPAUTH_CRAMMD5:
              if (gboSMTPAuthCRAMMD5)
              {
                geAuthState = AUTHSTATE_AUTHCRAMMD5;
              }
              else
              {
                strcpy (gpcCommand, Tag("Er39"));
                Cancel ();
                eNextState = STATE_CANCEL;
              }
              break;
          }
        }
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_AUTHLOGIN:
      if (eReturnSend == SOCK_OK)
      {
        strcpy (szCommand, "AUTH LOGIN");
        ResetTimeout (SMTP_GENERIC_TIMEOUT);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        geAuthState = AUTHSTATE_AUTHLOGINSENT;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_AUTHLOGINSENT:
      if ((eReturnSend == SOCK_OK) && (eReturnRead == SOCK_OK))
      {
        // Send the username
        if (gasAccount[gnAccount].boSMTPUsePOP3Details)
        {
          strcpy (szEncode, gasAccount[gnAccount].szPOP3Username);
        }
        else
        {
          strcpy (szEncode, gasAccount[gnAccount].szSMTPUsername);
        }
        // Base64 encode the username
        nBase64Size = sizeof (szCommand);
        EncodeBase64 (szEncode, strlen (szEncode), szCommand, & nBase64Size);
        szCommand[nBase64Size] = 0;

        Log ("OUT : ", "<Username>");
        eReturnSend = SendCommandStart (szCommand, psSocket);
        geAuthState = AUTHSTATE_AUTHLOGINUSERSENT;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_AUTHLOGINUSERSENT:
      if ((eReturnSend == SOCK_OK) && (eReturnRead == SOCK_OK))
      {
        // Send the password
        if (gasAccount[gnAccount].boSMTPUsePOP3Details)
        {
          strcpy (szEncode, gasAccount[gnAccount].szPOP3Password);
        }
        else
        {
          strcpy (szEncode, gasAccount[gnAccount].szSMTPPassword);
        }
        // Base64 encode the password
        nBase64Size = sizeof (szCommand);
        EncodeBase64 (szEncode, strlen (szEncode), szCommand, & nBase64Size);
        szCommand[nBase64Size] = 0;

        Log ("OUT : ", "<Password>");
        eReturnSend = SendCommandStart (szCommand, psSocket);
        geAuthState = AUTHSTATE_AUTHDONE;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_AUTHPLAIN:
      if (eReturnSend == SOCK_OK)
      {
        strcpy (szCommand, "AUTH PLAIN ");

        szEncode[0] = 0;
        nEncodeSize = 1;
        // Username
        if (gasAccount[gnAccount].boSMTPUsePOP3Details)
        {
          strcpy (szEncode + nEncodeSize,
            gasAccount[gnAccount].szPOP3Username);
          nEncodeSize += strlen (gasAccount[gnAccount].szPOP3Username);
        }
        else
        {
          strcpy (szEncode + nEncodeSize,
            gasAccount[gnAccount].szSMTPUsername);
          nEncodeSize += strlen (gasAccount[gnAccount].szSMTPUsername);
        }
        szEncode[nEncodeSize] = 0;
        nEncodeSize++;

        // Password
        if (gasAccount[gnAccount].boSMTPUsePOP3Details)
        {
          strcpy (szEncode + nEncodeSize,
            gasAccount[gnAccount].szPOP3Password);
          nEncodeSize += strlen (gasAccount[gnAccount].szPOP3Password);
        }
        else
        {
          strcpy (szEncode + nEncodeSize,
            gasAccount[gnAccount].szSMTPPassword);
          nEncodeSize += strlen (gasAccount[gnAccount].szSMTPPassword);
        }
        szEncode[nEncodeSize] = 0;

        nBase64Size = sizeof (szCommand) - 11;
        EncodeBase64 (szEncode, nEncodeSize, szCommand + 11, & nBase64Size);
        (szCommand + 11)[nBase64Size] = 0;

        ResetTimeout (SMTP_GENERIC_TIMEOUT);
        Log ("OUT : ", "AUTH PLAIN <Username Password>");
        eReturnSend = SendCommandStart (szCommand, psSocket);
        geAuthState = AUTHSTATE_AUTHDONE;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;

    case AUTHSTATE_AUTHCRAMMD5:
      if (eReturnSend == SOCK_OK)
      {
        strcpy (szCommand, "AUTH CRAM-MD5");
        ResetTimeout (SMTP_GENERIC_TIMEOUT);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        geAuthState = AUTHSTATE_AUTHCRAMMD5SENT;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    case AUTHSTATE_AUTHCRAMMD5SENT:
      if (eReturnSend == SOCK_OK)
      {
        if (eReturnRead == SOCK_OK)
        {
          // Get the challenge
          if (strlen (gpcCommand) > 4)
          {
            nKeySize = sizeof (szCommand);
            DecodeBase64 (gpcCommand + 4, strlen (gpcCommand + 4), szCommand,
              & nKeySize);
            szCommand[nKeySize] = 0;
          }
          else
          {
            ShowWarningTag ("Er40");
            szCommand[0] = 0;
            nKeySize = 0;
          }

          // Add the username
          if (gasAccount[gnAccount].boSMTPUsePOP3Details)
          {
            strcpy (szEncode, gasAccount[gnAccount].szPOP3Username);
            nEncodeSize = strlen (gasAccount[gnAccount].szPOP3Username);
          }
          else
          {
            strcpy (szEncode, gasAccount[gnAccount].szSMTPUsername);
            nEncodeSize = strlen (gasAccount[gnAccount].szSMTPUsername);
          }
          szEncode[nEncodeSize] = ' ';
          nEncodeSize++;
          szEncode[nEncodeSize] = 0;

          // Calculate the digest (into szEncode)
          if (gasAccount[gnAccount].boSMTPUsePOP3Details)
          {
            EncodeHMACMD5 (szCommand, nKeySize,
              gasAccount[gnAccount].szPOP3Password,
              strlen (gasAccount[gnAccount].szPOP3Password),
              acDigest);
          }
          else
          {
            EncodeHMACMD5 (szCommand, nKeySize,
              gasAccount[gnAccount].szSMTPPassword,
              strlen (gasAccount[gnAccount].szSMTPPassword),
              acDigest);
          }

          // Transfer the digest
          for (nPos = 0; nPos < 16; nPos++)
          {
            szEncode[nEncodeSize++]
              = gacBase16[((acDigest[nPos] >> 4) & 0x0f)];
            szEncode[nEncodeSize++]
              = gacBase16[((acDigest[nPos]) & 0x0f)];
          }
          szEncode[nEncodeSize] = 0;

          // Create respone (Username digest)
          nBase64Size = sizeof (szCommand);
          EncodeBase64 (szEncode, nEncodeSize, szCommand, & nBase64Size);
          szCommand[nBase64Size] = 0;

          Log ("OUT : ", "<Username Password>");
          eReturnSend = SendCommandStart (szCommand, psSocket);
          geAuthState = AUTHSTATE_AUTHDONE;
        }
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;

    case AUTHSTATE_AUTHDONE:
      if ((eReturnSend == SOCK_OK) && (eReturnRead == SOCK_OK))
      {
        ResetTimeout (SMTP_GENERIC_TIMEOUT);
        geSMTPTranState = SMTP_TRANSTATE_NOSENT;
        eNextState = STATE_SMTP_TRANSACTION;
        geAuthState = AUTHSTATE_NOSENT;
      }
      if ((eReturnSend == SOCK_FAIL) || (eReturnRead == SOCK_ERR))
      {
        ShowWarningTagArg ("Er10", gpcCommand);
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        eNextState = STATE_CANCEL;
      }
      break;
    default:
      REPORT ("Invalid authorization state\n");
      break;
  }
  return eNextState;
}

//////////////////////////////////////////////////////////////////
// SMTP sending and receiving
void SMTPSocketReadSend (socket_s * psSocket, SOCK * peRead, SOCK * peSend)
{
  SOCK                       eReturnRead;
  SOCK                       eReturnSend;

  os_error                   *psError;
//  STATE                      eNextState;
  socket_fdset               sRead;
  socket_fdset               sWrite;
  socket_fdset               sExcept;
  int                        nFound;
  socket_timeval             sTimeVal;

 eReturnRead = SOCK_WAIT;
 eReturnSend = SOCK_WAIT;

  FD_ZERO (& sRead);
  FD_ZERO (& sWrite);
  FD_ZERO (& sExcept);

  FD_SET ((unsigned int)(*psSocket), (fd_set*)(& sRead));
  FD_SET ((unsigned int)(*psSocket), (fd_set*)(& sWrite));
  FD_SET ((unsigned int)(*psSocket), (fd_set*)(& sExcept));

  sTimeVal.sec = 0;
  sTimeVal.usec = 0;

  psError = xsocket_select (((unsigned int)*psSocket) + 1, & sRead, & sWrite,
    & sExcept, & sTimeVal, & nFound);

//  eNextState = STATE_CONNECTING;
  if (psError)
  {
    REPORTVAR ("Error %d", psError->errnum);
    err (psError);
    Cancel ();
//    eNextState = STATE_CANCEL;
  }
  else
  {
    if (FD_ISSET ((unsigned int)(*psSocket), (fd_set*)(& sRead)))
    {
      REPORT ("Found on Read");
      eReturnRead = SMTPSocketRead (psSocket);
    }
    if (FD_ISSET ((unsigned int)(*psSocket), (fd_set*)(& sWrite)))
    {
      REPORT ("Found on Write");
      eReturnSend = SendCommandUpdate ();
    }
    if (FD_ISSET ((unsigned int)(*psSocket), (fd_set*)(& sExcept)))
    {
      REPORT ("Found on Except");
    }

#if defined _DEBUG
    if (nFound > 0)
    {
      REPORTVAR ("Pre-found %d", nFound);
      if ((FD_ISSET ((unsigned int)(*psSocket), (fd_set*)(& sRead)))
        || (FD_ISSET ((unsigned int)(*psSocket), (fd_set*)(& sWrite))))
//      if (FD_ISSET ((unsigned int)(*psSocket), (fd_set*)(& sWrite)))
      {
        REPORTVAR ("Found %d", nFound);
//        eNextState = STATE_CONNECTED;
//        geAuthState = AUTHSTATE_NOSENT;
//        geQuitState = QUITSTATE_QUIT;
      }
    }
#endif
  }






  *peRead = eReturnRead;
  *peSend = eReturnSend;
}

//////////////////////////////////////////////////////////////////
// Handles transaction state
STATE SMTPTransaction (socket_s * psSocket)
{
  STATE                      eNextState = STATE_SMTP_TRANSACTION;
  SOCK                       eReturnRead;
  SOCK                       eReturnSend;
  char                       szCommand[COMMAND_LEN];

//  eReturnRead = SMTPSocketRead (psSocket);
//  eReturnSend = SendCommandUpdate ();

  SMTPSocketReadSend (psSocket, & eReturnRead, & eReturnSend);

  switch (geSMTPTranState)
  {
    case SMTP_TRANSTATE_NOSENT:
      switch (geNetCom)
      {
        case NET_SMTP_SEND:
          // Send mail
          geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
          gnRETRActPos = 0;
          break;
        default:
          gePOP3TranState = SMTP_TRANSTATE_DONE;
          break;
      }
      break;
    case SMTP_TRANSTATE_NEXTMAIL:
      if (eReturnSend == SOCK_OK)
      {
        // Send MAIL command
        if (gnMAILActPos < gnMAILActNum)
        {
          gnCurrentMsg = ganMAILAct[gnMAILActPos];
          ParseAddresses (gnCurrentMsg);
          gnToAddressPos = gnAllAddressNum - 1;
          sprintf (szCommand, "MAIL FROM:<%s>",
            gasAccount[gnAccount].szEmailAddress);
          Log ("OUT : ", szCommand);
          eReturnSend = SendCommandStart (szCommand, psSocket);
          ResetTimeout (SMTP_MAIL_TIMEOUT);
          geSMTPTranState = SMTP_TRANSTATE_MAILSENT;
        }
        else
        {
          geSMTPTranState = SMTP_TRANSTATE_DONE;
        }
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        SMTPMailSendFail (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        geSMTPTranState = SMTP_TRANSTATE_DONE;
      }
      break;
    case SMTP_TRANSTATE_MAILSENT:
      if ((eReturnSend == SOCK_OK) && (eReturnRead == SOCK_OK))
      {
        geSMTPTranState = SMTP_TRANSTATE_RCPT;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        SMTPMailSendFail (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        geSMTPTranState = SMTP_TRANSTATE_DONE;
      }
      break;
    case SMTP_TRANSTATE_RCPT:
      if (eReturnSend == SOCK_OK)
      {
        sprintf (szCommand, "RCPT TO:<%s>",gaszToAddress[gnToAddressPos]);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_RCPT_TIMEOUT);
        geSMTPTranState = SMTP_TRANSTATE_RCPTSENT;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        SMTPMailSendFail (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        geSMTPTranState = SMTP_TRANSTATE_DONE;
      }
      break;
    case SMTP_TRANSTATE_RCPTSENT:
      if ((eReturnSend == SOCK_OK) &&
        ((eReturnRead == SOCK_OK) || (eReturnRead == SOCK_ERR)))
      {
        gnToAddressPos--;
        if (gnToAddressPos >= 0)
        {
          geSMTPTranState = SMTP_TRANSTATE_RCPT;
        }
        else
        {
          geSMTPTranState = SMTP_TRANSTATE_DATA;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        SMTPMailSendFail (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        geSMTPTranState = SMTP_TRANSTATE_DONE;
      }
      break;
    case SMTP_TRANSTATE_DATA:
      if (eReturnSend == SOCK_OK)
      {
        Log ("OUT : ", "DATA");
        eReturnSend = SendCommandStart ("DATA", psSocket);
        ResetTimeout (SMTP_DATA_TIMEOUT);
        geSMTPTranState = SMTP_TRANSTATE_DATASENT;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        SMTPMailSendFail (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        geSMTPTranState = SMTP_TRANSTATE_DONE;
      }
      break;
    case SMTP_TRANSTATE_DATASENT:
      if ((eReturnSend == SOCK_OK) && (eReturnRead == SOCK_OK))
      {
        geSMTPSendTextState = SMTP_SENDTEXT_HEADERFROM;
        geSMTPTranState = SMTP_TRANSTATE_TEXT;
      }
      if ((eReturnRead == SOCK_ERR) || (eReturnSend == SOCK_FAIL))
      {
        SMTPMailSendFail (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        geSMTPTranState = SMTP_TRANSTATE_DONE;
      }
      break;
    case SMTP_TRANSTATE_TEXT:
      if (eReturnSend != SOCK_WAIT)
      {
#if defined MAX_SEND_LEN
        if (gboFastSending)
        {
          do
          {
            geSMTPTranState = SMTPSendText (psSocket, eReturnSend);
            eReturnSend = SendCommandUpdate ();
          } while ((eReturnSend == SOCK_OK)
              && (geSMTPTranState == SMTP_TRANSTATE_TEXT));
          REPORTVAR ("Still sending %d", gnSendCommandLen);
        }
        else
        {
          geSMTPTranState = SMTPSendText (psSocket, eReturnSend);
          eReturnSend = SendCommandUpdate ();
        }
#else
        geSMTPTranState = SMTPSendText (psSocket, eReturnSend);
        eReturnSend = SendCommandUpdate ();
#endif
      }
      break;
    case SMTP_TRANSSTATE_TEXTSENT:
      if (eReturnRead == SOCK_OK)
      {
        // Destroy email
        SMTPMailSendSuccess (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_ERR)
      {
        SMTPMailSendFail (gnCurrentMsg);
        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
      }
      if (eReturnRead == SOCK_FAIL)
      {
        Cancel ();
        geSMTPTranState = SMTP_TRANSTATE_DONE;
      }
//#if defined _DEBUG
//      static int             gnSendPrintTime;
//      int                    nKey;
//
//      if (gnMonotonicTime > gnSendPrintTime)
//      {
//        gnSendPrintTime = gnMonotonicTime + 50;
//        REPORT ("SMTP_TRANSSTATE_TEXTSENT");
//      }
//
//      xosbyte1 (osbyte_SCAN_KEYBOARD, (0x67 ^ 0x80), 0, & nKey); // Fullstop
//      if (nKey == 0xff)
//      {
//        REPORT ("Key pressed");
//        // Wait for release of key
//        while (nKey == 0xff)
//        {
//          xosbyte1 (osbyte_SCAN_KEYBOARD, (0x67 ^ 0x80), 0, & nKey);
//        }
//        SMTPMailSendSuccess (gnCurrentMsg);
//        geSMTPTranState = SMTP_TRANSTATE_NEXTMAIL;
//        REPORT ("Moving on.");
////        Log ("OUT : ", ".");
////        eReturnSend = SendCommandStart (".", psSocket);
//      }
//#endif
      break;
    case SMTP_TRANSTATE_DONE:
      geSMTPTranState = SMTP_TRANSTATE_NOSENT;
      eNextState = STATE_SMTP_QUIT;
      break;
    default:
      REPORT ("Invalid SMTP transaction state\n");
      break;
  }

  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Finish off the SMTP transaction
STATE SMTPQuit (socket_s * psSocket)
{
  STATE                      eNextState = STATE_SMTP_QUIT;
  SOCK                       eReturnRead;
  SOCK                       eReturnSend;

  eReturnRead = SMTPSocketRead (psSocket);
  eReturnSend = SendCommandUpdate ();

  switch (geQuitState)
  {
    case QUITSTATE_QUIT:
      if (eReturnSend == SOCK_OK)
      {
        Log ("OUT : ", "QUIT");
        eReturnSend = SendCommandStart ("QUIT", & gsSocket);
        ResetTimeout (TERMINATION_TIMEOUT);
        geQuitState = QUITSTATE_QUITSENT;
      }
      break;
    case QUITSTATE_QUITSENT:
      if ((eReturnSend == SOCK_OK) || (eReturnSend == SOCK_FAIL))
      {
        if ((eReturnRead == SOCK_OK) || (eReturnRead == SOCK_ERR)
          || (eReturnRead == SOCK_FAIL))
        {
          geQuitState = QUITSTATE_INVALID;
          eNextState = STATE_FINISHED;
        }
      }
      break;
    default:
      REPORT ("Invalid SMTP quit state\n");
      break;
  }

  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Sends the header and email text
SMTP_TRANSTATE SMTPSendText (socket_s * psSocket, SOCK eReturnSend)
{
  SMTP_TRANSTATE             eNextState = SMTP_TRANSTATE_TEXT;
  char                       szBuffer[COMMAND_LEN + 1];
  char                       *szCommand;
  oswordreadclock_utc_block  sUtc;
  int                        nLength;
  os_date_and_time           *psDateAndTime;
//  SOCK                       eReturnSend;
  char                       szTimeZone[10];
  int                        nTimeOffset;
  char                       szVersion[6];
  int                        nCount;

  szBuffer[0] = '.';
  szCommand = szBuffer + 1;

//  eReturnSend = SendCommandUpdate ();

  // Send the header, then the text of the email, then a '.'
  switch (geSMTPSendTextState)
  {
    case SMTP_SENDTEXT_HEADERFROM:
      if (eReturnSend == SOCK_OK)
      {
        sprintf (szCommand, "From: %s <%s>", gasAccount[gnAccount].szName,
          gasAccount[gnAccount].szEmailAddress);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        gnToAddressPos = 0;
        geSMTPSendTextState = SMTP_SENDTEXT_HEADERTO;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADERTO:
      if (eReturnSend == SOCK_OK)
      {
        if (gnToAddressPos < gnToAddressNum)
        {
          if (gnToAddressPos == 0)
          {
            sprintf (szCommand, "To: <%s>",
              gaszToAddress[gnToAddressPos]);
          }
          else
          {
            sprintf (szCommand, "	<%s>",
              gaszToAddress[gnToAddressPos]);
          }
          Log ("OUT : ", szCommand);
          eReturnSend = SendCommandStart (szCommand, psSocket);
          ResetTimeout (SMTP_BLOCK_TIMEOUT);
          gnToAddressPos++;
        }
        else
        {
          geSMTPSendTextState = SMTP_SENDTEXT_HEADERCC;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADERCC:
      if (eReturnSend == SOCK_OK)
      {
        if (gnToAddressPos < gnCCAddressNum)
        {
          if (gnToAddressPos == gnToAddressNum)
          {
            sprintf (szCommand, "Cc: <%s>",
              gaszToAddress[gnToAddressPos]);
          }
          else
          {
            sprintf (szCommand, "	<%s>",
              gaszToAddress[gnToAddressPos]);
          }
          Log ("OUT : ", szCommand);
          eReturnSend = SendCommandStart (szCommand, psSocket);
          ResetTimeout (SMTP_BLOCK_TIMEOUT);
          gnToAddressPos++;
        }
        else
        {
          geSMTPSendTextState = SMTP_SENDTEXT_HEADERSUBJECT;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADERSUBJECT:
      if (eReturnSend == SOCK_OK)
      {
        sprintf (szCommand, "Subject: %s",
          GetIconText (gasEdit[gnCurrentMsg].whHead, (wimp_i)1));
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        geSMTPSendTextState = SMTP_SENDTEXT_HEADERDATE;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADERDATE:
      if (eReturnSend == SOCK_OK)
      {
        sUtc.op = oswordreadclock_OP_UTC;
        xoswordreadclock_utc (& sUtc);
        sprintf (szCommand, "Date: ");
        psDateAndTime = & (sUtc.utc);
        xterritory_convert_date_and_time (territory_CURRENT,
          (os_date_and_time const*)psDateAndTime,
          szCommand + 6, (sizeof (szBuffer) - 1 - 6),
          "%W3, %DY %M3 %CE%YR %24:%MI:%SE", NULL);

        xterritory_read_current_time_zone (NULL, & nTimeOffset);
        nTimeOffset = (nTimeOffset + 3000) / 6000;
        if (nTimeOffset < 0)
        {
          nTimeOffset = -nTimeOffset;
          sprintf (szTimeZone, " -%02d%20d", (nTimeOffset / 60),
            nTimeOffset % 60);
        }
        else
        {
          sprintf (szTimeZone, " +%02d%02d", (nTimeOffset / 60),
            nTimeOffset % 60);
        }
        strncat (szCommand, szTimeZone, (sizeof (szBuffer) - 1));

        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        geSMTPSendTextState = SMTP_SENDTEXT_HEADERUSERAGENT;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADERUSERAGENT:
      if (eReturnSend == SOCK_OK)
      {
        GetOSVersion (szVersion, sizeof (szVersion));
        sprintf (szCommand, "User-Agent: %s/%s (RISC-OS/%s)", Tag("Tsk"),
          VERSION_STRING_SHORT, szVersion);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        if (gasEdit[gnCurrentMsg].nMIMEListNum > 0)
        {
          // Add the MIME headers
          geSMTPSendTextState = SMTP_SENDTEXT_HEADERMIME;
        }
        else
        {
          // Skip all of the MIME headers (including this one)
          geSMTPSendTextState = SMTP_SENDTEXT_HEADEREND;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADERMIME:
      if (eReturnSend == SOCK_OK)
      {
        // Set up the boundary
        srand (gnMonotonicTime);
        for (nCount = 0; nCount < (MIME_BOUNDARY_LEN - 1); nCount++)
        {
          gszMIMEBoundary[nCount] = gacBoundaryCharList[(rand () % 64)];
        }
        gszMIMEBoundary[(MIME_BOUNDARY_LEN - 1)] = 0;
        gszMIMEBoundary[9] = '=';
        gszMIMEBoundary[10] = '_';
        gszMIMEBoundary[21] = '-';
        gszMIMEBoundary[22] = '-';

        // Send the MIME header line
        strncpy (szCommand, "MIME-Version: 1.0", COMMAND_LEN);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        geSMTPSendTextState = SMTP_SENDTEXT_HEADERCONTENTTYPE;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADERCONTENTTYPE:
      if (eReturnSend == SOCK_OK)
      {
        sprintf (szCommand, "Content-Type: multipart/mixed; boundary=\"%s\"",
          gszMIMEBoundary);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        geSMTPSendTextState = SMTP_SENDTEXT_HEADEREND;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_HEADEREND:
      if (eReturnSend == SOCK_OK)
      {
        szCommand[0] = 0;
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        gnMAILActLine = 0;
        if (gasEdit[gnCurrentMsg].nMIMEListNum > 0)
        {
          // Add the MIME support message
          geSMTPSendTextState = SMTP_SENDTEXT_MIMESUPPORT;
        }
        else
        {
          // Skip the MIME support message and go straight to the email
          geSMTPSendTextState = SMTP_SENDTEXT_EMAILTEXT;
          Log ("OUT : ","Going to email text");
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_MIMESUPPORT:
      if (eReturnSend == SOCK_OK)
      {
        if (gnMAILActLine < MIME_SUPPORT_LINES)
        {
          sprintf (szCommand, "Mime%02d", gnMAILActLine);
          eReturnSend = SendCommandStart (Tag(szCommand), psSocket);
          ResetTimeout (SMTP_BLOCK_TIMEOUT);
          gnMAILActLine++;
        }
        if (gnMAILActLine >= MIME_SUPPORT_LINES)
        {
          geSMTPSendTextState = SMTP_SENDTEXT_MIMESUPPORTEND;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_MIMESUPPORTEND:
      if (eReturnSend == SOCK_OK)
      {
        szCommand[0] = 0;
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        gnMAILActLine = 0;
        geSMTPSendTextState = SMTP_SENDTEXT_EMAILBOUNDARY;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_EMAILBOUNDARY:
      if (eReturnSend == SOCK_OK)
      {
        sprintf (szCommand, "--%s", gszMIMEBoundary);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        geSMTPSendTextState = SMTP_SENDTEXT_EMAILCONTENTTYPE;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_EMAILCONTENTTYPE:
      if (eReturnSend == SOCK_OK)
      {
        strncpy (szCommand, "Content-Type: text/plain; charset=us-ascii",
          COMMAND_LEN);
        Log ("OUT : ", szCommand);
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        geSMTPSendTextState = SMTP_SENDTEXT_EMAILHEADEREND;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_EMAILHEADEREND:
      if (eReturnSend == SOCK_OK)
      {
        szCommand[0] = 0;
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        geSMTPSendTextState = SMTP_SENDTEXT_EMAILTEXT;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      break;
    case SMTP_SENDTEXT_EMAILTEXT:
      if ((eReturnSend == SOCK_OK)
        && (gnMAILActLine < gasEdit[gnCurrentMsg].nLineMax))
      {
        nLength = (gasEdit[gnCurrentMsg].anLine[gnMAILActLine + 1]
          - gasEdit[gnCurrentMsg].anLine[gnMAILActLine]);
        if (nLength > ((int)sizeof (szBuffer) - 1))
        {
          nLength = ((int)sizeof (szBuffer) - 1);
        }
        strncpy (szCommand, gasEdit[gnCurrentMsg].szRawEmail +
          gasEdit[gnCurrentMsg].anLine[gnMAILActLine], nLength);
        szCommand[nLength - 1] = 0;
        Log ("OUT : ", szCommand);
        if (szCommand[0] == '.')
        {
          // Add an additional '.'
          eReturnSend = SendCommandStart (szBuffer, psSocket);
        }
        else
        {
          eReturnSend = SendCommandStart (szCommand, psSocket);
        }
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        gnMAILActLine++;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
      }
      if (eReturnSend == SOCK_OK)
      {
        if (gnMAILActLine >= gasEdit[gnCurrentMsg].nLineMax)
        {
          geSMTPAttachmentsState = SMTP_ATTACHMENTS_START;
          if (gasEdit[gnCurrentMsg].nMIMEListNum > 0)
          {
            // Add the base64 encoded MIME attachments
            geSMTPSendTextState = SMTP_SENDTEXT_ATTACHMENTS;
          }
          else
          {
            // There are no attachments, so we're done
            geSMTPSendTextState = SMTP_SENDTEXT_FINISH;
          }
        }
      }
      break;
    case SMTP_SENDTEXT_ATTACHMENTS:
      if (eReturnSend == SOCK_OK)
      {
        geSMTPSendTextState = SMTPSendAttachments (psSocket, eReturnSend);
      }
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPSendTextState = SMTP_SENDTEXT_FAILED;
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_INVALID;
      }
      break;


    case SMTP_SENDTEXT_FINISH:
      REPORT ("SMTP_SENDTEXT_FINISH");
      gnSMTPPause = gnMonotonicTime + SMTP_DATAEND_DELAY;
      geSMTPSendTextState = SMTP_SENDTEXT_FINISHPAUSE;
      break;

    case SMTP_SENDTEXT_FINISHPAUSE:
//      if ((gnMonotonicTime > gnSMTPPause) && (eReturnSend != SOCK_WAIT))
      {
        REPORT ("SMTP_SENDTEXT_FINISHPAUSE");
        geSMTPSendTextState = SMTP_SENDTEXT_DATAEND;
      }
      break;

    case SMTP_SENDTEXT_DATAEND:
      if (eReturnSend == SOCK_OK)
      {
        Log ("OUT : ", ".");
        eReturnSend = SendCommandStart (".", psSocket);

        ResetTimeout (SMTP_TERMINATION_TIMEOUT);
        if (eReturnSend == SOCK_OK)
        {
          eNextState = SMTP_TRANSSTATE_TEXTSENT;
          geSMTPSendTextState = SMTP_SENDTEXT_INVALID;
        }
        else
        {
          geSMTPSendTextState = SMTP_SENDTEXT_FINISHED;
        }
      }
      if (eReturnSend == SOCK_FAIL)
      {
        SMTPMailSendFail (gnCurrentMsg);
      }
      REPORT ("SMTP_SENDTEXT_DATAEND");
      break;
    case SMTP_SENDTEXT_FINISHED:
      if (eReturnSend == SOCK_OK)
      {
        eNextState = SMTP_TRANSSTATE_TEXTSENT;
        geSMTPSendTextState = SMTP_SENDTEXT_INVALID;
      }
      if (eReturnSend == SOCK_FAIL)
      {
        SMTPMailSendFail (gnCurrentMsg);
      }
      REPORT ("SMTP_SENDTEXT_FINISHED");
      break;
    case SMTP_SENDTEXT_FAILED:
      SMTPMailSendFail (gnCurrentMsg);
      geSMTPSendTextState = SMTP_SENDTEXT_FINISH;
      REPORT ("SMTP_SENDTEXT_FAILED");
      break;
    default:
      REPORT ("Send text state undefined");
      break;
  }
  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Send the attachments to an email
SMTP_SENDTEXT SMTPSendAttachments (socket_s * psSocket, SOCK eReturnSend)
{
  SMTP_SENDTEXT              eNextState = SMTP_SENDTEXT_ATTACHMENTS;
  char                       szCommand[COMMAND_LEN];
//  SOCK                       eReturnSend;
  int                        nEncodeSizeIn;
  int                        nEncodeSizeOut;
  char                       szContent[256];
  char                       szConverted[MIME_LEAFNAME_MAX];
  char                       szFileTypeName[256];

  switch (geSMTPAttachmentsState)
  {

    case SMTP_ATTACHMENTS_START:
      gnSMTPAttachmentsNum = 0;
      geSMTPAttachmentsState = SMTP_ATTACHMENTS_BOUNDARY;
      break;
    case SMTP_ATTACHMENTS_STARTATTACHMENT:
      if (gnSMTPAttachmentsNum < gasEdit[gnCurrentMsg].nMIMEListNum)
      {
        // This is the start of a new attachment
        szCommand[0] = 0;
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        if (eReturnSend == SOCK_FAIL)
        {
          geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
        }
        else
        {
          geSMTPAttachmentsState = SMTP_ATTACHMENTS_BOUNDARY;
        }
      }
      else
      {
        // There weren't any attachments after all!
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FINISH;
      }
      break;
    case SMTP_ATTACHMENTS_BOUNDARY:
      sprintf (szCommand, "--%s", gszMIMEBoundary);
      Log ("OUT : ", szCommand);
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_HEADERCONTENTTYPE;
      }
      break;
    case SMTP_ATTACHMENTS_HEADERCONTENTTYPE:
      xmimemaptranslate_filetype_to_mime_type (
        gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].nFileType,
        szContent);
      xmimemaptranslate_filetype_to_filetype_name (
        gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].nFileType,
        szFileTypeName);
      strncpy (szConverted, gasEdit[gnCurrentMsg].asAttachments
        [gnSMTPAttachmentsNum].szLeafName, MIME_LEAFNAME_MAX);
      ConvertFilenameFromRISCOS (szConverted);
      if (gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].
        boUseAttributes)
      {
        sprintf (szCommand, "Content-Type: %s; name=\"%s\"; type=%s;",
          szContent, szConverted, szFileTypeName);
      }
      else
      {
        sprintf (szCommand, "Content-Type: %s; name=\"%s\"; type=%s",
          szContent, szConverted, szFileTypeName);
      }
      Log ("OUT : ", szCommand);
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        if (gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].
          boUseAttributes)
        {
          geSMTPAttachmentsState
            = SMTP_ATTACHMENTS_HEADERCONTENTTYPEATTRIBUTES;
        }
        else
        {
          geSMTPAttachmentsState = SMTP_ATTACHMENTS_HEADERCONTENTDISPOSITION;
        }
      }
      break;
    case SMTP_ATTACHMENTS_HEADERCONTENTTYPEATTRIBUTES:
      sprintf (szCommand,
        "	load=&%08x; exec=&%08x; access=&%02x",
        gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].uLoad,
        gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].uExec,
        gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].uAccess);
      Log ("OUT : ", szCommand);
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_HEADERCONTENTDISPOSITION;
      }
      break;
    case SMTP_ATTACHMENTS_HEADERCONTENTDISPOSITION:
      strncpy (szConverted, gasEdit[gnCurrentMsg].asAttachments
        [gnSMTPAttachmentsNum].szLeafName, MIME_LEAFNAME_MAX);
      ConvertFilenameFromRISCOS (szConverted);
      sprintf (szCommand,
        "Content-Disposition: attachment; filename=\"%s\"", szConverted);
      Log ("OUT : ", szCommand);
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_HEADERCONTENTENCODING;
      }
      break;
    case SMTP_ATTACHMENTS_HEADERCONTENTENCODING:
      sprintf (szCommand, "Content-Transfer-Encoding: base64");
      Log ("OUT : ", szCommand);
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_HEADEREND;
      }
      break;
    case SMTP_ATTACHMENTS_HEADEREND:
      szCommand[0] = 0;
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        gnSMTPAttachmentsPos = 0;
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_DATA;
      }
      break;
    case SMTP_ATTACHMENTS_DATA:
      if (gnSMTPAttachmentsPos <
        gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].nFileSize)
      {
        nEncodeSizeIn = 51;
        if ((gasEdit[gnCurrentMsg].asAttachments[gnSMTPAttachmentsNum].
          nFileSize - gnSMTPAttachmentsPos) < nEncodeSizeIn)
        {
          nEncodeSizeIn = (gasEdit[gnCurrentMsg].asAttachments
            [gnSMTPAttachmentsNum].nFileSize - gnSMTPAttachmentsPos);
        }
        nEncodeSizeOut = COMMAND_LEN;
        EncodeBase64 (gasEdit[gnCurrentMsg].asAttachments
          [gnSMTPAttachmentsNum].pcFileStart + gnSMTPAttachmentsPos,
          nEncodeSizeIn, szCommand, & nEncodeSizeOut);
        szCommand[nEncodeSizeOut] = 0;
        eReturnSend = SendCommandStart (szCommand, psSocket);
        ResetTimeout (SMTP_BLOCK_TIMEOUT);
        if (eReturnSend == SOCK_FAIL)
        {
          geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
        }
        else
        {
          gnSMTPAttachmentsPos += nEncodeSizeIn;
          geSMTPAttachmentsState = SMTP_ATTACHMENTS_DATA;
        }
      }
      else
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_DATAEND;
      }
      break;
    case SMTP_ATTACHMENTS_DATAEND:
      gnSMTPAttachmentsNum++;
      if (gnSMTPAttachmentsNum < gasEdit[gnCurrentMsg].nMIMEListNum)
      {
        // More attachments
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_STARTATTACHMENT;
      }
      else
      {
        // No more attachments
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FINALGAP;
      }
      break;
    case SMTP_ATTACHMENTS_FINALGAP:
      szCommand[0] = 0;
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FINALBOUNDARY;
      }
      break;
    case SMTP_ATTACHMENTS_FINALBOUNDARY:
      sprintf (szCommand, "--%s--", gszMIMEBoundary);
      Log ("OUT : ", szCommand);
      eReturnSend = SendCommandStart (szCommand, psSocket);
      ResetTimeout (SMTP_BLOCK_TIMEOUT);
      if (eReturnSend == SOCK_FAIL)
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FAILED;
      }
      else
      {
        geSMTPAttachmentsState = SMTP_ATTACHMENTS_FINISH;
      }
      break;
    case SMTP_ATTACHMENTS_FAILED:
      eNextState = SMTP_SENDTEXT_FAILED;
      geSMTPAttachmentsState = SMTP_ATTACHMENTS_INVALID;
      break;
    case SMTP_ATTACHMENTS_FINISH:
      eNextState = SMTP_SENDTEXT_FINISH;
      geSMTPAttachmentsState = SMTP_ATTACHMENTS_INVALID;
      break;
    default:
      REPORT ("Send attachment state undefined");
      break;
  }
  return eNextState;
}

//////////////////////////////////////////////////////////////////
// Email was successfully sent - we can now destroy it
void SMTPMailSendSuccess (int nEditNum)
{
  ShiftMAILQueue ();
  DestroyEditWindow (nEditNum);
  Log ("", "Send successful");
}

//////////////////////////////////////////////////////////////////
// Email send failed - reopen it and report the error
void SMTPMailSendFail (int nEditNum)
{
  int                        nCount;

  ShiftMAILQueue ();
  OpenWindowInitPane (gasEdit[nEditNum].whWindow,
    gasEdit[nEditNum].whHead, PANE_TOP);

  // Add this to the list of email windows
  nCount = 0;
  while ((gawhEditOpen[nCount] != wimp_BACKGROUND)
    && (nCount < EDIT_MAX))
  {
    nCount++;
  }
  if (nCount < EDIT_MAX)
  {
    gawhEditOpen[nCount] = gasEdit[nEditNum].whWindow;
    ganEditOpen[nCount] = nEditNum;
  }

  // Report the error
  ShowWarningTagArg ("Er3", gpcCommand);
}

//////////////////////////////////////////////////////////////////
// Action on clicking on the 'send' button
void SendEmail (int nEditNum)
{
  char                       szTagName[5];
  char                       szTagName1[5];
  char                       szTagName2[5];
  int                        nTagCount;

//  if (gnRegistered == REGISTERED)
//  {
    AddToMAILQueue (nEditNum);
    CheckNetCom (NET_SMTP_SEND);

    // Close the window
    if (gasEdit[nEditNum].whWindow != wimp_BACKGROUND)
    {
      CloseWindowHandle (gasEdit[nEditNum].whWindow);
    }
    if (gasEdit[nEditNum].whHead != wimp_BACKGROUND)
    {
      CloseWindowHandle (gasEdit[nEditNum].whHead);
    }
//  }
//  else
//  {
//    szTagName1[0] = 'q' - 'E';
//    szTagName1[1] = 'z' - 'r';
//    szTagName1[2] = 'k' - '2';
//    szTagName1[3] = 'm' - '9';
//    szTagName1[4] = 0;
//    szTagName2[0] = 'q';
//    szTagName2[1] = 'z';
//    szTagName2[2] = 'k';
//    szTagName2[3] = 'm';
//    szTagName2[4] = 0;
//
//    for (nTagCount = 0; nTagCount < (int)sizeof (szTagName); nTagCount++)
//    {
//      szTagName[nTagCount] = szTagName2[nTagCount] - szTagName1[nTagCount];
//    }
//
//    ShowWarningTag (szTagName);
//  }
}




































//////////////////////////////////////////////////////////////////
// Resets the details array
void ResetDetails (void)
{
  int                        nLoop;

  for (nLoop = 0; nLoop < DETAILS_MAX; nLoop++)
  {
    gasDetails[nLoop].boSelected = FALSE;
    gasDetails[nLoop].nMsgNum = MESSAGE_INVALID;

//    if (nLoop < 10)
//    {
//      gasDetails[nLoop].nSize = nLoop * 1023;
//    }
//    else
//    {
    gasDetails[nLoop].nSize = -1;
    gasDetails[nLoop].nServerSize = -1;
//    }

    strncpy (gasDetails[nLoop].szSender, "", SENDER_MAX);
    strncpy (gasDetails[nLoop].szSenderDisplay, "", SENDER_MAX);
    strncpy (gasDetails[nLoop].szSubject, "", SUBJECT_MAX);
    gasDetails[nLoop].pcDate[0] = 0;
    gasDetails[nLoop].pcDate[1] = 0;
    gasDetails[nLoop].pcDate[2] = 0;
    gasDetails[nLoop].pcDate[3] = 0;
    gasDetails[nLoop].pcDate[4] = 0;
    gasDetails[nLoop].eState = DETAILS_NONE;
    gasDetails[nLoop].whWindow = wimp_BACKGROUND;
    gasDetails[nLoop].whHead = wimp_BACKGROUND;
    gasDetails[nLoop].szRawEmail = NULL;
    gasDetails[nLoop].szFormEmail = NULL;
    gasDetails[nLoop].nHeaderEndLine = 0;
    gasDetails[nLoop].nLineHide = 0;
    gasDetails[nLoop].anLine = NULL;
    gasDetails[nLoop].anRawLine = NULL;
    gasDetails[nLoop].nLineMax = 0;
    gasDetails[nLoop].boOpenOnLoad = FALSE;
    strncpy (gasDetails[nLoop].szUID, "", UID_MAX);
    gasDetails[nLoop].nSortPos = -1;
    gasDetails[nLoop].ihSenderIcon = 0;
    gasDetails[nLoop].ihSubjectIcon = 1;
    gasDetails[nLoop].eMailState = MAILSTATE_INVALID;
    gasDetails[nLoop].asMIMEList = NULL;
    gasDetails[nLoop].nMIMEListNum = 0;
    gasDetails[nLoop].szPreMIMEEmail = NULL;
    gasDetails[nLoop].nPreMIMESize = 0;
    strncpy (gasDetails[nLoop].szAttachNum, "0", ATTACH_NUM_TEXT_MAX);
    gasDetails[nLoop].ihAttNumIcon = 11;


    gawhEmailsOpen[nLoop] = wimp_BACKGROUND;
    ganEmailsOpen[nLoop] = EMAIL_INVALID;

    ganSort[nLoop] = EMAIL_INVALID;
  }
  ganSort[DETAILS_MAX] = EMAIL_INVALID;
  gawhEmailsOpen[DETAILS_MAX] = wimp_BACKGROUND;
  ganEmailsOpen[DETAILS_MAX] = EMAIL_INVALID;

  gnDetailsNum = 0;
}

//////////////////////////////////////////////////////////////////
// Place the addresses from the 'To:', 'CC:' and 'BCC' lines into an array
void ParseAddresses (int nEditNum)
{
  char                       *szTo;
  char                       *szCC;
  char                       *szBCC;
  int                        nPos;

  szTo = GetIconText (gasEdit[nEditNum].whHead, (wimp_i)0);
  szCC = GetIconText (gasEdit[nEditNum].whHead, (wimp_i)9);
  szBCC = GetIconText (gasEdit[nEditNum].whHead, (wimp_i)12);
  nPos = 0;

  nPos = AddressesToArray (szTo, nPos, ADDRESS_NUM_MAX);
  gnToAddressNum = nPos;
  nPos = AddressesToArray (szCC, nPos, ADDRESS_NUM_MAX);
  gnCCAddressNum = nPos;

  // Check to see if 'BCC to self' is set
  if (GetIconSelectionState (gasEdit[nEditNum].whHead, (wimp_i)13))
  {
    if (strlen(gasAccount[gnAccount].szBCCAddress) > 0)
    {
      nPos = AddressesToArray (gasAccount[gnAccount].szBCCAddress, nPos,
        ADDRESS_NUM_MAX);
    }
    else
    {
      nPos = AddressesToArray (gasAccount[gnAccount].szEmailAddress, nPos,
        ADDRESS_NUM_MAX);
    }
    gnBCCAddressNum = nPos;
  }

  nPos = AddressesToArray (szBCC, nPos, ADDRESS_NUM_MAX);
  gnBCCAddressNum = nPos;
  gnAllAddressNum = nPos;
}

//////////////////////////////////////////////////////////////////
// Parse the address string into an array
int AddressesToArray (char * szText, int nCount, int nMax)
{
  int                        nStart;
  int                        nEnd;
  int                        nLength;
  char                       szMax[5];

  nStart = 0;
  do
  {
    nEnd = nStart;
    while ((strchr (";, ", szText[nEnd]) == NULL) && (szText[nEnd] >= 0x20))
    {
      nEnd++;
    }

    nLength = nEnd - nStart;
    if (nLength > ADDRESS_LEN_MAX)
    {
      nLength = ADDRESS_LEN_MAX;
    }

    // Copy the address
    strncpy (gaszToAddress[nCount], szText + nStart, nLength);
    // Terminate the string
    gaszToAddress[nCount][nLength] = 0;

    if (nLength > 0)
    {
      nCount++;
    }

    nStart = nEnd;
    while ((strchr (";, ", szText[nStart]) != NULL)
      && (szText[nStart] >= 0x20))
    {
      nStart++;
    }
  } while ((szText[nStart] >= 0x20) && (nCount < nMax));

  if (nCount >= nMax)
  {
    sprintf (szMax, "%d", ADDRESS_NUM_MAX);
    ShowWarningTagArg ("Er32", szMax);
  }

  return nCount;
}



//////////////////////////////////////////////////////////////////
// See if any internet access is necessary or possible
void CheckNetCom (NET eNetCom)
{
  // Check for POP3 commands
  if (geNetCom == NET_INVALID)
  {
    if (eNetCom == NET_POP3_LIST)
    {
      geNetCom = NET_POP3_LIST;
      SetIconSprite ("amber", gwhMaHe, 0);
    }
    else
    {
      // Check for downloads
      if (gnRETRActNum > 0)
      {
        geNetCom = NET_POP3_DOWNLOAD;
        SetIconSprite ("amber", gwhMaHe, 0);
      }
      else
      {
        if (gnDELEActNum > 0)
        {
          geNetCom = NET_POP3_DELETE;
          SetIconSprite ("amber", gwhMaHe, 0);
        }
      }
    }
  }

  // Check for SMTP commands
  if ((geNetCom == NET_INVALID) || (eNetCom == NET_SMTP_SEND))
  {
    // Check for mail sends
    if (gnMAILActNum > 0)
    {
      geNetCom = NET_SMTP_SEND;
      SetIconSprite ("amber", gwhMaHe, 0);
    }
  }

  if (geNetCom != NET_INVALID)
  {
    SetNullPollActive (NULLPOLL_ACTIVE_NETWORK);
  }
  else
  {
    SetNullPollActive (NULLPOLL_DEACTIVE_NETWORK);
  }
}

//////////////////////////////////////////////////////////////////
// Add an email to the DELE queue
void AddToDELEQueue (int nEmailNum)
{
  int                        nCount;
  bool                       boDuplicate;

  if (gnDELEActNum < DETAILS_MAX)
  {
    // Check that it hasn't already been deleted
    if (gasDetails[nEmailNum].eState != DETAILS_DELETED)
    {
      // Check that it is not a duplicate
      boDuplicate = FALSE;
      for (nCount = 0; ((nCount < gnDELEActNum) && !boDuplicate); nCount++)
      {
        if (ganDELEAct[nCount] == nEmailNum)
        {
          boDuplicate = TRUE;
        }
      }

      if (!boDuplicate)
      {
        ganDELEAct[gnDELEActNum] = nEmailNum;
        gnDELEActNum++;

        gasDetails[nEmailNum].eMailState = MAILSTATE_DELETING;
        UpdateMain (nEmailNum, nEmailNum);
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Remove an email from the RETR queue and redraw
void ShiftDELEQueueRedraw (void)
{
  int                        nRedraw;

  if (gnDELEActNum > 0)
  {
    nRedraw = ganDELEAct[0];
    ShiftDELEQueue ();
    UpdateMain (nRedraw, nRedraw);
  }
}

//////////////////////////////////////////////////////////////////
// Remove an email from the RETR queue
void ShiftDELEQueue (void)
{
  int                        nCount;

  if (gnDELEActNum > 0)
  {
    if (gasDetails[ganDELEAct[0]].szRawEmail == NULL)
    {
      gasDetails[ganDELEAct[0]].eMailState = MAILSTATE_REMOTE;
    }
    else
    {
      gasDetails[ganDELEAct[0]].eMailState = MAILSTATE_LOCAL;
    }

    for (nCount = 1; nCount < (gnDELEActNum + 1); nCount++)
    {
      ganDELEAct[nCount - 1] = ganDELEAct[nCount];
    }
    gnDELEActNum--;
  }
}

//////////////////////////////////////////////////////////////////
// Add an email to the RETR queue
void AddToRETRQueue (int nEmailNum)
{
  int                        nCount;
  bool                       boDuplicate;

  if (gnRETRActNum < DETAILS_MAX)
  {
    // Check that it doesn't already have a body
    if (gasDetails[nEmailNum].szRawEmail == NULL)
    {
      // Check that it is not a duplicate
      boDuplicate = FALSE;
      for (nCount = 0; ((nCount < gnRETRActNum) && !boDuplicate); nCount++)
      {
        if (ganRETRAct[nCount] == nEmailNum)
        {
          boDuplicate = TRUE;
        }
      }

      if (!boDuplicate)
      {
        ganRETRAct[gnRETRActNum] = nEmailNum;
        gnRETRActNum++;

        gasDetails[nEmailNum].eMailState = MAILSTATE_GETTING;
        UpdateMain (nEmailNum, nEmailNum);
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Remove an email from the RETR queue
void ShiftRETRQueue (void)
{
  int                        nCount;

  if (gnRETRActNum > 0)
  {
    if (gasDetails[ganRETRAct[0]].szRawEmail == NULL)
    {
      gasDetails[ganRETRAct[0]].eMailState = MAILSTATE_REMOTE;
    }
    else
    {
      gasDetails[ganRETRAct[0]].eMailState = MAILSTATE_LOCAL;
    }
    UpdateMain (ganRETRAct[0], ganRETRAct[0]);

    for (nCount = 1; nCount < (gnRETRActNum + 1); nCount++)
    {
      ganRETRAct[nCount - 1] = ganRETRAct[nCount];
    }
    gnRETRActNum--;
  }
}

//////////////////////////////////////////////////////////////////
// Add an email to the MAIL queue
void AddToMAILQueue (int nEmailNum)
{
  int                        nCount;
  bool                       boDuplicate;

  if (gnMAILActNum < DETAILS_MAX)
  {
    // Check that it is not a duplicate
    boDuplicate = FALSE;
    for (nCount = 0; ((nCount < gnMAILActNum) && !boDuplicate); nCount++)
    {
      if (ganMAILAct[nCount] == nEmailNum)
      {
        boDuplicate = TRUE;
      }
    }

    if (!boDuplicate)
    {
      ganMAILAct[gnMAILActNum] = nEmailNum;
      gnMAILActNum++;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Remove an email from the MAIL queue
void ShiftMAILQueue (void)
{
  int                        nCount;

  if (gnMAILActNum > 0)
  {
    for (nCount = 1; nCount < (gnMAILActNum + 1); nCount++)
    {
      ganMAILAct[nCount - 1] = ganMAILAct[nCount];
    }
    gnMAILActNum--;
  }
}

//////////////////////////////////////////////////////////////////
// Completely remove a range of emails from the email list
void DeleteMultipleEmails (int nStartEmail, int nEndEmail)
{
  int                        nCount;

  // Delete the emails starting at the end and working backwards
  nCount = nEndEmail - 1;
  while (nCount >= nStartEmail)
  {
    DeleteEmailDetails (nCount);
    nCount--;
  }
}

//////////////////////////////////////////////////////////////////
// Completely remove an email from the email list
void DeleteEmailDetails (int nEmailNum)
{
  int                        nLoop;
  int                        nAllocSuccess;
  int                        nFree[6];
  bool                       boSuccess;
  bool                       boWinFound;
  int                        nEmailSearch;
  bool                       boShift;
  wimp_icon_state            sIcon;
  wimp_icon_create           sIconCreate;

//  REPORTVAR ("-- Email = %d", nEmailNum);

  // Delete the email entirely
  gnTotalMailSize -= gasDetails[gnCurrentMsg].nServerSize;

  DestroyEmailWindow (nEmailNum);

  gasDetails[nEmailNum].boSelected = FALSE;
  gasDetails[nEmailNum].nMsgNum = MESSAGE_INVALID;
  gasDetails[nEmailNum].nSize = -1;
  gasDetails[nEmailNum].nServerSize = -1;
  strncpy (gasDetails[nEmailNum].szSender, "", SENDER_MAX);
  strncpy (gasDetails[nEmailNum].szSenderDisplay, "", SENDER_MAX);
  strncpy (gasDetails[nEmailNum].szSubject, "", SUBJECT_MAX);
  gasDetails[nEmailNum].pcDate[0] = 0;
  gasDetails[nEmailNum].pcDate[1] = 0;
  gasDetails[nEmailNum].pcDate[2] = 0;
  gasDetails[nEmailNum].pcDate[3] = 0;
  gasDetails[nEmailNum].pcDate[4] = 0;
  gasDetails[nEmailNum].ihSenderIcon = 0;
  gasDetails[nEmailNum].ihSubjectIcon = 1;
  gasDetails[nEmailNum].eMailState = MAILSTATE_INVALID;
  gasDetails[nEmailNum].asMIMEList = NULL;
  gasDetails[nEmailNum].nMIMEListNum = 0;
  gasDetails[nEmailNum].szPreMIMEEmail = NULL;
  gasDetails[nEmailNum].nPreMIMESize = 0;
  strncpy (gasDetails[nEmailNum].szAttachNum, "0", ATTACH_NUM_TEXT_MAX);
  gasDetails[nEmailNum].ihAttNumIcon = 11;

  gasDetails[nEmailNum].eState = DETAILS_NONE;

  // Shift all of the other emails in memory
  for (nLoop = (nEmailNum + 1); nLoop < gnDetailsNum; nLoop++)
  {
    gasDetails[nLoop - 1] = gasDetails[nLoop];

    if (gasDetails[nLoop - 1].whHead != wimp_BACKGROUND)
    {
      // Update the sender and subject icons
      sIcon.w = gasDetails[nLoop - 1].whHead;
      sIcon.i = gasDetails[nLoop - 1].ihSenderIcon;
      xwimp_get_icon_state (& sIcon);
      xwimp_delete_icon (gasDetails[nLoop - 1].whHead,
        gasDetails[nLoop - 1].ihSenderIcon);
      sIcon.icon.data.indirected_text.text
        = gasDetails[nLoop - 1].szSender;
      sIconCreate.w = gasDetails[nLoop - 1].whHead;
      sIconCreate.icon = sIcon.icon;
      xwimp_create_icon (& sIconCreate,
        & gasDetails[nLoop - 1].ihSenderIcon);

      sIcon.w = gasDetails[nLoop - 1].whHead;
      sIcon.i = gasDetails[nLoop - 1].ihSubjectIcon;
      xwimp_get_icon_state (& sIcon);
      xwimp_delete_icon (gasDetails[nLoop - 1].whHead,
        gasDetails[nLoop - 1].ihSubjectIcon);
      sIcon.icon.data.indirected_text.text
        = gasDetails[nLoop - 1].szSubject;
      sIconCreate.w = gasDetails[nLoop - 1].whHead;
      sIconCreate.icon = sIcon.icon;
      xwimp_create_icon (& sIconCreate,
        & gasDetails[nLoop - 1].ihSubjectIcon);

      sIcon.w = gasDetails[nLoop - 1].whHead;
      sIcon.i = gasDetails[nLoop - 1].ihAttNumIcon;
      xwimp_get_icon_state (& sIcon);
      xwimp_delete_icon (gasDetails[nLoop - 1].whHead,
        gasDetails[nLoop - 1].ihAttNumIcon);
      sIcon.icon.data.indirected_text.text
        = gasDetails[nLoop - 1].szAttachNum;
      sIconCreate.w = gasDetails[nLoop - 1].whHead;
      sIconCreate.icon = sIcon.icon;
      xwimp_create_icon (& sIconCreate,
        & gasDetails[nLoop - 1].ihAttNumIcon);
    }

    boSuccess = TRUE;
    nFree[0] = EMAIL_INVALID;
    if (gasDetails[nLoop].szRawEmail != NULL)
    {
      nAllocSuccess = flex_reanchor (
        (flex_ptr)(& gasDetails[nLoop - 1].szRawEmail),
        (flex_ptr)(& gasDetails[nLoop].szRawEmail));

      if (nAllocSuccess == 0)
      {
        nFree[0] = nLoop;
        boSuccess = FALSE;
      }
      else
      {
        nFree[0] = nLoop - 1;
      }
    }

    nFree[1] = EMAIL_INVALID;
    if (gasDetails[nLoop].szFormEmail != NULL)
    {
      nAllocSuccess = flex_reanchor (
        (flex_ptr)(& gasDetails[nLoop - 1].szFormEmail),
        (flex_ptr)(& gasDetails[nLoop].szFormEmail));

      if (nAllocSuccess == 0)
      {
        nFree[1] = nLoop;
        boSuccess = FALSE;
      }
      else
      {
        nFree[1] = nLoop - 1;
      }
    }

    nFree[2] = EMAIL_INVALID;
    if (gasDetails[nLoop].anLine != NULL)
    {
      nAllocSuccess = flex_reanchor (
        (flex_ptr)(& gasDetails[nLoop - 1].anLine),
        (flex_ptr)(& gasDetails[nLoop].anLine));

      if (nAllocSuccess == 0)
      {
        nFree[2] = nLoop;
        boSuccess = FALSE;
      }
      else
      {
        nFree[2] = nLoop - 1;
      }
    }

    nFree[3] = EMAIL_INVALID;
    if (gasDetails[nLoop].anRawLine != NULL)
    {
      nAllocSuccess = flex_reanchor (
        (flex_ptr)(& gasDetails[nLoop - 1].anRawLine),
        (flex_ptr)(& gasDetails[nLoop].anRawLine));

      if (nAllocSuccess == 0)
      {
        nFree[3] = nLoop;
        boSuccess = FALSE;
      }
      else
      {
        nFree[3] = nLoop - 1;
      }
    }

    nFree[4] = EMAIL_INVALID;
    if (gasDetails[nLoop].asMIMEList != NULL)
    {
      nAllocSuccess = flex_reanchor (
        (flex_ptr)(& gasDetails[nLoop - 1].asMIMEList),
        (flex_ptr)(& gasDetails[nLoop].asMIMEList));

      if (nAllocSuccess == 0)
      {
        nFree[4] = nLoop;
        boSuccess = FALSE;
      }
      else
      {
        nFree[4] = nLoop - 1;
      }
    }

    nFree[5] = EMAIL_INVALID;
    if (gasDetails[nLoop].szPreMIMEEmail != NULL)
    {
      nAllocSuccess = flex_reanchor (
        (flex_ptr)(& gasDetails[nLoop - 1].szPreMIMEEmail),
        (flex_ptr)(& gasDetails[nLoop].szPreMIMEEmail));

      if (nAllocSuccess == 0)
      {
        nFree[5] = nLoop;
        boSuccess = FALSE;
      }
      else
      {
        nFree[5] = nLoop - 1;
      }
    }




    if (!boSuccess)
    {
      if (nFree[0] != EMAIL_INVALID)
      {
        flex_free ((flex_ptr)(& gasDetails[nFree[0]].szRawEmail));
        gasDetails[nLoop - 1].szRawEmail = NULL;
      }
      if (nFree[1] != EMAIL_INVALID)
      {
        flex_free ((flex_ptr)(& gasDetails[nFree[1]].szFormEmail));
        gasDetails[nLoop - 1].szFormEmail = NULL;
      }
      if (nFree[2] != EMAIL_INVALID)
      {
        flex_free ((flex_ptr)(& gasDetails[nFree[2]].anLine));
        gasDetails[nLoop - 1].anLine = NULL;
      }
      if (nFree[3] != EMAIL_INVALID)
      {
        flex_free ((flex_ptr)(& gasDetails[nFree[3]].anRawLine));
        gasDetails[nLoop - 1].anRawLine = NULL;
      }
      if (nFree[4] != EMAIL_INVALID)
      {
        flex_free ((flex_ptr)(& gasDetails[nFree[4]].asMIMEList));
        gasDetails[nLoop - 1].asMIMEList = NULL;
      }
      if (nFree[5] != EMAIL_INVALID)
      {
        flex_free ((flex_ptr)(& gasDetails[nFree[5]].szPreMIMEEmail));
        gasDetails[nLoop - 1].szPreMIMEEmail = NULL;
      }
    }
  }

  // Sift through the references and reset them
  boWinFound = FALSE;
  nEmailSearch = 0;
  while (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND)
  {
    if (nEmailNum < ganEmailsOpen[nEmailSearch])
    {
      ganEmailsOpen[nEmailSearch]--;
    }
    nEmailSearch++;
  }

  // Rejig the sort list
  boShift = FALSE;
  for (nLoop = 0; nLoop < gnDetailsNum; nLoop++)
  {
    if (ganSort[nLoop] == nEmailNum)
    {
      boShift = TRUE;
    }
    if (boShift)
    {
      ganSort[nLoop] = ganSort[nLoop + 1];
    }
    if (ganSort[nLoop] > nEmailNum)
    {
      ganSort[nLoop]--;
    }
    if (nLoop < (gnDetailsNum - 1))
    {
      // The last position has just become undefined (-1)
      gasDetails[ganSort[nLoop]].nSortPos = nLoop;
    }
  }

  gnDetailsNum--;

  // Clear the last email
  gasDetails[gnDetailsNum].boSelected = FALSE;
  gasDetails[gnDetailsNum].nMsgNum = MESSAGE_INVALID;
  gasDetails[gnDetailsNum].nSize = -1;
  gasDetails[gnDetailsNum].nServerSize = -1;
  strncpy (gasDetails[gnDetailsNum].szSender, "", SENDER_MAX);
  strncpy (gasDetails[gnDetailsNum].szSenderDisplay, "", SENDER_MAX);
  strncpy (gasDetails[gnDetailsNum].szSubject, "", SUBJECT_MAX);
  gasDetails[gnDetailsNum].eState = DETAILS_NONE;
  gasDetails[gnDetailsNum].whWindow = wimp_BACKGROUND;
  gasDetails[gnDetailsNum].whHead = wimp_BACKGROUND;
  gasDetails[gnDetailsNum].szRawEmail = NULL;
  gasDetails[gnDetailsNum].szFormEmail = NULL;
  gasDetails[gnDetailsNum].nHeaderEndLine = 0;
  gasDetails[gnDetailsNum].nLineHide = 0;
  gasDetails[gnDetailsNum].anLine = NULL;
  gasDetails[gnDetailsNum].anRawLine = NULL;
  gasDetails[gnDetailsNum].nLineMax = 0;
  gasDetails[gnDetailsNum].boOpenOnLoad = FALSE;
  strncpy (gasDetails[nLoop].szUID, "", UID_MAX);
  gasDetails[gnDetailsNum].pcDate[0] = 0;
  gasDetails[gnDetailsNum].pcDate[1] = 0;
  gasDetails[gnDetailsNum].pcDate[2] = 0;
  gasDetails[gnDetailsNum].pcDate[3] = 0;
  gasDetails[gnDetailsNum].pcDate[4] = 0;
  gasDetails[gnDetailsNum].ihSenderIcon = 0;
  gasDetails[gnDetailsNum].ihSubjectIcon = 1;
  gasDetails[gnDetailsNum].eMailState = MAILSTATE_INVALID;
  gasDetails[gnDetailsNum].asMIMEList = NULL;
  gasDetails[gnDetailsNum].nMIMEListNum = 0;
  gasDetails[gnDetailsNum].szPreMIMEEmail = NULL;
  gasDetails[gnDetailsNum].nPreMIMESize = 0;
  strncpy (gasDetails[gnDetailsNum].szAttachNum, "0", ATTACH_NUM_TEXT_MAX);
  gasDetails[gnDetailsNum].ihAttNumIcon = 11;

  RenumberQueues (nEmailNum);
}

//////////////////////////////////////////////////////////////////
// Delete the selected emails from the server
void CompileDeleteList (void)
{
  int                         nCount;

  for (nCount = 0; nCount < gnDetailsNum; nCount++)
  {
    if (gasDetails[nCount].boSelected)
    {
      AddToDELEQueue (nCount);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Renumber mail queues after a delete
void RenumberQueues (int nDeletedEmail)
{
  int                         nCount;

  // MAIL queue
  for (nCount = 0; nCount < gnMAILActNum; nCount++)
  {
    if (ganMAILAct[nCount] >= nDeletedEmail)
    {
      ganMAILAct[nCount]--;
    }
  }

  // DELE queue
  for (nCount = 0; nCount < gnDELEActNum; nCount++)
  {
    if (ganDELEAct[nCount] >= nDeletedEmail)
    {
      ganDELEAct[nCount]--;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Remove all entries from the RETR / DELE queues
void ClearPOP3Queues (void)
{
  int                        nCount;

  for (nCount = 0; nCount < gnRETRActNum; nCount++)
  {
    if (ganRETRAct[nCount] != EMAIL_INVALID)
    {
      if (gasDetails[ganRETRAct[nCount]].szRawEmail == NULL)
      {
        gasDetails[ganRETRAct[nCount]].eMailState = MAILSTATE_REMOTE;
      }
      else
      {
        gasDetails[ganRETRAct[nCount]].eMailState = MAILSTATE_LOCAL;
      }
    }
    ganRETRAct[nCount] = EMAIL_INVALID;
  }
  gnRETRActNum = 0;

  for (nCount = 0; nCount < gnDELEActNum; nCount++)
  {
    if (ganDELEAct[nCount] != EMAIL_INVALID)
    {
      if (gasDetails[ganDELEAct[nCount]].szRawEmail == NULL)
      {
        gasDetails[ganDELEAct[nCount]].eMailState = MAILSTATE_REMOTE;
      }
      else
      {
        gasDetails[ganDELEAct[nCount]].eMailState = MAILSTATE_LOCAL;
      }
    }
    ganDELEAct[nCount] = EMAIL_INVALID;
  }
  gnDELEActNum = 0;

  UpdateMain (-1, -1);
}

//////////////////////////////////////////////////////////////////
// Set the connection status and update the status icon
void SetConnectStatus (CONNECTED eStatus)
{
  os_t                       nTime;

  switch (eStatus)
  {
    default:
    case CONNECTED_OFF:
      if (geConnectStatus != eStatus)
      {
        geConnectStatus = eStatus;
      }
      SetIconSprite ("red", gwhMaHe, 0);
      break;
    case CONNECTED_WAITING:
      if (geConnectStatus != eStatus)
      {
        if ((geConnectStatus == CONNECTED_SENDING)
          || (geConnectStatus == CONNECTED_RECEIVING))
        {
          xos_read_monotonic_time (& nTime);
          if (nTime > (gnLastSendRecTime + CONNECTED_OFF_DELAY))
          {
            geConnectStatus = eStatus;
            SetIconSprite ("amber", gwhMaHe, 0);
          }
        }
        else
        {
          geConnectStatus = eStatus;
          SetIconSprite ("amber", gwhMaHe, 0);
        }
      }
      break;
    case CONNECTED_SENDING:
    case CONNECTED_RECEIVING:
      xos_read_monotonic_time (& gnLastSendRecTime);
      if (geConnectStatus != eStatus)
      {
        SetIconSprite ("green", gwhMaHe, 0);
        geConnectStatus = eStatus;
      }
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Resets the timeout time for an operation
void ResetTimeout (os_t nTime)
{
  xos_read_monotonic_time (& gnTimeoutTime);
  gnTimeoutTime += nTime;
}

//////////////////////////////////////////////////////////////////
// Checks for timeouts
void CheckTimeout (void)
{
  os_t                       nTime;

  if ((gnTimeoutTime != -1) && (geConnectStatus != CONNECTED_OFF))
  {
    xos_read_monotonic_time (& nTime);
    if (nTime > gnTimeoutTime)
    {
      ShowWarningTag ("Er17");
      Cancel ();
    }
  }
}

//////////////////////////////////////////////////////////////////
// Cancels operation
void Cancel (void)
{
  geState = STATE_CANCEL;
  gePOP3TranState = POP3_TRANSTATE_NOSENT;
  geSMTPTranState = SMTP_TRANSTATE_NOSENT;
  geAuthState = AUTHSTATE_NOSENT;
  geQuitState = QUITSTATE_QUIT;
  gnTimeoutTime = -1;
  geNetCom = NET_INVALID;

  if (gpcCurrentEmail)
  {
    flex_free ((flex_ptr)(& gpcCurrentEmail));
    gpcCurrentEmail = NULL;
  }

  ClearPOP3Queues ();

  while (gnMAILActNum > 0)
  {
    SMTPMailSendFail (ganMAILAct[gnMAILActPos]);
  }
}

//////////////////////////////////////////////////////////////////
// Clears all details in an account structure
void ClearAccountDetails (int nAccount)
{
  int                        nCount;

  strcpy (gasAccount[nAccount].szTitle, "");
  strcpy (gasAccount[nAccount].szName, "");
  strcpy (gasAccount[nAccount].szEmailAddress, "");
  strcpy (gasAccount[nAccount].szPOP3Server, "");
  gasAccount[nAccount].nPOP3Port = 110;
  strcpy (gasAccount[nAccount].szPOP3Username, "");
  gasAccount[nAccount].boPOP3RememberPassword = FALSE;
  gasAccount[nAccount].boPOP3GotPassword = FALSE;
  strcpy (gasAccount[nAccount].szPOP3Password, "");
  strcpy (gasAccount[nAccount].szSMTPServer, "");
  gasAccount[nAccount].nSMTPPort = 25;
  gasAccount[nAccount].boBCCToSelf = FALSE;
  gasAccount[nAccount].boCCBCC = FALSE;
  strcpy (gasAccount[nAccount].szBCCAddress, "");
  gasAccount[nAccount].eSMTPAuth = SMTPAUTH_NONE;
  gasAccount[nAccount].boSMTPUsePOP3Details = TRUE;
  strcpy (gasAccount[nAccount].szSMTPUsername, "");
  gasAccount[nAccount].boSMTPRememberPassword = FALSE;
  gasAccount[nAccount].boSMTPGotPassword = FALSE;
  strcpy (gasAccount[nAccount].szSMTPPassword, "");

  for (nCount = 0; nCount < SIG_LINE_NUM; nCount++)
  {
    strcpy (gasAccount[nAccount].szSigLine[nCount],"");
  }
}

//////////////////////////////////////////////////////////////////
// Set account details from dialogue entries
void SetAccountDetails (int nAccount)
{
  strncpy (gasAccount[nAccount].szTitle, GetIconText (gwhAcct, 7),
    TITLE_LEN);
  strncpy (gasAccount[nAccount].szName, GetIconText (gwhAcct, 9),
    STRING_LEN);
  strncpy (gasAccount[nAccount].szEmailAddress, GetIconText (gwhAcct, 11),
    STRING_LEN);
  strncpy (gasAccount[nAccount].szPOP3Server, GetIconText (gwhAcct, 13),
    STRING_LEN);
  sscanf (GetIconText (gwhAcct, 15), "%d", & gasAccount[nAccount].nPOP3Port);
  strncpy (gasAccount[nAccount].szPOP3Username, GetIconText (gwhAcct, 17),
    STRING_LEN);
  gasAccount[nAccount].boPOP3RememberPassword
    = GetIconSelectionState (gwhAcct, 18);
  if (gasAccount[nAccount].boPOP3RememberPassword)
  {
    if (strlen (GetIconText (gwhAcct, 20)) > 0)
    {
      strncpy (gasAccount[nAccount].szPOP3Password,
        GetIconText (gwhAcct, 20), PASS_LEN);
    }
  }
  else
  {
    strcpy (gasAccount[nAccount].szPOP3Password, "");
  }
  strncpy (gasAccount[nAccount].szSMTPServer, GetIconText (gwhAcct, 22),
    STRING_LEN);
  sscanf (GetIconText (gwhAcct, 24), "%d", & gasAccount[nAccount].nSMTPPort);

  if (GetIconSelectionState (gwhAcct, 27))
  {
    gasAccount[nAccount].eSMTPAuth = SMTPAUTH_NONE;
  }
  if (GetIconSelectionState (gwhAcct, 28))
  {
    gasAccount[nAccount].eSMTPAuth = SMTPAUTH_PLAIN;
  }
  if (GetIconSelectionState (gwhAcct, 29))
  {
    gasAccount[nAccount].eSMTPAuth = SMTPAUTH_LOGIN;
  }
  if (GetIconSelectionState (gwhAcct, 30))
  {
    gasAccount[nAccount].eSMTPAuth = SMTPAUTH_CRAMMD5;
  }

  gasAccount[nAccount].boSMTPUsePOP3Details
    = GetIconSelectionState (gwhAcct, 31);

  if (gasAccount[nAccount].boSMTPUsePOP3Details)
  {
    gasAccount[nAccount].boSMTPRememberPassword = FALSE;
  }
  else
  {
    gasAccount[nAccount].boSMTPRememberPassword
      = GetIconSelectionState (gwhAcct, 34);
  }

  if (!gasAccount[nAccount].boSMTPUsePOP3Details)
  {
    strncpy (gasAccount[nAccount].szSMTPUsername,
      GetIconText (gwhAcct, 33), STRING_LEN);

    if (gasAccount[nAccount].boSMTPRememberPassword)
    {
      if (strlen (GetIconText (gwhAcct, 36)) > 0)
      {
        strncpy (gasAccount[nAccount].szSMTPPassword,
          GetIconText (gwhAcct, 36), PASS_LEN);
      }
    }
    else
    {
      strcpy (gasAccount[nAccount].szSMTPPassword, "");
    }
  }
  else
  {
    strcpy (gasAccount[nAccount].szSMTPUsername, "");
    strcpy (gasAccount[nAccount].szSMTPPassword, "");
  }
}

//////////////////////////////////////////////////////////////////
// Set account settings details from dialogue entries
void SetAccountSettingsDetails (int nAccount)
{
  int                        nCount;

  gasAccount[nAccount].boBCCToSelf = GetIconSelectionState (gwhSett, 2);
  gasAccount[nAccount].boCCBCC = GetIconSelectionState (gwhSett, 6);
  strncpy (gasAccount[nAccount].szBCCAddress, GetIconText (gwhSett, 8),
    STRING_LEN);

  for (nCount = 0; nCount < SIG_LINE_NUM; nCount++)
  {
    strncpy (gasAccount[nAccount].szSigLine[nCount],
      GetIconText (gwhSett, (14 + nCount)), SIG_LINE_LENGTH);
  }
}

//////////////////////////////////////////////////////////////////
// Set account dialogue from details entries
void SetAccountDialogue (int nAccount)
{
  char                       szString[STRING_LEN];

  gnAccountDialogue = nAccount;

  if (nAccount == ACCOUNT_INVALID)
  {
    SetIconText ("", gwhAcct, 7);
    SetIconText ("", gwhAcct, 9);
    SetIconText ("", gwhAcct, 11);
    SetIconText ("", gwhAcct, 13);
    sprintf (szString, "%d", gasAccount[nAccount].nPOP3Port);
    SetIconText ("110", gwhAcct, 15);
    SetIconText ("", gwhAcct, 17);
    SetIconSelectionState (FALSE, gwhAcct, 18);
    SetIconText ("", gwhAcct, 20);
    SetIconGreyness (TRUE, gwhAcct, 19);
    SetIconGreyness (TRUE, gwhAcct, 20);
    SetIconText ("", gwhAcct, 22);
    SetIconText ("25", gwhAcct, 24);

    SetIconText ("", gwhAcct, 33);
    SetIconSelectionState (FALSE, gwhAcct, 34);
    SetIconText ("", gwhAcct, 36);
    SetIconSelectionState (TRUE, gwhAcct, 31);

    SetIconSelectionState (TRUE, gwhAcct, 27);
    SetIconSelectionState (FALSE, gwhAcct, 28);
    SetIconSelectionState (FALSE, gwhAcct, 29);
    SetIconSelectionState (FALSE, gwhAcct, 30);

    SetIconGreyness (TRUE, gwhAcBa, 3);
  }
  else
  {
    SetIconText (gasAccount[nAccount].szTitle, gwhAcct, 7);
    SetIconText (gasAccount[nAccount].szName, gwhAcct, 9);
    SetIconText (gasAccount[nAccount].szEmailAddress, gwhAcct, 11);
    SetIconText (gasAccount[nAccount].szPOP3Server, gwhAcct, 13);
    sprintf (szString, "%d", gasAccount[nAccount].nPOP3Port);
    SetIconText (szString, gwhAcct, 15);
    SetIconText (gasAccount[nAccount].szPOP3Username, gwhAcct, 17);
    SetIconSelectionState (gasAccount[nAccount].boPOP3RememberPassword,
      gwhAcct, 18);
    if (gasAccount[nAccount].boPOP3RememberPassword)
    {
      SetIconGreyness (FALSE, gwhAcct, 19);
      SetIconGreyness (FALSE, gwhAcct, 20);
      SetIconText ("", gwhAcct, 20);
//      SetIconText (gasAccount[nAccount].szPOP3Password, gwhAcct, 20);
    }
    else
    {
      SetIconText ("", gwhAcct, 20);
      SetIconGreyness (TRUE, gwhAcct, 19);
      SetIconGreyness (TRUE, gwhAcct, 20);
    }
    SetIconText (gasAccount[nAccount].szSMTPServer, gwhAcct, 22);
    sprintf (szString, "%d", gasAccount[nAccount].nSMTPPort);
    SetIconText (szString, gwhAcct, 24);
    SetIconGreyness (FALSE, gwhAcBa, 3);

    SetIconSelectionState (
      (gasAccount[nAccount].eSMTPAuth == SMTPAUTH_NONE), gwhAcct, 27);
    SetIconSelectionState (
      (gasAccount[nAccount].eSMTPAuth == SMTPAUTH_PLAIN), gwhAcct, 28);
    SetIconSelectionState (
      (gasAccount[nAccount].eSMTPAuth == SMTPAUTH_LOGIN), gwhAcct, 29);
    SetIconSelectionState (
      (gasAccount[nAccount].eSMTPAuth == SMTPAUTH_CRAMMD5), gwhAcct, 30);

    SetIconSelectionState (gasAccount[nAccount].boSMTPUsePOP3Details,
      gwhAcct, 31);
    SetIconText (gasAccount[nAccount].szSMTPUsername, gwhAcct, 33);
    SetIconSelectionState (gasAccount[nAccount].boSMTPRememberPassword,
      gwhAcct, 34);
    SetIconText ("", gwhAcct, 36);
  }

  SetSMTPAuthGreyness ();
}

//////////////////////////////////////////////////////////////////
// Set account settings dialogue from details entries
void SetAccountSettingsDialogue (int nAccount)
{
//  char                       szString[STRING_LEN];
  int                        nCount;

  gnAccountSettingsDialogue = nAccount;

  if (nAccount == ACCOUNT_INVALID)
  {
    SetIconSelectionState (TRUE, gwhSett, 2);
    SetIconSelectionState (FALSE, gwhSett, 6);
    SetIconText ("", gwhSett, 8);
    SetIconText (Tag("None"), gwhSett, 10);
    for (nCount = 0; nCount < SIG_LINE_NUM; nCount++)
    {
      SetIconText ("", gwhSett, (14 + nCount));
    }
  }
  else
  {
    SetIconSelectionState (gasAccount[nAccount].boBCCToSelf, gwhSett, 2);
    SetIconSelectionState (gasAccount[nAccount].boCCBCC, gwhSett, 6);
    SetIconText (gasAccount[nAccount].szBCCAddress, gwhSett, 8);
    SetIconText (gasAccount[nAccount].szTitle, gwhSett, 10);

    for (nCount = 0; nCount < SIG_LINE_NUM; nCount++)
    {
      SetIconText (gasAccount[nAccount].szSigLine[nCount], gwhSett,
        (14 + nCount));
    }
  }
}

//////////////////////////////////////////////////////////////////
// Set addresses dialogue
void SetAddressesDialogue (int nAddress)
{
  wimp_caret                 sCaret;

  gnAddress = nAddress;

  if ((nAddress == ADDRESS_INVALID) || (nAddress >= gnAddressNum))
  {
    SetIconText (Tag("AddNew"), gwhAddr, 1);
    SetIconText ("", gwhAddr, 8);
    SetIconText ("", gwhAddr, 10);
    SetIconGreyness (TRUE, gwhAddr, 11);
  }
  else
  {
    SetIconText (gasAddresses[nAddress].szName, gwhAddr, 1);
    SetIconText (gasAddresses[nAddress].szName, gwhAddr, 8);
    SetIconText (gasAddresses[nAddress].szAddress, gwhAddr, 10);
    SetIconGreyness (FALSE, gwhAddr, 11);
  }

  xwimp_get_caret_position (& sCaret);
  if (sCaret.w == gwhAddr)
  {
    xwimp_set_caret_position (gwhAddr, sCaret.i, 0, 0, -1, -1);
  }
}

//////////////////////////////////////////////////////////////////
// Addresses dialogue Delete
void AddressesDialogueDelete (void)
{
  int                        nAddress;

  if ((gnAddress != ADDRESS_INVALID) && (gnAddress < ADDRESSES_NUM_MAX))
  {
    gnAddressNum--;
    for (nAddress = gnAddress; nAddress < gnAddressNum; nAddress++)
    {
      gasAddresses[nAddress] = gasAddresses[nAddress + 1];
    }
  }
  SetAddressesDialogue (ADDRESS_INVALID);
}

//////////////////////////////////////////////////////////////////
// Addresses dialogue Update
void AddressesDialogueUpdate (void)
{
  int                        nAddress;
  int                        nAddressPos;
  char                       szName[ADDRESS_NAME_MAX];

  if ((strlen (GetIconText (gwhAddr, 8)) != 0)
    || (strlen (GetIconText (gwhAddr, 10)) != 0))
  {
    if ((gnAddress != ADDRESS_INVALID) && (gnAddress < ADDRESSES_NUM_MAX))
    {
      // Start by removing the previous entry (to ensure alphabetical order)
      gnAddressNum--;
      for (nAddress = gnAddress; nAddress < gnAddressNum; nAddress++)
      {
        gasAddresses[nAddress] = gasAddresses[nAddress + 1];
      }

      // Find out where to insert the address
      strncpy (szName, GetIconText (gwhAddr, 8), sizeof (szName));
      szName[sizeof (szName) - 1] = 0;
      nAddressPos = 0;
      while ((nAddressPos < gnAddressNum)
        && (cmpstr (szName, gasAddresses[nAddressPos].szName) < 0))
      {
        nAddressPos++;
      }

      // Shift the other addresses up
      for (nAddress = gnAddressNum; nAddress > nAddressPos; nAddress--)
      {
        gasAddresses[nAddress] = gasAddresses[nAddress - 1];
      }
      gnAddressNum++;

      // Insert the address
      strncpy (gasAddresses[nAddressPos].szName, szName,
        ADDRESS_NAME_MAX);
      strncpy (gasAddresses[nAddressPos].szAddress,
        GetIconText (gwhAddr, 10), ADDRESS_ADDRESS_MAX);
    }
    else
    {
      if (gnAddress == ADDRESS_INVALID)
      {
        if (gnAddressNum < ADDRESSES_NUM_MAX)
        {
          // Find out where to insert the address
          strncpy (szName, GetIconText (gwhAddr, 8), sizeof (szName));
          szName[sizeof (szName) - 1] = 0;
          nAddressPos = 0;
          while ((nAddressPos < gnAddressNum)
            && (cmpstr (szName, gasAddresses[nAddressPos].szName) < 0))
          {
            nAddressPos++;
          }

          // Shift the other addresses up
          for (nAddress = gnAddressNum; nAddress > nAddressPos; nAddress--)
          {
            gasAddresses[nAddress] = gasAddresses[nAddress - 1];
          }
          gnAddressNum++;

          // Insert the address
          strncpy (gasAddresses[nAddressPos].szName, szName,
            ADDRESS_NAME_MAX);
          strncpy (gasAddresses[nAddressPos].szAddress,
            GetIconText (gwhAddr, 10), ADDRESS_ADDRESS_MAX);
        }
        else
        {
          ShowWarningTag("Er33");
        }
      }
    }
    SetAddressesDialogue (ADDRESS_INVALID);
  }
}

//////////////////////////////////////////////////////////////////
// Addresses dialogue New
void AddressesDialogueNew (void)
{
  SetAddressesDialogue (ADDRESS_INVALID);
}

//////////////////////////////////////////////////////////////////
// Save address details
void SaveAddressesDetails (void)
{
  int                         nAddress;
  char                        szString[STRING_LEN];
  MemFile                     *pfhFile;
  fileswitch_object_type      eType;

  // Check that the directory exists
  xosfile_read_no_path (ADDRESS_SAVE_DIR, & eType, NULL, NULL, NULL, NULL);
  if (eType == fileswitch_NOT_FOUND)
  {
    // Create a directory
    xosfile_create_dir (ADDRESS_SAVE_DIR, 0);
  }

  pfhFile = memopen (ADDRESS_SAVE, "w");

  if (pfhFile)
  {
    memputs (Tag ("AddFile"), pfhFile);

    SaveSectionMem (pfhFile, "General");
    sprintf (szString, "%d", ADDRESS_FILE_VERSION);
    SaveDetailMem (pfhFile, "Version", szString);
    sprintf (szString, "%d", gnAddressNum);
    SaveDetailMem (pfhFile, "AddressNum", szString);

    SaveSectionMem (pfhFile, "Addresses");
    for (nAddress = 0; nAddress < gnAddressNum; nAddress++)
    {
      memputs (gasAddresses[nAddress].szName, pfhFile);
      memputc ('\n', pfhFile);
      memputs (gasAddresses[nAddress].szAddress, pfhFile);
      memputc ('\n', pfhFile);
    }
    memclose (pfhFile);
  }
}

//////////////////////////////////////////////////////////////////
// Load address details
bool LoadAddressesDetails (void)
{
  int                         nAddress;
  char                        szString[STRING_LEN];
//  FILE                        *pfhFile;
  int                         nSectionPos;
  int                         nLen;
  char                        szScramble[STRING_LEN];
  MemFile                     *pfhFile;
  bool                        boReturn = TRUE;
  int                         nVersion;

  pfhFile = memopen (ADDRESS_LOAD, "r");

  if (pfhFile)
  {
    nLen = strlen (Tag ("AddFile"));
    memgets (szScramble, nLen + 1, pfhFile);
    if (strncmp (szScramble, Tag ("AddFile"), nLen) == 0)
    {
      nSectionPos = FindSectionMem (pfhFile, "General");
      FindValueMem (pfhFile, nSectionPos, "Version",
        szString, sizeof (szString));
      sscanf (szString, "%d", & nVersion);
      if (nVersion == ADDRESS_FILE_VERSION)
      {
        FindValueMem (pfhFile, nSectionPos, "AddressNum",
          szString, sizeof (szString));
        sscanf (szString, "%d", & gnAddressNum);
        if (gnAddressNum < ADDRESSES_NUM_MAX)
        {
          nSectionPos = FindSectionMem (pfhFile, "Addresses");
          for (nAddress = 0; nAddress < gnAddressNum; nAddress++)
          {
            memgets (gasAddresses[nAddress].szName, ADDRESS_NAME_MAX,
              pfhFile);
            memgets (gasAddresses[nAddress].szAddress, ADDRESS_ADDRESS_MAX,
              pfhFile);
          }
        }
        else
        {
          boReturn = FALSE;
        }
      }
      else
      {
        boReturn = FALSE;
      }
    }
    else
    {
      boReturn = FALSE;
    }

    memclose (pfhFile);
  }

  return boReturn;
}

//////////////////////////////////////////////////////////////////
// Generate the accounts menu
void GenerateAccountMenu (wimp_menu * pcMenu)
{
  GenerateAccountMenuOffset (pcMenu, 0);
}

//////////////////////////////////////////////////////////////////
// Generate the accounts menu with a 'none' entry
void GenerateAccountMenuNone (wimp_menu * pcMenu)
{
  GenerateAccountMenuOffset (pcMenu, 1);

  strncpy (pcMenu->entries[0].data.indirected_text.text,
    Tag ("None"), MENU_ENTRY_NONE_LEN);
  pcMenu->entries[0].menu_flags |= wimp_MENU_SEPARATE;
}

//////////////////////////////////////////////////////////////////
// Generate the accounts menu prefixed with blanks
void GenerateAccountMenuOffset (wimp_menu * pcMenu, int nOffset)
{
  char *                      pcBuffer;
  int                         nStringLen;
  int                         nWidth = 0;
  wimp_menu_flags             uFlags;
  int                         nMenuEntry;

  pcBuffer = gpcAcctMenuBuffer;

  pcMenu->title_data.indirected_text.text = pcBuffer;
  strcpy (pcBuffer, Tag ("AccMenu"));
  pcBuffer += strlen (pcBuffer) + 1;
  uFlags = wimp_MENU_TITLE_INDIRECTED;
  pcMenu->title_fg = wimp_COLOUR_BLACK;
  pcMenu->title_bg = wimp_COLOUR_LIGHT_GREY;
  pcMenu->work_fg = wimp_COLOUR_BLACK;
  pcMenu->work_bg = wimp_COLOUR_WHITE;

  pcMenu->height = 44;
  pcMenu->gap = 0;

  nMenuEntry = 0;
  do
  {
    pcMenu->entries[nMenuEntry].sub_menu = (wimp_menu*)-1;
    pcMenu->entries[nMenuEntry].icon_flags = wimp_ICON_TEXT
                   | wimp_ICON_FILLED
                   | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT)
                   | wimp_ICON_INDIRECTED;
    pcMenu->entries[nMenuEntry].data.indirected_text.text = pcBuffer;

    if (nMenuEntry >= nOffset)
    {
      strcpy (pcBuffer, gasAccount[(nMenuEntry - nOffset)].szTitle);
      nStringLen = strlen (gasAccount[(nMenuEntry - nOffset)].szTitle);
    }
    else
    {
      strcpy (pcBuffer, "");
      nStringLen = MENU_ENTRY_NONE_LEN;
    }
    pcBuffer += nStringLen + 1;
    pcMenu->entries[nMenuEntry].data.indirected_text.validation = NULL;
    pcMenu->entries[nMenuEntry].data.indirected_text.size
      = nStringLen + 1;

    if ((nMenuEntry - nOffset) == gnAccount)
    {
      uFlags |= wimp_MENU_TICKED;
    }

    pcMenu->entries[nMenuEntry].menu_flags = uFlags;
    if (nStringLen > nWidth)
    {
      nWidth = nStringLen;
    }
    nMenuEntry++;
    uFlags = 0u;
  } while (nMenuEntry < (gnAccountNum + nOffset));

  pcMenu->width = (nWidth + 1) * 16;
  pcMenu->entries[(nMenuEntry - 1)].menu_flags |= wimp_MENU_LAST;

  if (gpcIconBarMenu)
  {
    SetMenuItemGreyness ((gnAccountNum < 1), gpcIconBarMenu, 1);
  }
}

//////////////////////////////////////////////////////////////////
// Generate the address menu
void GenerateAddressesMenu (ADDRESSMENU eMenuType)
{
  char *                      pcBuffer;
  int                         nStringLen;
  int                         nWidth = 0;
  wimp_menu_flags             uFlags;
  int                         nMenuEntry;
  wimp_menu                   *pcMenu = gpcAddrMenu;

  pcBuffer = gpcAddrMenuBuffer;
  pcMenu->title_data.indirected_text.text = pcBuffer;
  strncpy (pcBuffer, Tag ("AddMenu"), 32);
  pcBuffer += strnlen (pcBuffer, 32) + 1;
  uFlags = wimp_MENU_TITLE_INDIRECTED;
  pcMenu->title_fg = wimp_COLOUR_BLACK;
  pcMenu->title_bg = wimp_COLOUR_LIGHT_GREY;
  pcMenu->work_fg = wimp_COLOUR_BLACK;
  pcMenu->work_bg = wimp_COLOUR_WHITE;

  pcMenu->height = 44;
  pcMenu->gap = 0;

  nMenuEntry = 0;
  do
  {
    pcMenu->entries[nMenuEntry].sub_menu = (wimp_menu*)-1;
    pcMenu->entries[nMenuEntry].icon_flags = wimp_ICON_TEXT
                   | wimp_ICON_FILLED
                   | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT)
                   | wimp_ICON_INDIRECTED;
    if (gnAddressNum == 0)
    {
      pcMenu->entries[nMenuEntry].data.indirected_text.text = pcBuffer;
      strncpy (pcBuffer, Tag ("None"), 32 + gpcAddrMenuBuffer - pcBuffer);
      pcBuffer += strnlen (pcBuffer, 32 + gpcAddrMenuBuffer - pcBuffer) + 1;
      nStringLen = strlen (pcBuffer);
      pcMenu->entries[nMenuEntry].data.indirected_text.size
        = nStringLen + 1;
    }
    else
    {
      pcMenu->entries[nMenuEntry].data.indirected_text.text
        = gasAddresses[nMenuEntry].szName;
      nStringLen = strlen (gasAddresses[nMenuEntry].szName);
      pcMenu->entries[nMenuEntry].data.indirected_text.size
        = ADDRESS_NAME_MAX;
    }

    pcMenu->entries[nMenuEntry].data.indirected_text.validation = NULL;

    if ((nMenuEntry == gnAddress) && (eMenuType == ADDRESSMENU_ADDRESSES))
    {
      uFlags |= wimp_MENU_TICKED;
    }

    pcMenu->entries[nMenuEntry].menu_flags = uFlags;
    if (nStringLen > nWidth)
    {
      nWidth = nStringLen;
    }
    nMenuEntry++;
    uFlags = 0u;
  } while (nMenuEntry < gnAddressNum);

  pcMenu->width = (nWidth + 1) * 16;
  pcMenu->entries[(nMenuEntry - 1)].menu_flags |= wimp_MENU_LAST;
}

//////////////////////////////////////////////////////////////////
// Generate the attachments menu
void GenerateAttachmentMenu (wimp_menu * pcMenu, int nEmailNum)
{
  char *                      pcBuffer;
  int                         nStringLen;
  int                         nWidth = 0;
  wimp_menu_flags             uFlags;
  int                         nMenuEntry;
  char                        szIconName[32];
  os_error                    *psError;
  bool                        boHalfSize;

  pcBuffer = gpcAttcMenuBuffer;

  pcMenu->title_data.indirected_text.text = pcBuffer;
  strcpy (pcBuffer, Tag ("AttMenu"));
  pcBuffer += strlen (pcBuffer) + 1;
  uFlags = wimp_MENU_TITLE_INDIRECTED;
  pcMenu->title_fg = wimp_COLOUR_BLACK;
  pcMenu->title_bg = wimp_COLOUR_LIGHT_GREY;
  pcMenu->work_fg = wimp_COLOUR_BLACK;
  pcMenu->work_bg = wimp_COLOUR_WHITE;

  pcMenu->height = 44;
  pcMenu->gap = 0;

  nMenuEntry = 0;
  do
  {
    pcMenu->entries[nMenuEntry].icon_flags = wimp_ICON_TEXT
                   | wimp_ICON_VCENTRED
                   | wimp_ICON_FILLED
                   | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT)
                   | wimp_ICON_INDIRECTED;
    if (gasDetails[nEmailNum].nMIMEListNum <= 0)
    {
      pcMenu->entries[nMenuEntry].sub_menu = (wimp_menu*)-1;
      pcMenu->entries[nMenuEntry].data.indirected_text.text = pcBuffer;
      strncpy (pcBuffer, Tag ("None"), 32 + gpcAttcMenuBuffer - pcBuffer);
      pcBuffer += strnlen (pcBuffer, 32 + gpcAttcMenuBuffer - pcBuffer) + 1;
      nStringLen = strlen (pcBuffer);
      pcMenu->entries[nMenuEntry].data.indirected_text.size
        = nStringLen + 1;
      pcMenu->entries[nMenuEntry].data.indirected_text.validation = NULL;
    }
    else
    {
      pcMenu->entries[nMenuEntry].sub_menu = (wimp_menu*)gwhAttc;
      pcMenu->entries[nMenuEntry].data.indirected_text.text
        = gasDetails[nEmailNum].asMIMEList[nMenuEntry].szFileName;
      nStringLen
        = strlen (gasDetails[nEmailNum].asMIMEList[nMenuEntry].szFileName);
      pcMenu->entries[nMenuEntry].data.indirected_text.size
        = MIME_LEAFNAME_MAX;
      uFlags |= wimp_MENU_GIVE_WARNING;

      // Set up the icon
      boHalfSize = FALSE;
      sprintf (szIconName, "small_%03x",
        gasDetails[nEmailNum].asMIMEList[nMenuEntry].nFileType);

      psError = xwimpspriteop_read_sprite_info (szIconName, NULL, NULL,
        NULL, NULL);
      if (psError)
      {
        sprintf (szIconName, "file_%03x",
          gasDetails[nEmailNum].asMIMEList[nMenuEntry].nFileType);

        psError = xwimpspriteop_read_sprite_info (szIconName, NULL, NULL,
          NULL, NULL);
        if (psError)
        {
          strcpy (szIconName, "small_xxx");
        }
        else
        {
          boHalfSize = TRUE;
        }
      }

      if ((pcBuffer - gpcAttcMenuBuffer) < (ATTACH_MENU_BUF_SIZE - 12))
      {
        pcMenu->entries[nMenuEntry].icon_flags |= wimp_ICON_SPRITE;
        if (boHalfSize)
        {
          pcMenu->entries[nMenuEntry].icon_flags |= wimp_ICON_HALF_SIZE;
        }

        pcBuffer[0] = 'S';
        strcpy (pcBuffer + 1, szIconName);

        pcMenu->entries[nMenuEntry].data.indirected_text.validation
          = pcBuffer;

        pcBuffer += strlen (szIconName) + 2;
      }
    }

    pcMenu->entries[nMenuEntry].menu_flags = uFlags;
    if (nStringLen > nWidth)
    {
      nWidth = nStringLen;
    }
    nMenuEntry++;
    uFlags = 0u;
  } while (nMenuEntry < gasDetails[nEmailNum].nMIMEListNum);

  pcMenu->width = (nWidth + 1) * 16;
  pcMenu->entries[(nMenuEntry - 1)].menu_flags |= wimp_MENU_LAST;
}

//////////////////////////////////////////////////////////////////
// Generate the edit attachments menu
void GenerateEditAttachmentMenu (wimp_menu * pcMenu, int nEmailNum)
{
  char *                      pcBuffer;
  int                         nStringLen;
  int                         nWidth = 0;
  wimp_menu_flags             uFlags;
  int                         nMenuEntry;
  char                        szIconName[32];
  os_error                    *psError;
  bool                        boHalfSize;

  pcBuffer = gpcEdAtMenuBuffer;

  pcMenu->title_data.indirected_text.text = pcBuffer;
  strcpy (pcBuffer, Tag ("EdAttMenu"));
  pcBuffer += strlen (pcBuffer) + 1;
  uFlags = wimp_MENU_TITLE_INDIRECTED;
  pcMenu->title_fg = wimp_COLOUR_BLACK;
  pcMenu->title_bg = wimp_COLOUR_LIGHT_GREY;
  pcMenu->work_fg = wimp_COLOUR_BLACK;
  pcMenu->work_bg = wimp_COLOUR_WHITE;

  pcMenu->height = 44;
  pcMenu->gap = 0;

  nMenuEntry = 0;
  do
  {
    pcMenu->entries[nMenuEntry].icon_flags = wimp_ICON_TEXT
                   | wimp_ICON_VCENTRED
                   | wimp_ICON_FILLED
                   | (wimp_COLOUR_BLACK << wimp_ICON_FG_COLOUR_SHIFT)
                   | wimp_ICON_INDIRECTED;
    if (gasEdit[nEmailNum].nMIMEListNum <= 0)
    {
      pcMenu->entries[nMenuEntry].sub_menu = (wimp_menu*)-1;
      pcMenu->entries[nMenuEntry].data.indirected_text.text = pcBuffer;
      strncpy (pcBuffer, Tag ("None"), 32 + gpcEdAtMenuBuffer - pcBuffer);
      pcBuffer += strnlen (pcBuffer, 32 + gpcEdAtMenuBuffer - pcBuffer) + 1;
      nStringLen = strlen (pcBuffer);
      pcMenu->entries[nMenuEntry].data.indirected_text.size
        = nStringLen + 1;
      pcMenu->entries[nMenuEntry].data.indirected_text.validation = NULL;
    }
    else
    {
      pcMenu->entries[nMenuEntry].sub_menu = (wimp_menu*)gwhEdAt;
      pcMenu->entries[nMenuEntry].data.indirected_text.text
        = gasEdit[nEmailNum].asAttachments[nMenuEntry].szLeafName;
      nStringLen
        = strlen (gasEdit[nEmailNum].asAttachments[nMenuEntry].szLeafName);
      pcMenu->entries[nMenuEntry].data.indirected_text.size
        = MIME_LEAFNAME_MAX;
      uFlags |= wimp_MENU_GIVE_WARNING;

      // Set up the icon
      boHalfSize = FALSE;
      sprintf (szIconName, "small_%03x",
        gasEdit[nEmailNum].asAttachments[nMenuEntry].nFileType);

      psError = xwimpspriteop_read_sprite_info (szIconName, NULL, NULL,
        NULL, NULL);
      if (psError)
      {
        sprintf (szIconName, "file_%03x",
          gasEdit[nEmailNum].asAttachments[nMenuEntry].nFileType);

        psError = xwimpspriteop_read_sprite_info (szIconName, NULL, NULL,
          NULL, NULL);
        if (psError)
        {
          strcpy (szIconName, "small_xxx");
        }
        else
        {
          boHalfSize = TRUE;
        }
      }

      if ((pcBuffer - gpcEdAtMenuBuffer) < (ATTACH_MENU_BUF_SIZE - 12))
      {
        pcMenu->entries[nMenuEntry].icon_flags |= wimp_ICON_SPRITE;
        if (boHalfSize)
        {
          pcMenu->entries[nMenuEntry].icon_flags |= wimp_ICON_HALF_SIZE;
        }

        pcBuffer[0] = 'S';
        strcpy (pcBuffer + 1, szIconName);

        pcMenu->entries[nMenuEntry].data.indirected_text.validation
          = pcBuffer;

        pcBuffer += strlen (szIconName) + 2;
      }
    }

    pcMenu->entries[nMenuEntry].menu_flags = uFlags;
    if (nStringLen > nWidth)
    {
      nWidth = nStringLen;
    }
    nMenuEntry++;
    uFlags = 0u;
  } while (nMenuEntry < gasEdit[nEmailNum].nMIMEListNum);

  pcMenu->width = (nWidth + 1) * 16;
  pcMenu->entries[(nMenuEntry - 1)].menu_flags |= wimp_MENU_LAST;
}

//////////////////////////////////////////////////////////////////
// Open the edit attachments menu
void OpenEditAttachmentMenu (wimp_w whWindow, wimp_i ihIcon, int nEmailNum)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = whWindow;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  GenerateEditAttachmentMenu (gpcEditAttcMenu, nEmailNum);
  OpenMenu (gpcEditAttcMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Open the attachments menu
void OpenAttachmentMenu (wimp_w whWindow, wimp_i ihIcon, int nEmailNum)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = whWindow;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  GenerateAttachmentMenu (gpcAttcMenu, nEmailNum);
  OpenMenu (gpcAttcMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Open the addresses menu
void OpenAddressMenu (wimp_w whWindow, wimp_i ihIcon, ADDRESSMENU eMenuType)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = whWindow;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = whWindow;
  sIconState.i = ihIcon;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  GenerateAddressesMenu (eMenuType);
  geAddressMenuType = eMenuType;
  OpenMenu (gpcAddrMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Open the account menu from the login window
void OpenLoginMenu (void)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = gwhLogn;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = gwhLogn;
  sIconState.i = 0;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  GenerateAccountMenu (gpcLognMenu);
  OpenMenu (gpcLognMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Open the account menu from the login window
void OpenMainLoginMenu (void)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = gwhMaHe;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = gwhMaHe;
  sIconState.i = 8;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  GenerateAccountMenu (gpcAcctMenu);
  OpenMenu (gpcAcctMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Open the login window showing a particular account
void OpenLoginWindow (int nShowAccount)
{
  bool                        boSMTPGetPass;

  OpenWindowInitCentre (gwhLogn);
  SetLoginWindow (nShowAccount);
  if (nShowAccount == ACCOUNT_INVALID)
  {
    nShowAccount = 0;
  }

  boSMTPGetPass = (((!gasAccount[nShowAccount].boSMTPRememberPassword)
    && (!gasAccount[nShowAccount].boSMTPUsePOP3Details))
    && (gasAccount[nShowAccount].eSMTPAuth != SMTPAUTH_NONE));

  if (gasAccount[nShowAccount].boPOP3RememberPassword)
  {
    if (boSMTPGetPass)
    {
      xwimp_set_caret_position (gwhLogn, (wimp_i)(8), 0, 0, -1, -1);
    }
    else
    {
      xwimp_set_caret_position (gwhLogn, (wimp_i)(-1), 0, 0, -1, -1);
    }
  }
  else
  {
    xwimp_set_caret_position (gwhLogn, (wimp_i)(6), 0, 0, -1, -1);
  }
}

//////////////////////////////////////////////////////////////////
// Set up the login window display
void SetLoginWindow (int nShowAccount)
{
  wimp_caret                  sCaret;
  bool                        boSMTPGetPass;

  if (nShowAccount == ACCOUNT_INVALID)
  {
    nShowAccount = 0;
  }
  gnAccountLogin = nShowAccount;
  SetIconText (gasAccount[nShowAccount].szTitle, gwhLogn, 1);
  SetIconGreyness (gasAccount[nShowAccount].boPOP3RememberPassword,
    gwhLogn, 5);
  SetIconGreyness (gasAccount[nShowAccount].boPOP3RememberPassword,
    gwhLogn, 6);
  SetIconText ("", gwhLogn, 6);

  boSMTPGetPass = (((!gasAccount[nShowAccount].boSMTPRememberPassword)
    && (!gasAccount[nShowAccount].boSMTPUsePOP3Details))
    && (gasAccount[nShowAccount].eSMTPAuth != SMTPAUTH_NONE));
  SetIconGreyness (!boSMTPGetPass, gwhLogn, 7);
  SetIconGreyness (!boSMTPGetPass, gwhLogn, 8);

  xwimp_get_caret_position (& sCaret);
  if (gasAccount[nShowAccount].boPOP3RememberPassword)
  {
    if (sCaret.w == gwhLogn)
    {
      if (boSMTPGetPass)
      {
        xwimp_set_caret_position (gwhLogn, (wimp_i)(8), 0, 0, -1, -1);
      }
      else
      {
        xwimp_set_caret_position (gwhLogn, (wimp_i)(-1), 0, 0, -1, -1);
      }
    }
  }
  else
  {
    if (sCaret.w == gwhLogn)
    {
      xwimp_set_caret_position (gwhLogn, (wimp_i)(6), 0, 0, -1, -1);
    }
  }

  SetIconText ("", gwhLogn, 8);
}

//////////////////////////////////////////////////////////////////
// Set up the account icon in the choices window display
void ShowChoicesAccount (int nShowAccount)
{
  if ((nShowAccount >= 0) && (nShowAccount < gnAccountNum))
  {
    gnDefaultAccountDisplay = nShowAccount;
    SetIconText (gasAccount[nShowAccount].szTitle, gwhChce, 27);
  }
  else
  {
    gnDefaultAccountDisplay = ACCOUNT_INVALID;
    SetIconText (Tag("None"), gwhChce, 27);
  }
}

//////////////////////////////////////////////////////////////////
// Open the account profile window with the details of a particular account
void OpenAccountWindow (int nDialogueAccount)
{
  SetAccountDialogue (nDialogueAccount);
  OpenWindowInitPaneCentreSize (gwhAcct, gwhAcBa, PANE_BASE,
    ACCOUNT_OPEN_WIDTH, ACCOUNT_OPEN_HEIGHT);
  xwimp_set_caret_position (gwhAcct, (wimp_i)(7), 0, 0, -1, -1);
}

//////////////////////////////////////////////////////////////////
// Open the account settings window with the details of a particular account
void OpenAccountSettingsWindow (int nDialogueAccount)
{
  SetAccountSettingsDialogue (nDialogueAccount);
  OpenWindowInitPaneCentreSize (gwhSett, gwhSeBa, PANE_BASE,
    SETTINGS_OPEN_WIDTH, SETTINGS_OPEN_HEIGHT);
  xwimp_set_caret_position (gwhSett, (wimp_i)8, 0, 0, -1, -1); }

//////////////////////////////////////////////////////////////////
// Open the iconbar menu
void SetupIconbarMenu (void)
{
  GenerateAccountMenu (gpcAcctMenu);

  SetMenuItemGreyness ((!(gnAccountNum < ACCOUNT_MAX) || !gboAccountsLoaded),
    gpcIconBarMenu, 2);

  SetMenuItemGreyness ((!gboAccountsLoaded) || (gnAccountNum == 0),
    gpcIconBarMenu, 1);
  SetMenuItemGreyness (!gboAccountsLoaded, gpcIconBarMenu, 3);
  SetMenuItemGreyness (!gboAccountsLoaded, gpcIconBarMenu, 4);

  SetMenuItemGreyness (((!gboAccountsLoaded)
    || (strcmp (gszUnlockPassword, "") == 0)), gpcIconBarMenu, 5);
}

//////////////////////////////////////////////////////////////////
// An account has been selected from the iconbar menu
void MenuSelectIconbarAccount (int nAccount)
{
  if ((gasAccount[nAccount].boPOP3RememberPassword
    || gasAccount[nAccount].boPOP3GotPassword)
    && ((gasAccount[nAccount].eSMTPAuth == SMTPAUTH_NONE)
    || gasAccount[nAccount].boSMTPUsePOP3Details
    || gasAccount[nAccount].boSMTPRememberPassword
    || gasAccount[nAccount].boSMTPGotPassword))
  {
    LoginAccount (nAccount);
  }
  else
  {
    OpenLoginWindow (nAccount);
  }
}

//////////////////////////////////////////////////////////////////
// Login an account
void LoginAccount (int nAccount)
{
  wimp_window_info            sWindowInfo;

  // Check if a transfer is in progress
  if (TransferInProgress ())
  {
    ShowWarningTag ("Er19");
  }
  else
  {
    if (gnAccount != ACCOUNT_INVALID)
    {
      // Clear the account info
      CloseWindowHandle (gwhMain);
      CloseWindowHandle (gwhMaHe);
      DeleteMultipleEmails (0, gnDetailsNum);
    }

    if ((!gasAccount[nAccount].boPOP3GotPassword)
      && (!gasAccount[nAccount].boPOP3RememberPassword))
    {
      strcpy (gasAccount[nAccount].szPOP3Password, GetIconText (gwhLogn, 6));
    }
    gasAccount[nAccount].boPOP3GotPassword = TRUE;

    if ((!gasAccount[nAccount].boSMTPGotPassword)
      && (!gasAccount[nAccount].boSMTPRememberPassword))
    {
      strcpy (gasAccount[nAccount].szSMTPPassword, GetIconText (gwhLogn, 8));
    }
    gasAccount[nAccount].boSMTPGotPassword = TRUE;

    gnAccount = nAccount;

    gnEmailSelected = EMAIL_INVALID;
    gnTotalMailSize = 0;
    gnTotalMailSizeTemp = 0;

    sWindowInfo.w = gwhMain;
    xwimp_get_window_info_header_only (& sWindowInfo);
    strncpy (sWindowInfo.title_data.indirected_text.text,
      gasAccount[nAccount].szTitle,
      sWindowInfo.title_data.indirected_text.size);

    OpenWindowInitPaneNew (gwhMain, gwhMaHe, PANE_TOP);
  }
}

//////////////////////////////////////////////////////////////////
// Open a memory 'file' for reading/writing
MemFile * memopen (char * filename, char * mode)
{
  MemFile                     *psMemFile = NULL;
  int                         nSuccess;

  if (mode[0] == 'r')
  {
    psMemFile = (MemFile*)malloc (sizeof (MemFile));

    if (psMemFile)
    {
      nSuccess = LoadFileFlex (filename, & psMemFile->pcMemory,
        & psMemFile->nSize);

      if ((nSuccess <= 0) || (psMemFile->pcMemory == NULL))
      {
        free (psMemFile);
        psMemFile = NULL;
        if (nSuccess == 0)
        {
          ShowWarningTag ("Er20");
        }
      }
      else
      {
        if (strcmp (gszUnlockPassword, "") != 0)
        {
          // Attempt to unscramble the file
          UnscrambleData ((int*)psMemFile->pcMemory,
            (int*)psMemFile->pcMemory, ((psMemFile->nSize) / 4),
            gszUnlockPassword);
        }

        psMemFile->nPos = 0;
        psMemFile->cMode = mode[0];

        strncpy (psMemFile->szFilename, filename, 1024);
      }
    }
  }

  if (mode[0] == 'w')
  {
    psMemFile = (MemFile*)malloc (sizeof (MemFile));

    nSuccess = flex_alloc ((flex_ptr)& psMemFile->pcMemory, MEMFILE_BLOCK);

    psMemFile->nPos = 0;
    psMemFile->cMode = mode[0];
    psMemFile->nSize = MEMFILE_BLOCK;

    strncpy (psMemFile->szFilename, filename, 1024);

    if (nSuccess == 0)
    {
      free (psMemFile);
      ShowWarningTag ("Er21");
      psMemFile = NULL;
    }
  }

  return psMemFile;
}

//////////////////////////////////////////////////////////////////
// Close a memory 'file' for reading/writing
int memclose (MemFile * psMemFile)
{
  int                         nSuccess = EOF;
  os_error                    *psError;
  int                         nSaveSize;

  if (psMemFile->cMode == 'r')
  {
    flex_free ((flex_ptr)& psMemFile->pcMemory);
    free (psMemFile);
    nSuccess = 0;
  }

  if (psMemFile->cMode == 'w')
  {
    nSaveSize = psMemFile->nPos;

    if (strcmp (gszUnlockPassword, "") != 0)
    {
      // Scramble the file
      nSaveSize = (nSaveSize + 15) & ~15;
      ScrambleData ((int*)psMemFile->pcMemory,
        (int*)psMemFile->pcMemory, (nSaveSize / 4),
        gszUnlockPassword);
    }

    // Save out the file
    psError = xosfile_save_stamped (psMemFile->szFilename, 0xfff,
      psMemFile->pcMemory, psMemFile->pcMemory + nSaveSize);
    err (psError);

    if (psError == NULL)
    {
      nSuccess = 0;
    }

    flex_free ((flex_ptr)& psMemFile->pcMemory);
    free (psMemFile);
  }

  return nSuccess;
}

//////////////////////////////////////////////////////////////////
// Save account details
void SaveAccountDetails (void)
{
  int                         nAccount;
  char                        szString[STRING_LEN];
  MemFile                     *pfhFile;
  int                         anBuffer[STRING_LEN / 4];
  int                         nLen;
  char                        szScramble[STRING_LEN];
  fileswitch_object_type      eType;
  int                         nCount;

  // Check that the directory exists
  xosfile_read_no_path (ACCOUNTS_SAVE_DIR, & eType, NULL, NULL, NULL, NULL);
  if (eType == fileswitch_NOT_FOUND)
  {
    // Create a directory
    xosfile_create_dir (ACCOUNTS_SAVE_DIR, 0);
  }

  pfhFile = memopen (ACCOUNTS_SAVE, "w");

  if (pfhFile)
  {
    memputs (Tag ("File"), pfhFile);

    SaveSectionMem (pfhFile, "General");
    sprintf (szString, "%d", gnAccountNum);
    SaveDetailMem (pfhFile, "Accounts", szString);
    SaveDetailMem (pfhFile, "DateFormat", gszDateFormat);
    sprintf (szString, "%d", gboLog);
    SaveDetailMem (pfhFile, "Logging", szString);
    sprintf (szString, "%d", gnDefaultAccount);
    SaveDetailMem (pfhFile, "DefaultAcc", szString);
    SaveDetailMem (pfhFile, "LocalFont", gszFont);
    SaveDetailMem (pfhFile, "RemoteFont", gszFontB);
    sprintf (szString, "%d", ganColWidth[1]);
    SaveDetailMem (pfhFile, "ColPos1", szString);
    sprintf (szString, "%d", ganColWidth[2]);
    SaveDetailMem (pfhFile, "ColPos2", szString);
    sprintf (szString, "%d", ganColWidth[3]);
    SaveDetailMem (pfhFile, "ColPos3", szString);
    sprintf (szString, "%d", ganColWidth[4]);
    SaveDetailMem (pfhFile, "ColPos4", szString);
    sprintf (szString, "%d", ganColWidth[5]);
    SaveDetailMem (pfhFile, "ColPos5", szString);
    sprintf (szString, "%d", ganColWidth[6]);
    SaveDetailMem (pfhFile, "ColPos6", szString);
    sprintf (szString, "%d", geDeleteTypeConfig);
    SaveDetailMem (pfhFile, "DeleteType", szString);
    sprintf (szString, "%d", gboEmoticons);
    SaveDetailMem (pfhFile, "Emoticons", szString);
#if defined MAX_SEND_LEN
    sprintf (szString, "%d", gnMaxSendLen);
    SaveDetailMem (pfhFile, "MaxSend", szString);
    sprintf (szString, "%d", gnNullPollNetwork);
    SaveDetailMem (pfhFile, "NetIdle", szString);
    sprintf (szString, "%d", gboFastSending);
    SaveDetailMem (pfhFile, "FastSend", szString);
#endif

    for (nAccount = 0; nAccount < gnAccountNum; nAccount++)
    {
      sprintf (szString, "Account %d", nAccount);
      SaveSectionMem (pfhFile, szString);
      SaveDetailMem (pfhFile, "Title", gasAccount[nAccount].szTitle);
      SaveDetailMem (pfhFile, "Name", gasAccount[nAccount].szName);
      SaveDetailMem (pfhFile, "Email", gasAccount[nAccount].szEmailAddress);
      SaveDetailMem (pfhFile, "POP3Server",
        gasAccount[nAccount].szPOP3Server);
      sprintf (szString, "%d", gasAccount[nAccount].nPOP3Port);
      SaveDetailMem (pfhFile, "POP3Port", szString);
      SaveDetailMem (pfhFile, "POP3Username",
        gasAccount[nAccount].szPOP3Username);
      sprintf (szString, "%d", gasAccount[nAccount].boPOP3RememberPassword);
      SaveDetailMem (pfhFile, "Remember", szString);

      if (gasAccount[nAccount].boPOP3RememberPassword)
      {
        strcpy (szScramble, "Tapir");
        strncat (szScramble, gasAccount[nAccount].szTitle,
          sizeof (szScramble) - 5);

        nLen = ((strlen (gasAccount[nAccount].szPOP3Password)
          + 8) / 8) * 2 + 1;
        ScrambleData ((int*)gasAccount[nAccount].szPOP3Password, anBuffer,
          nLen, szScramble);
        HexToString (szString, anBuffer, nLen);
        SaveDetailMem (pfhFile, "POP3Password", szString);
      }
      else
      {
        SaveDetailMem (pfhFile, "POP3Password", "");
      }

      SaveDetailMem (pfhFile, "SMTPServer",
        gasAccount[nAccount].szSMTPServer);
      sprintf (szString, "%d", gasAccount[nAccount].nSMTPPort);
      SaveDetailMem (pfhFile, "SMTPPort", szString);

      sprintf (szString, "%d", gasAccount[nAccount].boBCCToSelf);
      SaveDetailMem (pfhFile, "BCCToSelf", szString);
      sprintf (szString, "%d", gasAccount[nAccount].boCCBCC);
      SaveDetailMem (pfhFile, "CCBCC", szString);
      SaveDetailMem (pfhFile, "BCCEmail", gasAccount[nAccount].szBCCAddress);


      sprintf (szString, "%d", gasAccount[nAccount].eSMTPAuth);
      SaveDetailMem (pfhFile, "SMTPAuth", szString);
      sprintf (szString, "%d", gasAccount[nAccount].boSMTPUsePOP3Details);
      SaveDetailMem (pfhFile, "SMTPUsePOP3", szString);
      SaveDetailMem (pfhFile, "SMTPUsername",
        gasAccount[nAccount].szSMTPUsername);
      sprintf (szString, "%d", gasAccount[nAccount].boSMTPRememberPassword);
      SaveDetailMem (pfhFile, "SMTPRemember", szString);

      if (gasAccount[nAccount].boSMTPRememberPassword)
      {
        strcpy (szScramble, "TapirSMTP");
        strncat (szScramble, gasAccount[nAccount].szTitle,
          sizeof (szScramble) - 9);

        nLen = ((strlen (gasAccount[nAccount].szSMTPPassword)
          + 8) / 8) * 2 + 1;
        ScrambleData ((int*)gasAccount[nAccount].szSMTPPassword, anBuffer,
          nLen, szScramble);
        HexToString (szString, anBuffer, nLen);
        SaveDetailMem (pfhFile, "SMTPPassword", szString);
      }
      else
      {
        SaveDetailMem (pfhFile, "SMTPPassword", "");
      }

      for (nCount = 0; nCount < SIG_LINE_NUM; nCount++)
      {
        sprintf (szString, "SigLine%d", nCount);
        SaveDetailMem (pfhFile, szString,
          gasAccount[nAccount].szSigLine[nCount]);
      }
    }

    memclose (pfhFile);
  }
}

//////////////////////////////////////////////////////////////////
// Save a section name
void SaveSection (FILE * pfhFile, char * szSection)
{
  fputc ('\n', pfhFile);
  fputc ('[', pfhFile);
  fputs (szSection, pfhFile);
  fputc (']', pfhFile);
  fputc ('\n', pfhFile);
}

//////////////////////////////////////////////////////////////////
// Save details line
void SaveDetail (FILE * pfhFile, char * szName, char * szDetails)
{
  int                         nLength;

  fputs (szName, pfhFile);
  fputc (' ', pfhFile);
  fputc (':', pfhFile);
  fputc (' ', pfhFile);
  nLength = 0;
  while (szDetails[nLength] >= 0x20)
  {
    nLength++;
  }
  szDetails[nLength] = 0;
  fputs (szDetails, pfhFile);
  fputc ('\n', pfhFile);
}

//////////////////////////////////////////////////////////////////
// Save a section name to memory
void SaveSectionMem (MemFile * pfhFile, char * szSection)
{
  memputc ('\n', pfhFile);
  memputc ('[', pfhFile);
  memputs (szSection, pfhFile);
  memputc (']', pfhFile);
  memputc ('\n', pfhFile);
}

//////////////////////////////////////////////////////////////////
// Save details line to memory
void SaveDetailMem (MemFile * pfhFile, char * szName, char * szDetails)
{
  int                         nLength;

  memputs (szName, pfhFile);
  memputc (' ', pfhFile);
  memputc (':', pfhFile);
  memputc (' ', pfhFile);
  nLength = 0;
  while (szDetails[nLength] >= 0x20)
  {
    nLength++;
  }
  szDetails[nLength] = 0;
  memputs (szDetails, pfhFile);
  memputc ('\n', pfhFile);
}

//////////////////////////////////////////////////////////////////
// Write string to memory 'file'
int memputs (char * str, MemFile * psMemory)
{
  int                         nLength;
  int                         nNewSize;
  int                         nSuccess = 1;
  int                         nReturn;

  nLength = strlen (str);

  if ((psMemory->nPos + nLength + 16) >= psMemory->nSize)
  {
    nNewSize = (((psMemory->nSize + nLength + 16) + (MEMFILE_BLOCK - 1))
      & ~MEMFILE_BLOCK);
    nSuccess = flex_extend ((flex_ptr)& psMemory->pcMemory, nNewSize);

    if (nSuccess == 1)
    {
      psMemory->nSize = nNewSize;
    }
  }

  if (nSuccess == 1)
  {
    strncpy (psMemory->pcMemory + psMemory->nPos, str, nLength);
    psMemory->nPos += nLength;
    nReturn = nLength;
  }
  else
  {
    nReturn = EOF;
  }

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Write character to memory 'file'
int memputc (int c, MemFile * psMemory)
{
  int                         nNewSize;
  int                         nSuccess = 1;
  int                         nReturn;

  if ((psMemory->nPos + 1 + 16) >= psMemory->nSize)
  {
    nNewSize = (((psMemory->nSize + 1 + 16) + (MEMFILE_BLOCK - 1))
      & ~MEMFILE_BLOCK);
    nSuccess = flex_extend ((flex_ptr)& psMemory->pcMemory, nNewSize);

    if (nSuccess == 1)
    {
      psMemory->nSize = nNewSize;
    }
  }

  if (nSuccess == 1)
  {
    (char)psMemory->pcMemory[psMemory->nPos] = c;
    psMemory->nPos += 1;
    nReturn = c;
  }
  else
  {
    nReturn = EOF;
  }

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Load account details
bool LoadAccountDetails (void)
{
  int                         nAccount;
  char                        szString[STRING_LEN];
  char                        szStringExtra[STRING_LEN];
//  FILE                        *pfhFile;
  int                         nSectionPos;
  int                         anBuffer[STRING_LEN / 4];
  int                         nLen;
  char                        szScramble[STRING_LEN];
  MemFile                     *pfhFile;
  bool                        boReturn = TRUE;
  int                         nEnum;
  int                         nCount;

  pfhFile = memopen (ACCOUNTS_LOAD, "r");

  if (pfhFile)
  {
    nLen = strlen (Tag ("File"));
    memgets (szScramble, nLen + 1, pfhFile);
    if (strncmp (szScramble, Tag ("File"), nLen) == 0)
    {
      nSectionPos = FindSectionMem (pfhFile, "General");
      FindValueMem (pfhFile, nSectionPos, "Accounts",
        szString, sizeof (szString));
      sscanf (szString, "%d", & gnAccountNum);
      FindValueMem (pfhFile, nSectionPos, "DateFormat",
        gszDateFormat, sizeof (gszDateFormat));
      FindValueMem (pfhFile, nSectionPos, "Logging",
        szString, sizeof (szString));
      sscanf (szString, "%d", & gboLog);
      FindValueMem (pfhFile, nSectionPos, "DefaultAcc",
        szString, sizeof (szString));
      sscanf (szString, "%d", & gnDefaultAccount);

      FindValueMem (pfhFile, nSectionPos, "LocalFont",
        szString, sizeof (szString));
      FindValueMem (pfhFile, nSectionPos, "RemoteFont",
        szStringExtra, sizeof (szStringExtra));
      ChangeListFonts (szString, szStringExtra);

      FindValueMem (pfhFile, nSectionPos, "ColPos1",
        szString, sizeof (szString));
      sscanf (szString, "%d", & ganColWidth[1]);
      FindValueMem (pfhFile, nSectionPos, "ColPos2",
        szString, sizeof (szString));
      sscanf (szString, "%d", & ganColWidth[2]);
      FindValueMem (pfhFile, nSectionPos, "ColPos3",
        szString, sizeof (szString));
      sscanf (szString, "%d", & ganColWidth[3]);
      FindValueMem (pfhFile, nSectionPos, "ColPos4",
        szString, sizeof (szString));
      sscanf (szString, "%d", & ganColWidth[4]);
      FindValueMem (pfhFile, nSectionPos, "ColPos5",
        szString, sizeof (szString));
      sscanf (szString, "%d", & ganColWidth[5]);
      FindValueMem (pfhFile, nSectionPos, "ColPos6",
        szString, sizeof (szString));
      sscanf (szString, "%d", & ganColWidth[6]);

      FindValueMem (pfhFile, nSectionPos, "DeleteType",
        szString, sizeof (szString));
      sscanf (szString, "%d", & nEnum);
      switch (nEnum)
      {
        default:
        case 0: // DELETETYPE_GUESS
          SetDeleteType (DELETETYPE_GUESS);
          break;
        case 1: // DELETETYPE_OS4
          SetDeleteType (DELETETYPE_OS4);
          break;
        case 2: // DELETETYPE_OS5
          SetDeleteType (DELETETYPE_OS5);
          break;
      }
      FindValueMem (pfhFile, nSectionPos, "Emoticons",
        szString, sizeof (szString));
      sscanf (szString, "%d", & gboEmoticons);
#if defined MAX_SEND_LEN
      FindValueMem (pfhFile, nSectionPos, "MaxSend",
        szString, sizeof (szString));
      sscanf (szString, "%d", & gnMaxSendLen);
      FindValueMem (pfhFile, nSectionPos, "NetIdle",
        szString, sizeof (szString));
      sscanf (szString, "%d", & gnNullPollNetwork);

      FindValueMem (pfhFile, nSectionPos, "FastSend",
        szString, sizeof (szString));
      sscanf (szString, "%d", & gboFastSending);
#endif

      // Resize the main window
      SetMainExtent (-1);

      for (nAccount = 0; nAccount < gnAccountNum; nAccount++)
      {
        sprintf (szString, "Account %d", nAccount);
        nSectionPos = FindSectionMem (pfhFile, szString);
        FindValueMem (pfhFile, nSectionPos, "Title",
          gasAccount[nAccount].szTitle, TITLE_LEN);
        FindValueMem (pfhFile, nSectionPos, "Name",
          gasAccount[nAccount].szName, STRING_LEN);
        FindValueMem (pfhFile, nSectionPos, "Email",
          gasAccount[nAccount].szEmailAddress, STRING_LEN);
        FindValueMem (pfhFile, nSectionPos, "POP3Server",
          gasAccount[nAccount].szPOP3Server, STRING_LEN);
        FindValueMem (pfhFile, nSectionPos, "POP3Port", szString,
          sizeof (szString));
        sscanf (szString, "%d", & gasAccount[nAccount].nPOP3Port);
        FindValueMem (pfhFile, nSectionPos, "POP3Username",
          gasAccount[nAccount].szPOP3Username, STRING_LEN);
        FindValueMem (pfhFile, nSectionPos, "Remember", szString,
          sizeof (szString));
        sscanf (szString, "%d",
          & gasAccount[nAccount].boPOP3RememberPassword);

        if (gasAccount[nAccount].boPOP3RememberPassword)
        {
          strcpy (szScramble, "Tapir");
          strncat (szScramble, gasAccount[nAccount].szTitle,
            sizeof (szScramble) - 5);

          FindValueMem (pfhFile, nSectionPos, "POP3Password",
            szString, STRING_LEN);
          nLen = ((strlen (szString) + 7) / 8) * 2 + 1;
          StringToHex (szString, anBuffer, (STRING_LEN / 4));
          UnscrambleData (anBuffer,
            (int*)gasAccount[nAccount].szPOP3Password, nLen, szScramble);
        }
        else
        {
          strcpy (gasAccount[nAccount].szPOP3Password, "");
        }

        FindValueMem (pfhFile, nSectionPos, "SMTPServer",
          gasAccount[nAccount].szSMTPServer, STRING_LEN);
        FindValueMem (pfhFile, nSectionPos, "SMTPPort", szString,
          sizeof (szString));
        sscanf (szString, "%d", & gasAccount[nAccount].nSMTPPort);

        FindValueMem (pfhFile, nSectionPos, "BCCToSelf", szString,
          sizeof (szString));
        sscanf (szString, "%d", & gasAccount[nAccount].boBCCToSelf);
        FindValueMem (pfhFile, nSectionPos, "CCBCC", szString,
          sizeof (szString));
        sscanf (szString, "%d", & gasAccount[nAccount].boCCBCC);
        FindValueMem (pfhFile, nSectionPos, "BCCEmail",
          gasAccount[nAccount].szBCCAddress, STRING_LEN);


        FindValueMem (pfhFile, nSectionPos, "SMTPAuth", szString,
          sizeof (szString));
        sscanf (szString, "%d", & nEnum);
        switch (nEnum)
        {
          default:
          case 0: // SMTPAUTH_NONE
            gasAccount[nAccount].eSMTPAuth = SMTPAUTH_NONE;
            break;
          case 1: // SMTPAUTH_PLAIN
            gasAccount[nAccount].eSMTPAuth = SMTPAUTH_PLAIN;
            break;
          case 2: // SMTPAUTH_LOGIN
            gasAccount[nAccount].eSMTPAuth = SMTPAUTH_LOGIN;
            break;
          case 3: // SMTPAUTH_CRAMMD5
            gasAccount[nAccount].eSMTPAuth = SMTPAUTH_CRAMMD5;
            break;
        }

        FindValueMem (pfhFile, nSectionPos, "SMTPUsePOP3", szString,
          sizeof (szString));
        sscanf (szString, "%d", & gasAccount[nAccount].boSMTPUsePOP3Details);
        FindValueMem (pfhFile, nSectionPos, "SMTPUsername",
          gasAccount[nAccount].szSMTPUsername, STRING_LEN);

        FindValueMem (pfhFile, nSectionPos, "SMTPRemember", szString,
          sizeof (szString));
        sscanf (szString, "%d",
          & gasAccount[nAccount].boSMTPRememberPassword);

        if (gasAccount[nAccount].boSMTPRememberPassword)
        {
          strcpy (szScramble, "TapirSMTP");
          strncat (szScramble, gasAccount[nAccount].szTitle,
            sizeof (szScramble) - 9);

          FindValueMem (pfhFile, nSectionPos, "SMTPPassword",
            szString, STRING_LEN);
          nLen = ((strlen (szString) + 7) / 8) * 2 + 1;
          StringToHex (szString, anBuffer, (STRING_LEN / 4));
          UnscrambleData (anBuffer,
            (int*)gasAccount[nAccount].szSMTPPassword, nLen, szScramble);
        }
        else
        {
          strcpy (gasAccount[nAccount].szSMTPPassword, "");
        }

        for (nCount = 0; nCount < SIG_LINE_NUM; nCount++)
        {
          sprintf (szString, "SigLine%d", nCount);
          FindValueMem (pfhFile, nSectionPos, szString,
            gasAccount[nAccount].szSigLine[nCount], SIG_LINE_LENGTH);
        }
      }
      OpenDefaultAccount ();
    }
    else
    {
      boReturn = FALSE;
    }

    memclose (pfhFile);
  }

  return boReturn;
}

//////////////////////////////////////////////////////////////////
// Find the specified section and return its file position
int FindSection (FILE * pfhFile, char * szSection)
{
  char                        szString[1024];
  char                        *szReturn;
  int                         nReturn;
  char                        *szEnd;

  fseek (pfhFile, 0, SEEK_SET);

  nReturn = EOF;

  do
  {
    do
    {
      szReturn = fgets (szString, sizeof (szString), pfhFile);
    } while (szReturn && (szString[0] != '['));

    if (szReturn)
    {
      szEnd = strchr (szString, ']');
      if (szEnd)
      {
        szEnd[0] = 0;
        if (strcmp (szSection, (szString + 1)) == 0)
        {
          nReturn = ftell (pfhFile);
        }
      }
    }
  } while (szReturn && (nReturn == EOF));

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Find the value of the specified variable
bool FindValue (FILE * pfhFile, int nSection, char * szName, char * szValue, int nValueLen)
{
  char                        szString[1024];
  char                        *szReturn;
  bool                        boReturn = FALSE;
  char                        *szEnd;
  char                        *szStart;
  int                         nPos;

  fseek (pfhFile, nSection, SEEK_SET);

  do
  {
    szReturn = fgets (szString, sizeof (szString), pfhFile);

    if (szReturn)
    {
      if (szReturn[0] == '[')
      {
        szReturn = NULL;
      }
      else
      {
        nPos = 0;
        while ((nPos < ((int)sizeof (szString) - 1))
          && (szReturn[nPos] >= 0x20))
        {
          nPos++;
        }
        szReturn[nPos] = 0;

        szStart = strchr (szString, ':');
        if (szStart > szString)
        {
          szEnd = szStart - 1;
          while ((szEnd > szString) && (szEnd[0] == ' '))
          {
            szEnd--;
          }

          if (strncmp (szName, szString, (szEnd - szString + 1)) == 0)
          {
            szStart++;
            while (szStart[0] == ' ')
            {
              szStart++;
            }
            strncpy (szValue, szStart, nValueLen);
            boReturn = TRUE;
          }
        }
      }
    }
  } while ((szReturn) && (!boReturn));

  if (!boReturn)
  {
    szValue[0] = 0;
  }

  return boReturn;
}

//////////////////////////////////////////////////////////////////
// Read a string in from memory, terminating on newline/null etc..
char * memgets (char * str, int n, MemFile * psMemory)
{
  int                         nPos;
  char                        *szReturn;

  if (psMemory->nPos >= psMemory->nSize)
  {
    szReturn = NULL;
  }
  else
  {
    nPos = 0;
    while ((nPos < (n - 1)) && (psMemory->nPos < psMemory->nSize)
      && (psMemory->pcMemory[psMemory->nPos] >= 0x20))
    {
      str[nPos] = psMemory->pcMemory[psMemory->nPos];
      nPos++;
      psMemory->nPos++;
    }
    str[nPos] = 0;
    psMemory->nPos++;

    szReturn = str;
  }

  return szReturn;
}

//////////////////////////////////////////////////////////////////
// Set the 'file' position in memory
int memseek (MemFile * psMemory, int pos, int from)
{
  int                         nReturn = 0;

  switch (from)
  {
    case SEEK_SET:
      psMemory->nPos = pos;
      break;
    case SEEK_CUR:
      psMemory->nPos += pos;
      break;
    case SEEK_END:
      psMemory->nPos += psMemory->nSize - pos;
      break;
    default:
      nReturn = 1;
      break;
  }

  if (psMemory->nPos < 0)
  {
    psMemory->nPos = 0;
    nReturn = 1;
  }
  if (psMemory->nPos >= psMemory->nSize)
  {
    psMemory->nPos = psMemory->nSize;
    nReturn = 1;
  }

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Read the 'file' position in memory
int memtell (MemFile * psMemory)
{
  int                         nReturn;

  if (psMemory->nPos >= psMemory->nSize)
  {
    nReturn = EOF;
  }
  else
  {
    nReturn = psMemory->nPos;
  }

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Find the specified section and return its memory position
int FindSectionMem (MemFile * pfhFile, char * szSection)
{
  char                        szString[1024];
  char                        *szReturn;
  int                         nReturn;
  char                        *szEnd;

  memseek (pfhFile, 0, SEEK_SET);

  nReturn = EOF;

  do
  {
    do
    {
      szReturn = memgets (szString, sizeof (szString), pfhFile);
    } while (szReturn && (szString[0] != '['));

    if (szReturn)
    {
      szEnd = strchr (szString, ']');
      if (szEnd)
      {
        szEnd[0] = 0;
        if (strcmp (szSection, (szString + 1)) == 0)
        {
          nReturn = memtell (pfhFile);
        }
      }
    }
  } while (szReturn && (nReturn == EOF));

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Find the value of the specified variable from memory
bool FindValueMem (MemFile * pfhFile, int nSection, char * szName, char * szValue, int nValueLen)
{
  char                        szString[1024];
  char                        *szReturn;
  bool                        boReturn = FALSE;
  char                        *szEnd;
  char                        *szStart;
  int                         nPos;

  memseek (pfhFile, nSection, SEEK_SET);

  do
  {
    szReturn = memgets (szString, sizeof (szString), pfhFile);

    if (szReturn)
    {
      if (szReturn[0] == '[')
      {
        szReturn = NULL;
      }
      else
      {
        nPos = 0;
        while ((nPos < ((int)sizeof (szString) - 1))
          && (szReturn[nPos] >= 0x20))
        {
          nPos++;
        }
        szReturn[nPos] = 0;

        szStart = strchr (szString, ':');
        if (szStart > szString)
        {
          szEnd = szStart - 1;
          while ((szEnd > szString) && (szEnd[0] == ' '))
          {
            szEnd--;
          }

          if (strncmp (szName, szString, (szEnd - szString + 1)) == 0)
          {
            szStart++;
            while (szStart[0] == ' ')
            {
              szStart++;
            }
            strncpy (szValue, szStart, nValueLen);
            boReturn = TRUE;
          }
        }
      }
    }
  } while ((szReturn) && (!boReturn));

  if (!boReturn)
  {
    szValue[0] = 0;
  }

  return boReturn;
}

//////////////////////////////////////////////////////////////////
// Act on a mouse click in the main window button bar
void MouseClickMaHeWorkArea (int nXPos, int nYPos, int nButton)
{
  int                   nColumn;
  bool                  boFound;
  bool                  boGap;

  boFound = FALSE;
  boGap = FALSE;

  if ((nYPos > (-HEADER_HEIGHT - BUTTON_YOFFSET))
    && (nYPos < (-BUTTON_YOFFSET)))
  {
    nColumn = (COLUMNS_MAX - 1);
    while ((nColumn > 0) && (!boFound))
    {
      if ((nXPos > (ganColWidth[nColumn] + COLUMN_XOFFSET - COLUMN_GAP))
        && (nXPos < (ganColWidth[nColumn] + COLUMN_XOFFSET + COLUMN_GAP)))
      {
        boFound = TRUE;
        boGap = TRUE;
      }
      else
      {
        if ((nXPos >= (ganColWidth[nColumn - 1] + COLUMN_XOFFSET
          + COLUMN_GAP))
          && (nXPos <= (ganColWidth[nColumn] + COLUMN_XOFFSET - COLUMN_GAP)))
        {
          boFound = TRUE;
        }
      }
      nColumn--;
    }
  }

  if (boFound)
  {
    if (!boGap)
    {
      if (nButton == wimp_CLICK_SELECT)
      {
        switch (nColumn)
        {
          case 0: // Message status
            SortEmails (CompareMailStateIncreasing);
            break;
          case 1: // Message number
            SortEmails (CompareMsgNumIncreasing);
            break;
          case 2: // Size
            SortEmails (CompareSizeIncreasing);
            break;
          case 3: // Sender
            SortEmails (CompareSenderIncreasing);
            break;
          case 4: // Subject
            SortEmails (CompareSubjectIncreasing);
            break;
          case 5: // Date
            SortEmails (CompareDateIncreasing);
            break;
          default:
            break;
        }
      }
      if (nButton == wimp_CLICK_ADJUST)
      {
        switch (nColumn)
        {
          case 0: // Message status
            SortEmails (CompareMailStateDecreasing);
            break;
          case 1: // Message number
            SortEmails (CompareMsgNumDecreasing);
            break;
          case 2: // Size
            SortEmails (CompareSizeDecreasing);
            break;
          case 3: // Sender
            SortEmails (CompareSenderDecreasing);
            break;
          case 4: // Subject
            SortEmails (CompareSubjectDecreasing);
            break;
          case 5: // Date
            SortEmails (CompareDateDecreasing);
            break;
          default:
            break;
        }
      }
    }
    else
    {
      if ((nButton == wimp_DRAG_SELECT)
        || (nButton == wimp_DRAG_ADJUST))
      {
        DragColumnWidth (nXPos, nYPos, nColumn + 1);
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Sort the email list
void SortEmails (bool (*Compare)(int, int))
{
  bool                  boDone;
  bool                  boSwitch;
  int                   nEmail;
  int                   nSwap;

  do
  {
    boDone = TRUE;
    for (nEmail = 0; nEmail < (gnDetailsNum - 1); nEmail++)
    {
      boSwitch = Compare (ganSort[nEmail], ganSort[(nEmail + 1)]);
      if (boSwitch)
      {
        boDone = FALSE;
        nSwap = ganSort[nEmail];
        ganSort[nEmail] = ganSort[(nEmail + 1)];
        ganSort[(nEmail + 1)] = nSwap;
        gasDetails[ganSort[nEmail]].nSortPos = nEmail;
        gasDetails[ganSort[nEmail + 1]].nSortPos = (nEmail + 1);
      }
    }
  } while (!boDone);

  UpdateMain (-1, -1);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareSizeIncreasing (int nEmail1, int nEmail2)
{
  return (gasDetails[nEmail1].nServerSize > gasDetails[nEmail2].nServerSize);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareSizeDecreasing (int nEmail1, int nEmail2)
{
  return (gasDetails[nEmail1].nServerSize < gasDetails[nEmail2].nServerSize);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareMsgNumIncreasing (int nEmail1, int nEmail2)
{
  return (gasDetails[nEmail1].nMsgNum > gasDetails[nEmail2].nMsgNum);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareMsgNumDecreasing (int nEmail1, int nEmail2)
{
  return (gasDetails[nEmail1].nMsgNum < gasDetails[nEmail2].nMsgNum);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareSenderIncreasing (int nEmail1, int nEmail2)
{
  return (cmpstr (gasDetails[nEmail1].szSenderDisplay,
    gasDetails[nEmail2].szSenderDisplay) < 0);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareSenderDecreasing (int nEmail1, int nEmail2)
{
  return (cmpstr (gasDetails[nEmail1].szSenderDisplay,
    gasDetails[nEmail2].szSenderDisplay) > 0);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareSubjectIncreasing (int nEmail1, int nEmail2)
{
  return (cmpstr (gasDetails[nEmail1].szSubject,
    gasDetails[nEmail2].szSubject) < 0);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareSubjectDecreasing (int nEmail1, int nEmail2)
{
  return (cmpstr (gasDetails[nEmail1].szSubject,
    gasDetails[nEmail2].szSubject) > 0);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareDateIncreasing (int nEmail1, int nEmail2)
{
  int                   nPos;
  int                   nDiff = 0;

  for (nPos = 4; ((nPos >= 0) && (nDiff == 0)); nPos--)
  {
    if (gasDetails[nEmail1].pcDate[nPos]
      < (gasDetails[nEmail2].pcDate[nPos]))
    {
      nDiff = -1;
    }
    if (gasDetails[nEmail1].pcDate[nPos]
      > (gasDetails[nEmail2].pcDate[nPos]))
    {
      nDiff = +1;
    }
  }

  return (nDiff > 0);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareDateDecreasing (int nEmail1, int nEmail2)
{
  int                   nPos;
  int                   nDiff = 0;

  for (nPos = 4; ((nPos >= 0) && (nDiff == 0)); nPos--)
  {
    if (gasDetails[nEmail1].pcDate[nPos]
      < (gasDetails[nEmail2].pcDate[nPos]))
    {
      nDiff = -1;
    }
    if (gasDetails[nEmail1].pcDate[nPos]
      > (gasDetails[nEmail2].pcDate[nPos]))
    {
      nDiff = +1;
    }
  }

  return (nDiff < 0);
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareMailStateIncreasing (int nEmail1, int nEmail2)
{
  return ((int)(gasDetails[nEmail1].eMailState) >
    (int)(gasDetails[nEmail2].eMailState));
}

//////////////////////////////////////////////////////////////////
// Compare the ordering of two emails
bool CompareMailStateDecreasing (int nEmail1, int nEmail2)
{
  return ((int)(gasDetails[nEmail1].eMailState) <
    (int)(gasDetails[nEmail2].eMailState));
}

//////////////////////////////////////////////////////////////////
// Compare two strings
int cmpstr (char * szString1, char * szString2)
{
  int                   nPos;
  int                   nReturn = 0;
  char                  cChar1;
  char                  cChar2;

  nPos = -1;
  do
  {
    nPos++;

    cChar1 = szString1[nPos];
    cChar2 = szString2[nPos];

    if ((cChar1 >= 'A') && (cChar1 <= 'Z'))
    {
      cChar1 += ('a' - 'A');
    }
    if ((cChar2 >= 'A') && (cChar2 <= 'Z'))
    {
      cChar2 += ('a' - 'A');
    }

    if (cChar1 < cChar2)
    {
      nReturn = +1;
    }
    if (cChar1 > cChar2)
    {
      nReturn = -1;
    }
  } while ((nReturn == 0) && (cChar1 != 0)  && (cChar2 != 0));

  return nReturn;
}

//////////////////////////////////////////////////////////////////
// Read the time string and store a 5 byte UTC time
void InterpretDate (char * szTime, char * pcUTCTime)
{
  int                   nDate;
  char                  szMonth[4];
  int                   nYear;
  int                   nHour;
  int                   nMinute;
  int                   nSecond;
  territory_ordinals    sOrdinals;
  int                   nReturn;

  nReturn = sscanf (szTime, "%*3s, %2d %3s %d %2d:%2d:%2d %*s",
    & nDate, szMonth, & nYear,
    & nHour, & nMinute, & nSecond);

  if (nReturn != 6)
  {
    nReturn = sscanf (szTime, "%2d %3s %d %2d:%2d:%2d %*s",
      & nDate, szMonth, & nYear,
      & nHour, & nMinute, & nSecond);
  }

  if (nReturn != 6)
  {
    nDate = 0;
    strcpy(szMonth,"");
    nYear = 0;
    nHour = 0;
    nMinute = 0;
    nSecond = 0;
  }

  sOrdinals.centisecond = 0;
  sOrdinals.second = nSecond;
  sOrdinals.minute = nMinute;
  sOrdinals.hour = nHour;
  sOrdinals.date = nDate;

  if (strcmp (szMonth, "Jan") == 0)
  {
    sOrdinals.month = 1;
  }
  if (strcmp (szMonth, "Feb") == 0)
  {
    sOrdinals.month = 2;
  }
  if (strcmp (szMonth, "Mar") == 0)
  {
    sOrdinals.month = 3;
  }
  if (strcmp (szMonth, "Apr") == 0)
  {
    sOrdinals.month = 4;
  }
  if (strcmp (szMonth, "May") == 0)
  {
    sOrdinals.month = 5;
  }
  if (strcmp (szMonth, "Jun") == 0)
  {
    sOrdinals.month = 6;
  }
  if (strcmp (szMonth, "Jul") == 0)
  {
    sOrdinals.month = 7;
  }
  if (strcmp (szMonth, "Aug") == 0)
  {
    sOrdinals.month = 8;
  }
  if (strcmp (szMonth, "Sep") == 0)
  {
    sOrdinals.month = 9;
  }
  if (strcmp (szMonth, "Oct") == 0)
  {
    sOrdinals.month = 10;
  }
  if (strcmp (szMonth, "Nov") == 0)
  {
    sOrdinals.month = 11;
  }
  if (strcmp (szMonth, "Dec") == 0)
  {
    sOrdinals.month = 12;
  }

  if (nYear < 100)
  {
    nYear += 2000;
  }

  sOrdinals.year = nYear;
  sOrdinals.weekday = 0;
  sOrdinals.yearday = 0;

  xterritory_convert_ordinals_to_time (territory_CURRENT,
    (os_date_and_time *)pcUTCTime, & sOrdinals);
}

//////////////////////////////////////////////////////////////////
// Read the time from a 5 byte UTC time and write it to a string
void DateToText (char * pcUTCTime, char * szDate, int nStringLen)
{
  if ((pcUTCTime[0] == 0) && (pcUTCTime[1] == 0) && (pcUTCTime[2] == 0)
    && (pcUTCTime[3] == 0) && (pcUTCTime[4] == 0))
  {
    strcpy (szDate, "");
  }
  else
  {
    xterritory_convert_date_and_time (territory_CURRENT,
      (os_date_and_time const *)pcUTCTime, szDate, nStringLen,
      gszDateFormat, NULL);
  }
}

//////////////////////////////////////////////////////////////////
// Copy the sender to the field that will be displayed
void CopySenderDisplay (char * szCopyTo, char * szSender)
{
  char                  *szStart;
  char                  *szEnd;
  bool                  boCopied = FALSE;

  szStart = strchr (szSender, '"');
  if (szStart)
  {
    szEnd = strchr (szStart + 1, '"');

    if (szEnd > (szStart + 1))
    {
      strncpy (szCopyTo, szStart + 1, (szEnd - szStart - 1));
      boCopied = TRUE;
    }
  }

  if (!boCopied)
  {
    szEnd = strchr (szSender, '<');

    if (szEnd)
    {
      szEnd--;
      while ((szEnd > szSender) && ((szEnd[0] == ' ') || (szEnd[0] == '"')))
      {
        szEnd--;
      }

      szStart = szSender;
      while (((szStart[0] == ' ') || (szStart[0] == '"'))
        && (szStart < szEnd))
      {
        szStart++;
      }

      if (szStart < szEnd)
      {
        strncpy (szCopyTo, szStart, (szEnd - szStart + 1));
        boCopied = TRUE;
      }
    }
  }

  if (!boCopied)
  {
    szStart = strchr (szSender, '<');
    if (szStart)
    {
      szEnd = strchr (szStart + 1, '>');

      if (szEnd > (szStart + 1))
      {
        strncpy (szCopyTo, szStart + 1, (szEnd - szStart - 1));
        boCopied = TRUE;
      }
    }
  }

  if (!boCopied)
  {
    strcpy (szCopyTo, szSender);
    boCopied = TRUE;
  }

  if (!boCopied)
  {
    strcpy (szCopyTo, "");
  }
}

//////////////////////////////////////////////////////////////////
// Copy the size to a string in shortened format
void CopySize (int nSize, char * szCopyTo)
{
  if (nSize > (1024 * 1024))
  {
    nSize = (nSize + (1024 * 1024 / 2)) / (1024 * 1024);
    sprintf (szCopyTo, "%dM", nSize);
  }
  else
  {
    nSize = (nSize + (1024 / 2)) / (1024);
    sprintf (szCopyTo, "%dK", nSize);
  }
}

//////////////////////////////////////////////////////////////////
// Initiate an outline drag from the dimensions of the given icon
void DragColumnWidth (int nXPos, int nYPos, int nColumn)
{
  int                         nXinc;
  int                         nYinc;
  wimp_window_state           sWindowState;
  wimp_drag                   sDragInfo;

  if (!gboDrag)
  {
    sWindowState.w = gwhMaHe;
    xwimp_get_window_state (& sWindowState);

    nXinc = sWindowState.visible.x0 - sWindowState.xscroll;
    nYinc = sWindowState.visible.y1 - sWindowState.yscroll;

    sDragInfo.w = 0;
    sDragInfo.type = wimp_DRAG_USER_POINT;
    sDragInfo.initial.x0 = nXPos;
    sDragInfo.initial.y0 = nYPos;
    sDragInfo.initial.x1 = nXPos;
    sDragInfo.initial.y1 = nYPos;
    sDragInfo.bbox.x0 = sWindowState.visible.x0 - sWindowState.xscroll
      + ganColWidth[nColumn - 1] + COLUMN_XOFFSET;
    sDragInfo.bbox.y0 = sWindowState.visible.y1 - BUTTON_YOFFSET
      - HEADER_HEIGHT;
    sDragInfo.bbox.x1 = sDragInfo.bbox.x0 + COLUMN_WIDTH_MAX;
    sDragInfo.bbox.y1 = sWindowState.visible.y1 - BUTTON_YOFFSET;
    sDragInfo.handle = NULL;
    sDragInfo.draw = NULL;
    sDragInfo.undraw = NULL;
    sDragInfo.redraw = NULL;

    xwimp_drag_box (& sDragInfo);

    gnDragColumn = nColumn;
    gnColumnXPosStart = nXPos;
    geSaveType = SAVETYPE_COLUMN;

    SetNullPollActive (NULLPOLL_ACTIVE_FAST);
    gboDrag = TRUE;
  }
}

//////////////////////////////////////////////////////////////////
// Set the given column width
void SetColumnWidth (int nColumn, int nWidth)
{
  int                         nXInc;
  int                         nLoop;
  int                         nXMin;
  wimp_window_state           sWindowState;
  int                         nEllipsisWidth;

  if (nWidth < ganColWidth[nColumn - 1])
  {
    nWidth = ganColWidth[nColumn - 1];
  }

  if (ganColWidth[nColumn] != nWidth)
  {
    if (gnEllipsisWidthB > gnEllipsisWidth)
    {
      nEllipsisWidth = gnEllipsisWidthB / MILLIPOINT;
    }
    else
    {
      nEllipsisWidth = gnEllipsisWidth / MILLIPOINT;
    }

    nXMin = ganColWidth[nColumn] + COLUMN_REDRAW_ADD - nEllipsisWidth * 2;
    nXInc = nWidth - ganColWidth[nColumn];

    for (nLoop = nColumn; nLoop < COLUMNS_MAX; nLoop++)
    {
      ganColWidth[nLoop] += nXInc;
    }
    SetMainExtent (-1);

    if (nXInc < 0)
    {
      nXMin = ganColWidth[nColumn] + COLUMN_REDRAW_ADD - nEllipsisWidth * 2;
    }

    if (nXMin < ganColWidth[nColumn - 1])
    {
      nXMin = ganColWidth[nColumn - 1];
    }

    xwimp_force_redraw (gwhMaHe, nXMin + COLUMN_XOFFSET,
      - BUTTON_YOFFSET - HEADER_HEIGHT,
      ganColWidth[COLUMNS_MAX - 1] + COLUMN_XOFFSET,
      - BUTTON_YOFFSET);

    sWindowState.w = gwhMain;
    xwimp_get_window_state (& sWindowState);

    xwimp_force_redraw (gwhMain, nXMin + COLUMN_XOFFSET,
      sWindowState.visible.y0 - sWindowState.visible.y1
      + sWindowState.yscroll,
      ganColWidth[COLUMNS_MAX - 1] + COLUMN_XOFFSET,
      + sWindowState.yscroll);
  }
}

//////////////////////////////////////////////////////////////////
// Set the given column width from a screen position
void SetColumnFromScreen (int nColumn, int nXPos)
{
  wimp_window_state           sWindowState;
  int                         nXWin;
  int                         nChange;

  sWindowState.w = gwhMaHe;
  xwimp_get_window_state (& sWindowState);

  nXWin = nXPos - sWindowState.visible.x0 + sWindowState.xscroll;

  nChange = nXWin - ganColWidth[nColumn] + sWindowState.visible.x1;

  SetColumnWidth (nColumn, nXWin);

  sWindowState.visible.x1 = nChange;
  xwimp_open_window ((wimp_open *)& sWindowState);

  sWindowState.w = gwhMain;
  xwimp_get_window_state (& sWindowState);
  sWindowState.visible.x1 = nChange;
  xwimp_open_window ((wimp_open *)& sWindowState);
}

//////////////////////////////////////////////////////////////////
// Change th pointer shape if it is over a column edge
void CheckColumnEdgePointer (int nXPos, int nYPos)
{
  wimp_window_state           sWindowState;
  int                         nColumn;
  bool                        boGap;

  sWindowState.w = gwhMaHe;
  xwimp_get_window_state (& sWindowState);

  nXPos = nXPos - sWindowState.visible.x0 + sWindowState.xscroll;
  nYPos = nYPos - sWindowState.visible.y1 + sWindowState.yscroll;

  boGap = FALSE;

  if ((nYPos > (-HEADER_HEIGHT - BUTTON_YOFFSET))
    && (nYPos < (-BUTTON_YOFFSET)))
  {
    nColumn = (COLUMNS_MAX - 1);
    while ((nColumn > 0) && (!boGap))
    {
      if ((nXPos > (ganColWidth[nColumn] + COLUMN_XOFFSET - COLUMN_GAP))
        && (nXPos < (ganColWidth[nColumn] + COLUMN_XOFFSET + COLUMN_GAP)))
      {
        boGap = TRUE;
      }
      nColumn--;
    }
  }

  if (!boGap && (gboColumnPointer))
  {
    // Remove column pointer
    gboColumnPointer = FALSE;
    xwimpspriteop_set_pointer_shape ("ptr_default", 97, 0, 0, NULL,
      NULL);
  }

  if (boGap && (!gboColumnPointer))
  {
    // Invoke column pointer
    gboColumnPointer = TRUE;
    xwimpspriteop_set_pointer_shape (COLUMN_PTR, 97, COLUMN_PTR_X,
      COLUMN_PTR_Y, NULL, NULL);
  }
}

//////////////////////////////////////////////////////////////////
// Sets up the email list for the emails to be saved
void SetEmailSave (int nEmailNum, bool boEdit)
{
  ganEmailSave[0] = nEmailNum;
  gboEditSave = boEdit;
  gnEmailSaveNum = 1;
  gnEmailSavePos = 0;
}

//////////////////////////////////////////////////////////////////
// Calculates the size of the emails to be save
int EmailSaveSize (void)
{
  int                         nCount;
  int                         nSize = 0;

  if (gboEditSave)
  {
    for (nCount = 0; nCount < gnEmailSaveNum; nCount++)
    {
      nSize += gasEdit[ganEmailSave[nCount]].nSize;
    }
  }
  else
  {
    for (nCount = 0; nCount < gnEmailSaveNum; nCount++)
    {
      if (gasDetails[ganEmailSave[nCount]].szPreMIMEEmail)
      {
        nSize += gasDetails[ganEmailSave[nCount]].nPreMIMESize;
      }
      else
      {
        nSize += gasDetails[ganEmailSave[nCount]].nSize;
      }
    }
  }
  return nSize;
}

//////////////////////////////////////////////////////////////////
// Sets up the email list from the selection for the emails to be saved
bool SetEmailSaveSelection ()
{
  int                         nCount;
  bool                        boSuccess;

  boSuccess = TRUE;
  gnSelected = 0;
  gnEmailSaveNum = 0;
  for (nCount = 0; ((nCount < gnDetailsNum) && boSuccess); nCount++)
  {
    if (gasDetails[nCount].boSelected)
    {
      gnSelected++;
      if (gasDetails[nCount].szRawEmail != NULL)
      {
        ganEmailSave[gnEmailSaveNum] = nCount;
        gnEmailSaveNum++;
      }
      else
      {
        boSuccess = FALSE;
      }
    }
  }
  if (gnEmailSaveNum == 0)
  {
    boSuccess = FALSE;
  }
  if (!boSuccess)
  {
    gnEmailSaveNum = 0;
  }
  gboEditSave = FALSE;
  gnEmailSavePos = 0;

  return boSuccess;
}

//////////////////////////////////////////////////////////////////
// Create an email to a particular address
int CreateEditWindowAddress (char * szAddress)
{
  int                         nEditNum;

  nEditNum = CreateEditWindow ();
  if (nEditNum >= 0)
  {
    SetIconText (szAddress, gasEdit[nEditNum].whHead, (wimp_i)0);
  }

  return nEditNum;
}

//////////////////////////////////////////////////////////////////
// Create a forwarded message
void CreateForwardMessage (int nEmailNum)
{
  int                         nEditNum;
  int                         nStartLine;
  int                         nEndLine;
  int                         nSize;
  char                        szLine[1024];
  char                        szDate[512];
  int                         nInsertLine;
  int                         nToLine;
  bool                        boFound;
  int                         nInsertPos;
  int                         nAttachment;
  MIMEDetails                 *psAttach;
  MIMEEditDetails             *psEditAttach;
  int                         nSuccess;
  int                         nSizePre;
  int                         nSizePost;
  int                         nStartPos;
  int                         nAttachNum;
  char                        szNumber[6];
  int                         nAttachTo;

  nEditNum = CreateEditWindow ();

  if (nEditNum >= 0)
  {
    nInsertLine = 0;
    nInsertPos = 0;

    // Insert header information
    nSize = sprintf (szLine, "%s\n", Tag ("ForwardBegin"));
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);
    nInsertLine++;
    nInsertPos += nSize;

    // Insert Date
    if ((gasDetails[nEmailNum].pcDate[0] != 0)
      || (gasDetails[nEmailNum].pcDate[1] != 0)
      || (gasDetails[nEmailNum].pcDate[2] != 0)
      || (gasDetails[nEmailNum].pcDate[3] != 0)
      || (gasDetails[nEmailNum].pcDate[4] != 0))
    {
      xterritory_convert_date_and_time (territory_CURRENT,
        (os_date_and_time const *)gasDetails[nEmailNum].pcDate,
        szDate, sizeof (szDate),
        FORWARD_DATE_FORMAT, NULL);
      nSize = sprintf (szLine, "Date: %s\n", szDate);
      InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);
      nInsertLine++;
      nInsertPos += nSize;
    }

    // Insert From
    nSize = sprintf (szLine, "From: %s\n", gasDetails[nEmailNum].szSender);
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);
    nInsertLine++;
    nInsertPos += nSize;

    // Copy over the 'To:' lines
    nToLine = -1;
    boFound = FALSE;
    while ((nToLine < gasDetails[nEmailNum].nHeaderEndLine) && (!boFound))
    {
      nToLine++;
      if ((strncmp ((gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nToLine]), "To:", 3) == 0)
        || (strncmp ((gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nToLine]), "TO:", 3) == 0))
      {
        boFound = TRUE;
      }
    }

    if (boFound)
    {
      while (boFound)
      {
        nSize = gasDetails[nEmailNum].anRawLine[nToLine + 1]
          - gasDetails[nEmailNum].anRawLine[nToLine];
        InsertText (nEditNum, nInsertPos, nInsertLine,
          gasDetails[nEmailNum].szRawEmail
          + gasDetails[nEmailNum].anRawLine[nToLine], nSize);
        nInsertLine++;
        nInsertPos += nSize;
        nToLine++;
        if (gasDetails[nEmailNum].szRawEmail[
          gasDetails[nEmailNum].anRawLine[nToLine]] != ' ')
        {
          boFound = FALSE;
        }
      }
    }

    // Insert Subject
    nSize = sprintf (szLine, "Subject: %s\n",
      gasDetails[nEmailNum].szSubject);
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);
    nInsertLine++;
    nInsertPos += nSize;

    nSize = sprintf (szLine, "\n");
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);
    nInsertLine++;
    nInsertPos += nSize;

    // Insert footer information
    nSize = sprintf (szLine, "\n%s\n", Tag ("ForwardEnd"));
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);

    // Copy the email contents
    nSize = gasDetails[nEmailNum].nSize
      - gasDetails[nEmailNum].anRawLine[
      gasDetails[nEmailNum].nHeaderEndLine];
    InsertText (nEditNum, nInsertPos, nInsertLine,
      gasDetails[nEmailNum].szRawEmail
      + gasDetails[nEmailNum].anRawLine[
      gasDetails[nEmailNum].nHeaderEndLine], nSize);

    ReFormat (nEditNum, 0, -1, & nStartLine, & nEndLine);
    UpdateEditWindow (nEditNum, nStartLine,
      nEndLine);

    // Fill out header fields
    if (strncmp (gasDetails[nEmailNum].szSubject, "Fw:", 3) == 0)
    {
      strncpy (szLine, gasDetails[nEmailNum].szSubject, sizeof (szLine));
    }
    else
    {
      strcpy (szLine, "Fw: ");
      strncat (szLine, gasDetails[nEmailNum].szSubject,
        (sizeof (szLine) - 4));
    }
    SetIconText (szLine, gasEdit[nEditNum].whHead, (wimp_i)1);

    // Transfer any attachments (requires a bit of work)
    if (gasDetails[nEmailNum].nMIMEListNum > 0)
    {
      nAttachNum = gasDetails[nEmailNum].nMIMEListNum - 1;
      if (nAttachNum > ATTACHMENT_EDIT_MAX)
      {
        nAttachNum = ATTACHMENT_EDIT_MAX;
        sprintf(szNumber, "%d", ATTACHMENT_EDIT_MAX);
        ShowWarningTagArg ("Er46", szNumber);
      }
      nAttachTo = 0;
      for (nAttachment = 0; nAttachment < nAttachNum; nAttachment++)
      {
        // Skip the first attachment (since it's most likely the email text)
        psAttach = & gasDetails[nEmailNum].asMIMEList[(nAttachment + 1)];
        psEditAttach = & gasEdit[nEditNum].asAttachments[nAttachTo];
        FreeMIMEEditDetails (psEditAttach);

        strncpy (psEditAttach->szFileName, psAttach->szFileName,
          MIME_FILENAME_MAX);
        strncpy (psEditAttach->szLeafName, psAttach->szFileName,
          MIME_LEAFNAME_MAX);
        psEditAttach->nFileType = psAttach->nFileType;
        psEditAttach->nFileSize = psAttach->nSizePost;
        psEditAttach->boUseAttributes = psAttach->boUseAttributes;
        psEditAttach->uLoad = psAttach->uLoad;
        psEditAttach->uExec = psAttach->uExec;
        psEditAttach->uAccess = psAttach->uAccess;

        // Decode the attachment
        nSuccess = 1;
        nSizePre = psAttach->nSizePre;
        nStartPos = psAttach->nStartPos;
        nSizePost = 0;
        switch (psAttach->eEncoding)
        {
          case CTENCODING_QUOTEDPRINTABLE:
            nSizePost = nSizePre;
            nSuccess = flex_alloc
              ((flex_ptr)(& psEditAttach->pcFileStart), nSizePost);
            if (nSuccess == 1)
            {
              DecodeQuotedPrintable (
                gasDetails[nEmailNum].szPreMIMEEmail + nStartPos,
                nSizePre, psEditAttach->pcFileStart, & nSizePost);
            }
            break;
          case CTENCODING_BASE64:
            nSizePost = ((nSizePre * 3) / 4) + 3;
            nSuccess = flex_alloc
              ((flex_ptr)(& psEditAttach->pcFileStart), nSizePost);
            if (nSuccess == 1)
            {
              DecodeBase64 (
              gasDetails[nEmailNum].szPreMIMEEmail + nStartPos,
              nSizePre, psEditAttach->pcFileStart, & nSizePost);
            }
            break;
          case CTENCODING_PLAIN:
          default:
            nSizePost = nSizePre;
            nSuccess = flex_alloc
              ((flex_ptr)(& psEditAttach->pcFileStart), nSizePost);
            if (nSuccess == 1)
            {
              memcpy (psEditAttach->pcFileStart,
                gasDetails[nEmailNum].szPreMIMEEmail + nStartPos,
                nSizePost);
            }
            break;
        }
        psEditAttach->nFileSize = nSizePost;

        if (nSuccess == 0)
        {
          psEditAttach->pcFileStart = NULL;
          psEditAttach->nFileSize = 0;
        }
        else
        {
          nAttachTo++;
        }
      }
      gasEdit[nEditNum].nMIMEListNum = nAttachTo;

      EditAttachmentsIconUpdate (nEditNum);

      if (nAttachTo < nAttachNum)
      {
        ShowWarningTag ("Er45");
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Create a reply message
void CreateReplyMessage (int nEmailNum)
{
  int                         nEditNum;
  int                         nStartLine;
  int                         nEndLine;
  int                         nSize;
  char                        szLine[1024];
  char                        szDate[512];
  int                         nInsertLine;
  int                         nInsertPos;
  int                         nLine;
  bool                        boSigFound;
  char                        szTo[TO_MAX];
  int                         nInserted;
  char                        cLastChar;

  nEditNum = CreateEditWindow ();

  if (nEditNum >= 0)
  {
    nInsertLine = 0;
    nInsertPos = 0;

    // Insert header information
    xterritory_convert_date_and_time (territory_CURRENT,
      (os_date_and_time const *)gasDetails[nEmailNum].pcDate,
      szDate, sizeof (szDate),
      REPLY_DATE_FORMAT, NULL);

    nSize = sprintf (szLine, Tag ("Reply"), szDate);
    strcat (szLine, "\n\n");
    nSize += 2;
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);
    nInsertLine++;
    nInsertPos += nSize;

    // Insert footer information
    nSize = sprintf (szLine, "\n\n");
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);

    // Copy the email contents
    nLine = gasDetails[nEmailNum].nHeaderEndLine;
    boSigFound = FALSE;
    while ((nLine <= (gasDetails[nEmailNum].nLineMax - 1)) && (!boSigFound))
    {
      nSize = gasDetails[nEmailNum].anRawLine[nLine + 1]
        - gasDetails[nEmailNum].anRawLine[nLine];

      if ((nSize == 4) && (strncmp ("-- \n", gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nLine], 4) == 0))
      {
        boSigFound = TRUE;
      }
      else
      {
        nInserted = 0;
        while (nSize > 0)
        {
          InsertText (nEditNum, nInsertPos, nInsertLine, "> ", 2);
          nInsertPos += 2;
          if (nSize > REPLY_INSERT_LEN)
          {
            strncpy (szLine, gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine] + nInserted,
              REPLY_INSERT_LEN);
            InsertText (nEditNum, nInsertPos, nInsertLine, szLine,
              REPLY_INSERT_LEN);
            cLastChar = (gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine])
              [nInserted + REPLY_INSERT_LEN - 1];
            nInsertPos += REPLY_INSERT_LEN;
            nInserted += REPLY_INSERT_LEN;
            nSize -= REPLY_INSERT_LEN;
          }
          else
          {
            strncpy (szLine, gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine] + nInserted,
              nSize);
            InsertText (nEditNum, nInsertPos, nInsertLine, szLine,
              nSize);
            cLastChar = (gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine])
              [nInserted + nSize - 1];
            nInsertPos += nSize;
            nInserted += nSize;
            nSize = 0;
          }
          if ((cLastChar != 0x0a) && (cLastChar != 0x0d))
          {
            InsertText (nEditNum, nInsertPos, nInsertLine, "\n", 1);
            nInsertPos++;
          }
          nInsertLine++;
        }
      }
      nLine++;
    }

    ReFormat (nEditNum, 0, -1, & nStartLine, & nEndLine);
    UpdateEditWindow (nEditNum, nStartLine,
      nEndLine);

    // Fill out header fields
    strcpy (szTo, "");
    AppendExtractedAddresses
      (gasDetails[nEmailNum].szSender, szTo, sizeof (szTo), FALSE);

    SetIconText (szTo, gasEdit[nEditNum].whHead, (wimp_i)0);

    if (strncmp (gasDetails[nEmailNum].szSubject, "Re:", 3) == 0)
    {
      strncpy (szLine, gasDetails[nEmailNum].szSubject, sizeof (szLine));
    }
    else
    {
      strcpy (szLine, "Re: ");
      strncat (szLine, gasDetails[nEmailNum].szSubject,
        (sizeof (szLine) - 4));
    }
    SetIconText (szLine, gasEdit[nEditNum].whHead, (wimp_i)1);
  }
}

//////////////////////////////////////////////////////////////////
// Create a reply to all message
void CreateReplyToAllMessage (int nEmailNum)
{
  int                         nEditNum;
  int                         nStartLine;
  int                         nEndLine;
  int                         nSize;
  char                        szLine[1024];
  char                        szDate[512];
  int                         nInsertLine;
  int                         nInsertPos;
  int                         nLine;
  bool                        boSigFound;
  char                        szTo[TO_MAX];
  char                        szCC[CC_MAX];
  int                         nToLine;
  bool                        boFound;
  int                         nInserted;
  char                        cLastChar;

  nEditNum = CreateEditWindow ();

  if (nEditNum >= 0)
  {
    nInsertLine = 0;
    nInsertPos = 0;

    // Insert header information
    xterritory_convert_date_and_time (territory_CURRENT,
      (os_date_and_time const *)gasDetails[nEmailNum].pcDate,
      szDate, sizeof (szDate),
      REPLY_DATE_FORMAT, NULL);

    nSize = sprintf (szLine, Tag ("ReplyToAll"), szDate,
      gasDetails[nEmailNum].szSenderDisplay);

    strcat (szLine, "\n\n");
    nSize += 2;
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);
    nInsertLine++;
    nInsertPos += nSize;

    // Insert footer information
    nSize = sprintf (szLine, "\n\n");
    InsertText (nEditNum, nInsertPos, nInsertLine, szLine, nSize);

    // Copy the email contents
    nLine = gasDetails[nEmailNum].nHeaderEndLine;
    boSigFound = FALSE;
    while ((nLine <= (gasDetails[nEmailNum].nLineMax - 1)) && (!boSigFound))
    {
      nSize = gasDetails[nEmailNum].anRawLine[nLine + 1]
        - gasDetails[nEmailNum].anRawLine[nLine];

      if ((nSize == 4) && (strncmp ("-- \n", gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nLine], 4) == 0))
      {
        boSigFound = TRUE;
      }
      else
      {
        nInserted = 0;
        while (nSize > 0)
        {
          InsertText (nEditNum, nInsertPos, nInsertLine, "> ", 2);
          nInsertPos += 2;
          if (nSize > REPLY_INSERT_LEN)
          {
            strncpy (szLine, gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine] + nInserted,
              REPLY_INSERT_LEN);
            InsertText (nEditNum, nInsertPos, nInsertLine, szLine,
              REPLY_INSERT_LEN);
            cLastChar = (gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine])
              [nInserted + REPLY_INSERT_LEN - 1];
            nInsertPos += REPLY_INSERT_LEN;
            nInserted += REPLY_INSERT_LEN;
            nSize -= REPLY_INSERT_LEN;
          }
          else
          {
            strncpy (szLine, gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine] + nInserted,
              nSize);
            InsertText (nEditNum, nInsertPos, nInsertLine, szLine,
              nSize);
            cLastChar = (gasDetails[nEmailNum].szRawEmail
              + gasDetails[nEmailNum].anRawLine[nLine])
              [nInserted + nSize - 1];
            nInsertPos += nSize;
            nInserted += nSize;
            nSize = 0;
          }
          if ((cLastChar != 0x0a) && (cLastChar != 0x0d))
          {
            InsertText (nEditNum, nInsertPos, nInsertLine, "\n", 1);
            nInsertPos++;
          }
          nInsertLine++;
        }
      }
      nLine++;
    }

    ReFormat (nEditNum, 0, -1, & nStartLine, & nEndLine);
    UpdateEditWindow (nEditNum, nStartLine,
      nEndLine);

    // Fill out header fields
    strcpy (szTo, "");
    AppendExtractedAddresses
      (gasDetails[nEmailNum].szSender, szTo, sizeof (szTo), FALSE);

    nToLine = -1;
    boFound = FALSE;
    while ((nToLine < gasDetails[nEmailNum].nHeaderEndLine) && (!boFound))
    {
      nToLine++;
      if ((strncmp ((gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nToLine]), "To:", 3) == 0)
        || (strncmp ((gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nToLine]), "TO:", 3) == 0))
      {
        boFound = TRUE;
      }
    }

    if (boFound)
    {
      while (boFound)
      {
        nSize = gasDetails[nEmailNum].anRawLine[nToLine + 1]
          - gasDetails[nEmailNum].anRawLine[nToLine];

        if (nSize > (int)sizeof (szLine))
        {
          nSize = (sizeof (szLine) - 1);
        }

        strncpy (szLine, gasDetails[nEmailNum].szRawEmail
          + gasDetails[nEmailNum].anRawLine[nToLine], nSize);
        szLine[nSize] = 0;


        if ((strncmp (szLine, "To:", 3) == 0)
          || (strncmp (szLine, "TO:", 3) == 0))
        {
          AppendExtractedAddresses (szLine + 3, szTo, sizeof (szTo), FALSE);
        }
        else
        {
          AppendExtractedAddresses (szLine, szTo, sizeof (szTo), FALSE);
        }
        nToLine++;
        if (gasDetails[nEmailNum].szRawEmail[
          gasDetails[nEmailNum].anRawLine[nToLine]] != ' ')
        {
          boFound = FALSE;
        }
      }
    }
    SetIconText (szTo, gasEdit[nEditNum].whHead, (wimp_i)0);

    strcpy (szCC, "");
    nToLine = -1;
    boFound = FALSE;
    while ((nToLine < gasDetails[nEmailNum].nHeaderEndLine) && (!boFound))
    {
      nToLine++;
      if ((strncmp ((gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nToLine]), "Cc:", 3) == 0)
        || (strncmp ((gasDetails[nEmailNum].szRawEmail
        + gasDetails[nEmailNum].anRawLine[nToLine]), "CC:", 3) == 0))
      {
        boFound = TRUE;
      }
    }

    if (boFound)
    {
      while (boFound)
      {
        nSize = gasDetails[nEmailNum].anRawLine[nToLine + 1]
          - gasDetails[nEmailNum].anRawLine[nToLine];

        if (nSize > (int)sizeof (szLine))
        {
          nSize = (sizeof (szLine) - 1);
        }

        strncpy (szLine, gasDetails[nEmailNum].szRawEmail
          + gasDetails[nEmailNum].anRawLine[nToLine], nSize);
        szLine[nSize] = 0;


        if ((strncmp (szLine, "Cc:", 3) == 0)
          || (strncmp (szLine, "CC:", 3) == 0))
        {
          AppendExtractedAddresses (szLine + 3, szCC, sizeof (szCC), FALSE);
        }
        else
        {
          AppendExtractedAddresses (szLine, szCC, sizeof (szCC), FALSE);
        }
        nToLine++;
        if (gasDetails[nEmailNum].szRawEmail[
          gasDetails[nEmailNum].anRawLine[nToLine]] != ' ')
        {
          boFound = FALSE;
        }
      }
    }
    if (strlen(szCC) > 0)
    {
      SetIconText (szCC, gasEdit[nEditNum].whHead, (wimp_i)9);
      ShowAdvanced (nEditNum, TRUE);
    }

    if (strncmp (gasDetails[nEmailNum].szSubject, "Re:", 3) == 0)
    {
      strncpy (szLine, gasDetails[nEmailNum].szSubject, sizeof (szLine));
    }
    else
    {
      strcpy (szLine, "Re: ");
      strncat (szLine, gasDetails[nEmailNum].szSubject,
        (sizeof (szLine) - 4));
    }
    SetIconText (szLine, gasEdit[nEditNum].whHead, (wimp_i)1);
  }
}

//////////////////////////////////////////////////////////////////
// Extract email addresses from a string and append it to the given string
void AppendExtractedAddresses (char * szInput, char * szOutput, int nOutLen, bool boIncludeSelf)
{
  char                        *szFind;
  char                        *szPos;
  char                        *szEnd;
  int                         nCopied;
  int                         nCopy;

  nCopied = strlen (szOutput);

  szPos = szInput;
  while (szPos)
  {
    szFind = strchr (szPos, '<');
    if (szFind)
    {
      szPos = szFind + 1;
      szEnd = strchr (szPos, '>');
      if (szEnd)
      {
        nCopy = (szEnd - szPos);
        szEnd++;

        if (boIncludeSelf || (strncmp (gasAccount[gnAccount].szEmailAddress,
          szPos, nCopy) != 0)
          || ((int)strlen (gasAccount[gnAccount].szEmailAddress) != nCopy))
        {
          if ((nCopied + nCopy + 2) < nOutLen)
          {
            if (strcmp (szOutput, "") != 0)
            {
              strncat (szOutput, ", ", 2);
              nCopied += 2;
            }
            strncat (szOutput, szPos, nCopy);
            nCopied += nCopy;
          }
        }
      }
      szPos = szEnd;
    }
    else
    {
      while ((strchr (";, ", szPos[0]) != NULL) && szPos[0] >= 0x20)
      {
        szPos++;
      }
      szEnd = szPos;
      while ((strchr (";, ", szEnd[0]) == NULL) && szEnd[0] >= 0x20)
      {
        szEnd++;
      }

      if (szEnd > szPos)
      {
        nCopy = (szEnd - szPos);
        szEnd++;

        if (boIncludeSelf || (strncmp (gasAccount[gnAccount].szEmailAddress,
          szPos, nCopy) != 0)
          || ((int)strlen (gasAccount[gnAccount].szEmailAddress) != nCopy))
        {
          if ((nCopied + nCopy + 2) < nOutLen)
          {
            if (strcmp (szOutput, "") != 0)
            {
              strncat (szOutput, ", ", 2);
              nCopied += 2;
            }
            strncat (szOutput, szPos, nCopy);
            nCopied += nCopy;
          }
        }
      }
      else
      {
        szEnd = 0;
      }
      szPos = szEnd;
    }
  }
}

//////////////////////////////////////////////////////////////////
// Attach a submenu to a menu
void SetSubMenu (wimp_menu * pcMain, int nItem, wimp_menu * pcSub)
{
  pcMain->entries[nItem].sub_menu = pcSub;
}

//////////////////////////////////////////////////////////////////
// Set the greyed out status of a menu item
void SetMenuItemGreyness (bool boState, wimp_menu * pcMenu, int nItem)
{
  if (boState)
  {
    pcMenu->entries[nItem].icon_flags |= wimp_ICON_SHADED;
  }
  else
  {
    pcMenu->entries[nItem].icon_flags &= ~wimp_ICON_SHADED;
  }
}

//////////////////////////////////////////////////////////////////
// Set the ticked status of a menu item
void SetMenuItemTicked (bool boTicked, wimp_menu * pcMenu, int nItem)
{
  if (boTicked)
  {
    pcMenu->entries[nItem].menu_flags |= wimp_MENU_TICKED;
  }
  else
  {
    pcMenu->entries[nItem].menu_flags &= ~wimp_MENU_TICKED;
  }
}

//////////////////////////////////////////////////////////////////
// Select all of the emails in the email list
void SelectAllEmails (void)
{
  int                         nCount;

  for (nCount = 0; (nCount < gnDetailsNum); nCount++)
  {
    if (!gasDetails[ganSort[nCount]].boSelected)
    {
      ToggleSelectRow (nCount);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Invert the selection of all of the emails in the email list
void InvertAllEmails (void)
{
  int                         nCount;

  for (nCount = 0; (nCount < gnDetailsNum); nCount++)
  {
    ToggleSelectRow (nCount);
  }
}

//////////////////////////////////////////////////////////////////
// Set up the main list menu
void SetUpMainMenu (void)
{
  bool                        boFullSelected;

  boFullSelected = SetEmailSaveSelection ();

  if (gnSelected > 0)
  {
    SetMenuItemGreyness (FALSE, gpcMainMenu, 1);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcMainMenu, 1);
    gboTentativeSelection = TRUE;
  }

  if (gnEmailSaveNum > 0)
  {
    SetMenuItemGreyness (FALSE, gpcMainSelMenu, 2);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcMainSelMenu, 2);
  }

  if (gnEmailSaveNum == 1)
  {
    SetMenuItemGreyness (FALSE, gpcMainSendMenu, 1);
    SetMenuItemGreyness (FALSE, gpcMainSendMenu, 2);
    SetMenuItemGreyness (FALSE, gpcMainSendMenu, 3);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcMainSendMenu, 1);
    SetMenuItemGreyness (TRUE, gpcMainSendMenu, 2);
    SetMenuItemGreyness (TRUE, gpcMainSendMenu, 3);
  }
}

//////////////////////////////////////////////////////////////////
// Set up the email menu
void SetUpEmailMenu (void)
{
  if ((!gsSelect.boEdit) && (gsSelect.nEmailNum == gnEmailSelected))
  {
    SetMenuItemGreyness (FALSE, gpcEmailMenu, 2);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcEmailMenu, 2);
  }

  if (gasDetails[gnEmailSelected].szPreMIMEEmail)
  {
    SetMenuItemGreyness (FALSE, gpcEmailMenu, 1);
    GenerateAttachmentMenu (gpcAttcMenu, gnEmailSelected);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcEmailMenu, 1);
  }

  SetMenuItemTicked ((gasDetails[gnEmailSelected].nLineHide == 0),
    gpcEmailMenu, 4);
}

//////////////////////////////////////////////////////////////////
// Set up the new email menu
void SetUpNewMenu (void)
{
  bool                        boGreyEdit = TRUE;

  if (gsCaret.nEditNum == gnEmailSelected)
  {
    boGreyEdit = FALSE;
    SetMenuItemGreyness (FALSE, gpcNewEditMenu, 2);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcNewEditMenu, 2);
  }

  if ((gsSelect.boEdit) && (gsSelect.nEmailNum == gnEmailSelected))
  {
    boGreyEdit = FALSE;
    SetMenuItemGreyness (FALSE, gpcNewEditMenu, 0);
    SetMenuItemGreyness (FALSE, gpcNewEditMenu, 1);
    SetMenuItemGreyness (FALSE, gpcNewEditMenu, 3);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcNewEditMenu, 0);
    SetMenuItemGreyness (TRUE, gpcNewEditMenu, 1);
    SetMenuItemGreyness (TRUE, gpcNewEditMenu, 3);
  }

  SetMenuItemGreyness (boGreyEdit, gpcNewMenu, 2);

  if (gasEdit[gnEmailSelected].nMIMEListNum > 0)
  {
    SetMenuItemGreyness (FALSE, gpcNewMenu, 1);
    GenerateEditAttachmentMenu (gpcEditAttcMenu, gnEmailSelected);
  }
  else
  {
    SetMenuItemGreyness (TRUE, gpcNewMenu, 1);
  }

  SetMenuItemTicked (gasEdit[gnEmailSelected].boAdvanced,
    gpcNewMenu, 4);
}

//////////////////////////////////////////////////////////////////
// Attempt to open all of the selected emails
void OpenSelectedEmails (void)
{
  int                         nCount;
  bool                        boDownload;

  boDownload = FALSE;
  for (nCount = 0; nCount < gnDetailsNum; nCount++)
  {
    if (gasDetails[nCount].boSelected)
    {
      if (gasDetails[nCount].szRawEmail)
      {
        CreateEmailWindow (nCount);
      }
      else
      {
        gasDetails[nCount].boOpenOnLoad = TRUE;
        AddToRETRQueue (nCount);
        boDownload = TRUE;
      }
    }
  }

  if (boDownload)
  {
    CheckNetCom (NET_POP3_DOWNLOAD);
  }
}

//////////////////////////////////////////////////////////////////
// Scramble an area of memory in a reversible manner
void ScrambleData (int * anPlain, int * anBuffer, int nBufferLen, char * szPassword)
{
  BLOWFISH_CTX                ctx;
  int                         nLoop;

  Blowfish_Init (& ctx, (unsigned char*)szPassword, strlen (szPassword));
  for (nLoop = 0; nLoop < nBufferLen; nLoop += 2)
  {
    anBuffer[nLoop + 0] = anPlain[nLoop + 0];
    anBuffer[nLoop + 1] = anPlain[nLoop + 1];

    Blowfish_Encrypt(& ctx, (unsigned long*)& anBuffer[nLoop],
      (unsigned long*)& anBuffer[nLoop + 1]);
  }
}

//////////////////////////////////////////////////////////////////
// Unscramble an area of memory in a reversible manner
void UnscrambleData (int * anScrambled, int * anBuffer, int nBufferLen, char * szPassword)
{
  BLOWFISH_CTX                ctx;
  int                         nLoop;

  Blowfish_Init (& ctx, (unsigned char*)szPassword, strlen (szPassword));
  for (nLoop = 0; nLoop < nBufferLen; nLoop += 2)
  {
    anBuffer[nLoop + 0] = anScrambled[nLoop + 0];
    anBuffer[nLoop + 1] = anScrambled[nLoop + 1];

    Blowfish_Decrypt(& ctx, (unsigned long*)& anBuffer[nLoop],
      (unsigned long*)& anBuffer[nLoop + 1]);
  }
}

//////////////////////////////////////////////////////////////////
// Convert an array of numbers to a string
void HexToString (char * szPlainText, int * anBuffer, int nBufferLen)
{
  int                         nLoop;
  char                        *pcBuffer;
  int                         nLen;

  nLen = nBufferLen * 4;
  pcBuffer = (char*)anBuffer;

  for (nLoop = 0; nLoop < nLen; nLoop++)
  {
    szPlainText[nLoop * 2 + 0] =
      CHAR_BASE + ((pcBuffer[nLoop] & (15 << 0)) >> 0);
    szPlainText[nLoop * 2 + 1] =
      CHAR_BASE + ((pcBuffer[nLoop] & (15 << 4)) >> 4);
  }
  szPlainText[nLen * 2 + 0] = 0;
  szPlainText[nLen * 2 + 1] = 0;
}

//////////////////////////////////////////////////////////////////
// Convert a string to an array of numbers
void StringToHex (char * szPlainText, int * anBuffer, int nBufferLen)
{
  int                         nLoop;
  char                        *pcBuffer;
  int                         nLen;

  nLen = (strlen (szPlainText) / 2);
  pcBuffer = (char*)anBuffer;
  if (nLen > (nBufferLen * 4))
  {
    nLen = nBufferLen * 4;
  }

  for (nLoop = 0; nLoop < nLen; nLoop++)
  {
    pcBuffer[nLoop]
      = (((int)(szPlainText[nLoop * 2 + 0] - CHAR_BASE)) << 0)
      + (((int)(szPlainText[nLoop * 2 + 1] - CHAR_BASE)) << 4);
  }
}

//////////////////////////////////////////////////////////////////
// Open the Unlock window
void OpenUnlockWindow (void)
{
  SetIconText ("", gwhUnLk, 3);
  OpenWindowInitCentre (gwhUnLk);
  xwimp_set_caret_position (gwhUnLk, (wimp_i)3, 0, 0, -1, -1);
}

//////////////////////////////////////////////////////////////////
// Open the Choices window
void OpenChoicesWindow (void)
{
  SetChoicesDialogue ();
  OpenWindowInitPaneCentreSize (gwhChce, gwhChBa, PANE_BASE,
    CHOICES_OPEN_WIDTH, CHOICES_OPEN_HEIGHT);
  xwimp_set_caret_position (gwhChce, (wimp_i)3, 0, 0, -1, -1); }

//////////////////////////////////////////////////////////////////
// Open the Addresses window
void OpenAddressesWindow (int nAddress)
{
  SetAddressesDialogue (nAddress);
  OpenWindowInitCentre (gwhAddr);
  xwimp_set_caret_position (gwhAddr, (wimp_i)8, 0, 0, -1, -1);
}

//////////////////////////////////////////////////////////////////
// Act on the Unlock window's OK button
void UnlockOkay (void)
{
  strncpy (gszUnlockPassword, GetIconText (gwhUnLk, 3),
  sizeof (gszUnlockPassword));

  // Load account details
  gboAccountsLoaded = LoadAccountDetails ();
  LoadAddressesDetails ();
}

//////////////////////////////////////////////////////////////////
// Act on the Choices window's OK button
void ChoicesOkay (void)
{
  SetChoicesDetails ();
}

//////////////////////////////////////////////////////////////////
// Set choices details from dialogue entries
void SetChoicesDetails (void)
{
  char                        *szPrevious;
  char                        *szNew1;
  char                        *szNew2;
  char                        *szDateFormat;
  bool                        boRedraw = FALSE;
  bool                        boEmoticons;
  bool                        boRedrawEmailEdit = FALSE;
#if defined MAX_SEND_LEN
  char                        *szDebug;
#endif

  szNew1 = GetIconText (gwhChce, 5);
  szNew2 = GetIconText (gwhChce, 7);

  if (strcmp (szNew1, szNew2) != 0)
  {
    // New passwords do not match
    ShowWarningTag ("Er22");
  }
  else
  {
    szPrevious = GetIconText (gwhChce, 3);
    if (strcmp (gszUnlockPassword, szPrevious) == 0)
    {
      // Change the password
      strncpy (gszUnlockPassword, GetIconText (gwhChce, 5),
        sizeof (gszUnlockPassword));
    }
    else
    {
      if ((strcmp (szNew1, "") != 0) || (strcmp (szNew2, "") != 0)
        || (strcmp (szPrevious, "") != 0))
      {
        // Wrong password
        ShowWarningTag ("Er23");
      }
    }
  }

  szDateFormat = GetIconText (gwhChce, 14);
  if (strcmp (gszDateFormat, szDateFormat) != 0)
  {
    boRedraw = TRUE;
  }

  if (strcmp (gszDateFormat, "") != 0)
  {
    strncpy (gszDateFormat, szDateFormat, sizeof (gszDateFormat));
  }
  else
  {
    strncpy (gszDateFormat, DATE_FORMAT, sizeof (gszDateFormat));
  }

  if (GetIconSelectionState (gwhChce, 17))
  {
    SetDeleteType (DELETETYPE_GUESS);
  }
  if (GetIconSelectionState (gwhChce, 29))
  {
    SetDeleteType (DELETETYPE_OS5);
  }
  if (GetIconSelectionState (gwhChce, 30))
  {
    SetDeleteType (DELETETYPE_OS4);
  }

  gboLog = GetIconSelectionState (gwhChce, 10);

  if (ChangeListFonts (gszLocalChoiceFont, gszRemoteChoiceFont))
  {
    boRedraw = TRUE;
  }

  boEmoticons = GetIconSelectionState (gwhChce, 31);
  if (boEmoticons != gboEmoticons)
  {
    boRedrawEmailEdit = TRUE;
    gboEmoticons = boEmoticons;
  }

#if defined MAX_SEND_LEN
  szDebug = GetIconText (gwhChce, 35);
  sscanf (szDebug, "%d", & gnMaxSendLen);
  szDebug = GetIconText (gwhChce, 37);
  sscanf (szDebug, "%d", & gnNullPollNetwork);
  gboFastSending = GetIconSelectionState (gwhChce, 38);
#endif

  if (boRedraw)
  {
    UpdateMain (-1, -1);
  }

  if (boRedrawEmailEdit)
  {
    RedrawAllEmailEditWindows ();
  }

  gnDefaultAccount = gnDefaultAccountDisplay;
}

//////////////////////////////////////////////////////////////////
// Redraw all of the email and edit windows
void RedrawAllEmailEditWindows (void)
{
  int                         nEmailSearch;
  wimp_window_state           sWindowState;
  int                         nEmailNum;

  // Redraw all of the Email and Edit windows
  nEmailSearch = 0;
  while (gawhEmailsOpen[nEmailSearch] != wimp_BACKGROUND)
  {
    nEmailNum = ganEmailsOpen[nEmailSearch];
    if (gasDetails[nEmailNum].szFormEmail)
    {
      flex_free((flex_ptr)(& gasDetails[nEmailNum].szFormEmail));
    }
    if (gasDetails[nEmailNum].anLine)
    {
      flex_free((flex_ptr)(& gasDetails[nEmailNum].anLine));
    }
    if (gasDetails[nEmailNum].anRawLine)
    {
      flex_free((flex_ptr)(& gasDetails[nEmailNum].anRawLine));
    }

    CreateFormattedEmail (ganEmailsOpen[nEmailSearch]);

    sWindowState.w = gawhEmailsOpen[nEmailSearch];
    xwimp_get_window_state (& sWindowState);
    err (xwimp_force_redraw (gawhEmailsOpen[nEmailSearch],
      0, sWindowState.visible.y0 - sWindowState.visible.y1,
      sWindowState.visible.x1 - sWindowState.visible.x0, 0));
    nEmailSearch++;
  }
  nEmailSearch = 0;
  while (gawhEditOpen[nEmailSearch] != wimp_BACKGROUND)
  {
    sWindowState.w = gawhEditOpen[nEmailSearch];
    xwimp_get_window_state (& sWindowState);
    err (xwimp_force_redraw (gawhEditOpen[nEmailSearch],
      0, sWindowState.visible.y0 - sWindowState.visible.y1,
      sWindowState.visible.x1 - sWindowState.visible.x0, 0));
    nEmailSearch++;
  }
}

//////////////////////////////////////////////////////////////////
// Set choices dialogue from choices entries
void SetChoicesDialogue (void)
{
#if defined MAX_SEND_LEN
  char                        szDebug[16];
#endif

  SetIconText ("", gwhChce, 3);
  SetIconText ("", gwhChce, 5);
  SetIconText ("", gwhChce, 7);
  SetIconSelectionState (gboLog, gwhChce, 10);
  SetIconText (gszDateFormat, gwhChce, 14);
  ShowChoicesAccount (gnDefaultAccount);
  strncpy (gszLocalChoiceFont, gszFont, sizeof (gszLocalChoiceFont));
  SetIconText (gszLocalChoiceFont, gwhChce, 19);
  strncpy (gszRemoteChoiceFont, gszFontB, sizeof (gszRemoteChoiceFont));
  SetIconText (gszRemoteChoiceFont, gwhChce, 22);
  SetIconSelectionState (
    (geDeleteTypeConfig == DELETETYPE_GUESS), gwhChce, 17);
  SetIconSelectionState (
    (geDeleteTypeConfig == DELETETYPE_OS5), gwhChce, 29);
  SetIconSelectionState (
    (geDeleteTypeConfig == DELETETYPE_OS4), gwhChce, 30);
  SetIconSelectionState (gboEmoticons, gwhChce, 31);

#if defined MAX_SEND_LEN
  sprintf (szDebug, "%d", gnMaxSendLen);
  SetIconText (szDebug, gwhChce, 35);
  sprintf (szDebug, "%d", gnNullPollNetwork);
  SetIconText (szDebug, gwhChce, 37);
  SetIconSelectionState (gboFastSending, gwhChce, 38);
#endif

}

//////////////////////////////////////////////////////////////////
// Delete the account
void DeleteAccount (int nAccount)
{
  int                         nCount;

  // Check if a transfer is in progress
  if (TransferInProgress ())
  {
    ShowWarningTag ("Er18");
  }
  else
  {
    if (nAccount != ACCOUNT_INVALID)
    {
      // Clear the account info
      CloseWindowHandlePane (gwhMain, gwhMaHe);
      CloseWindowHandlePane (gwhSett, gwhSeBa);
      DeleteMultipleEmails (0, gnDetailsNum);

      // Shift the accounts higher up the list
      for (nCount = nAccount; nCount < (gnAccountNum - 1); nCount++)
      {
        gasAccount[nCount] = gasAccount[nCount + 1];
      }
      ClearAccountDetails (gnAccountNum);

      // Shift the default account
      if (gnDefaultAccount > nAccount)
      {
        gnDefaultAccount--;
      }
      else
      {
        if (gnDefaultAccount == nAccount)
        {
          gnDefaultAccount = ACCOUNT_INVALID;
        }
      }
      gnAccountNum--;
      gnAccount = ACCOUNT_INVALID;
      gnAccountDialogue = ACCOUNT_INVALID;
      gnAccountSettingsDialogue = ACCOUNT_INVALID;
    }
  }
}

//////////////////////////////////////////////////////////////////
// The effect of clicking on the Continue button of a query box
void QueryContinue (void)
{
  bool                        boWinFound;
  int                         nEditSearch;

  CloseQuery ();

  switch (geQueryAction)
  {
    case QUERYACTION_STOP:
      Cancel ();
      break;
    case QUERYACTION_DELETEACCOUNT:
      DeleteAccount (gnAccountDialogue);
      break;
    case QUERYACTION_DELETEEMAILS:
      CompileDeleteList ();
      CheckNetCom (NET_POP3_DELETE);
      break;
    case QUERYACTION_DELETEADDRESS:
      AddressesDialogueDelete ();
      break;
    case QUERYACTION_QUIT:
      Quit ();
      break;
    case QUERYACTION_CLOSEEDIT:
      boWinFound = FALSE;
      nEditSearch = 0;
      while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
      {
        if (gwhWindowClose == gawhEditOpen[nEditSearch])
        {
          err (xwimp_close_window (gwhWindowClose));
          err (xwimp_close_window
            (gasEdit[ganEditOpen[nEditSearch]].whHead));
          DestroyEditWindow (ganEditOpen[nEditSearch]);
          boWinFound = TRUE;
        }
        nEditSearch++;
      }
      gwhWindowClose = wimp_BACKGROUND;
      break;
    case QUERYACTION_NONE:
    default:
      break;
  }
}

//////////////////////////////////////////////////////////////////
// The effect of clicking on the Cancel button of a query box
void QueryCancel (void)
{
  CloseQuery ();

  switch (geQueryAction)
  {
    case QUERYACTION_STOP:
    case QUERYACTION_DELETEACCOUNT:
    case QUERYACTION_DELETEEMAILS:
    case QUERYACTION_QUIT:
    case QUERYACTION_NONE:
    case QUERYACTION_CLOSEEDIT:
    default:
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Test whether or not a transfer is currently in progress
bool TransferInProgress (void)
{
  bool                        boTransferInProgress;;

  if ((geNetCom != NET_INVALID)
    || (geState != STATE_DISCONNECTED)
    || (gnRETRActNum > 0)
    || (gnMAILActNum > 0)
    || (gnDELEActNum > 0))
  {
    boTransferInProgress = TRUE;
  }
  else
  {
    boTransferInProgress = FALSE;
  }

  return boTransferInProgress;
}

//////////////////////////////////////////////////////////////////
// Lock everything (clear the account details)
void Lock (void)
{
  int                         nCount;

  // Check if a transfer is in progress
  if (TransferInProgress ())
  {
    ShowWarningTag ("Er24");
  }
  else
  {
    CloseWindowHandle (gwhLogn);
    CloseWindowHandle (gwhAddr);
    CloseWindowHandlePane (gwhMain, gwhMaHe);
    CloseWindowHandlePane (gwhAcct, gwhAcBa);
    CloseWindowHandlePane (gwhChce, gwhChBa);
    CloseWindowHandlePane (gwhSett, gwhSeBa);

    if (gnAccount != ACCOUNT_INVALID)
    {
      // Clear the account info
      DeleteMultipleEmails (0, gnDetailsNum);
    }

    for (nCount = 0; nCount < gnAccountNum; nCount++)
    {
      ClearAccountDetails (nCount);
    }
    gnAccountNum = 0;
    gnAccount = ACCOUNT_INVALID;
    gnAccountDialogue = ACCOUNT_INVALID;
    gnAccountSettingsDialogue = ACCOUNT_INVALID;
    gnAddress = ADDRESS_INVALID;
    gnAddressNum = 0;

    gboAccountsLoaded = FALSE;
  }
}

//////////////////////////////////////////////////////////////////
// Extend the memory allocated for formatting information
int ExtendLineMem (int nEditNum)
{
  int                   nAllocSuccess;
  int                   nNewSize;

  nNewSize = gasEdit[nEditNum].nLineMem + (EDIT_LINE_BLOCK * sizeof(int));
  nAllocSuccess = flex_extend ((flex_ptr)& gasEdit[nEditNum].anLine,
    nNewSize);
  if (nAllocSuccess == 1)
  {
    gasEdit[nEditNum].nLineMem = nNewSize;
  }
  else
  {
    ShowWarningTag ("Er25");
  }

  return nAllocSuccess;
}

//////////////////////////////////////////////////////////////////
// Extend the memory allocated for the email text
int ExtendEmailMem (int nEditNum)
{
  int                   nAllocSuccess;
  int                   nNewSize;

  nNewSize = gasEdit[nEditNum].nEmailMem + (EDIT_CHARS_BLOCK * sizeof(char));
  nAllocSuccess = flex_extend ((flex_ptr)& gasEdit[nEditNum].szRawEmail,
    nNewSize);
  if (nAllocSuccess == 1)
  {
    gasEdit[nEditNum].nEmailMem = nNewSize;
  }
  else
  {
    ShowWarningTag ("Er25");
  }

  return nAllocSuccess;
}

//////////////////////////////////////////////////////////////////
// Extend the memory allocated for formatting information
int ExtendLineMemTo (int nEditNum, int nSize)
{
  int                   nAllocSuccess = 1;
  int                   nNewSize;

  if (nSize > gasEdit[nEditNum].nLineMem)
  {
    nNewSize = ((EDIT_LINE_BLOCK * sizeof(int))
      * (nSize / (EDIT_LINE_BLOCK * sizeof(int))))
      + (EDIT_LINE_BLOCK * sizeof(int));
    nAllocSuccess = flex_extend ((flex_ptr)& gasEdit[nEditNum].anLine,
      nNewSize);
    if (nAllocSuccess == 1)
    {
      gasEdit[nEditNum].nLineMem = nNewSize;
    }
    else
    {
      ShowWarningTag ("Er25");
    }
  }

  return nAllocSuccess;
}

//////////////////////////////////////////////////////////////////
// Extend the memory allocated for the email text
int ExtendEmailMemTo (int nEditNum, int nSize)
{
  int                   nAllocSuccess = 1;
  int                   nNewSize;

  if (nSize >= gasEdit[nEditNum].nEmailMem)
  {
    nNewSize = ((EDIT_CHARS_BLOCK * sizeof(char))
      * (nSize / (EDIT_CHARS_BLOCK * sizeof(char))))
      + (EDIT_CHARS_BLOCK * sizeof(char));
    nAllocSuccess = flex_extend ((flex_ptr)& gasEdit[nEditNum].szRawEmail,
      nNewSize);
    if (nAllocSuccess == 1)
    {
      gasEdit[nEditNum].nEmailMem = nNewSize;
    }
    else
    {
      ShowWarningTag ("Er25");
    }
  }

  return nAllocSuccess;
}

//////////////////////////////////////////////////////////////////
// Change the local and remote font
bool ChangeListFonts (char * szFont, char * szFontB)
{
  int                         nFontMinX;
  int                         nFontMinY;
  int                         nFontMaxX;
  int                         nFontMaxY;
  int                         nXRes;
  int                         nYRes;
  bool                        boReturn = FALSE;

  if ((strncmp (gszFont, szFont, sizeof (gszFont)) != 0)
    || (strncmp (gszFontB, szFontB, sizeof (gszFontB)) != 0))
  {
    xfont_lose_font (ghFont);
    xfont_lose_font (ghFontB);
    if (strncmp (szFont, "", sizeof (gszFont)) != 0)
    {
      strncpy (gszFont, szFont, sizeof (gszFont));
    }
    else
    {
      strncpy (gszFont, "Trinity.Medium", sizeof (gszFont));
    }

    if (strncmp (szFontB, "", sizeof (gszFontB)) != 0)
    {
      strncpy (gszFontB, szFontB, sizeof (gszFontB));
    }
    else
    {
      strncpy (gszFontB, "Trinity.Bold", sizeof (gszFontB));
    }

    // Find Font
    xfont_find_font (gszFont, 12 * 16, 12 * 16, 0, 0, & ghFont, & nXRes,
      & nYRes);
    xfont_find_font (gszFontB, 12 * 16, 12 * 16, 0, 0, & ghFontB, & nXRes,
      & nYRes);

    xfont_read_info (ghFont, & nFontMinX, & nFontMinY, & nFontMaxX,
      & nFontMaxY);
    gnRowHeight = nFontMaxY - nFontMinY;
    gnTextYOffset = - nFontMinY;

    xfont_read_info (ghFontB, & nFontMinX, & nFontMinY, & nFontMaxX,
      & nFontMaxY);
    if ((nFontMaxY - nFontMinY) > gnRowHeight)
    {
      gnRowHeight = nFontMaxY - nFontMinY;
      gnTextYOffset = - nFontMinY;
    }

    xfont_scan_string (ghFont, "", (font_GIVEN_FONT
      | font_GIVEN_LENGTH), MILLIPOINT * 64, MILLIPOINT * gnRowHeight,
      NULL, NULL, 1, NULL, & gnEllipsisWidth, NULL, NULL);
    xfont_scan_string (ghFontB, "", (font_GIVEN_FONT
      | font_GIVEN_LENGTH), MILLIPOINT * 64, MILLIPOINT * gnRowHeight,
      NULL, NULL, 1, NULL, & gnEllipsisWidthB, NULL, NULL);

    boReturn = TRUE;
  }

  return boReturn;
}

//////////////////////////////////////////////////////////////////
// Find all of the additional fonts
void FindAdditionalFonts (void)
{
  int                         nFontMinX;
  int                         nFontMinY;
  int                         nFontMaxX;
  int                         nFontMaxY;
//  char                        szFont[] = "Trinity.Medium";
//  char                        szFontB[] = "Trinity.Bold";
  char                        szEmailFont[] = "Corpus.Medium";
  char                        szEmailBFont[] = "Corpus.Bold";
  char                        szEmailIFont[] = "Corpus.Medium.Oblique";
  char                        szEmailBIFont[] = "Corpus.Bold.Oblique";
  int                         nXRes;
  int                         nYRes;

  // Find Font
  xfont_find_font (gszFont, 12 * 16, 12 * 16, 0, 0, & ghFont, & nXRes,
    & nYRes);
  xfont_find_font (gszFontB, 12 * 16, 12 * 16, 0, 0, & ghFontB, & nXRes,
    & nYRes);

  xfont_read_info (ghFont, & nFontMinX, & nFontMinY, & nFontMaxX,
    & nFontMaxY);
  gnRowHeight = nFontMaxY - nFontMinY;
  gnTextYOffset = - nFontMinY;

  xfont_read_info (ghFontB, & nFontMinX, & nFontMinY, & nFontMaxX,
    & nFontMaxY);
  if ((nFontMaxY - nFontMinY) > gnRowHeight)
  {
    gnRowHeight = nFontMaxY - nFontMinY;
    gnTextYOffset = - nFontMinY;
  }

  xfont_scan_string (ghFont, "", (font_GIVEN_FONT
    | font_GIVEN_LENGTH), MILLIPOINT * 64, MILLIPOINT * gnRowHeight,
    NULL, NULL, 1, NULL, & gnEllipsisWidth, NULL, NULL);
  xfont_scan_string (ghFontB, "", (font_GIVEN_FONT
    | font_GIVEN_LENGTH), MILLIPOINT * 64, MILLIPOINT * gnRowHeight,
    NULL, NULL, 1, NULL, & gnEllipsisWidthB, NULL, NULL);

  // Find email font
  xfont_find_font (szEmailFont, 12 * 16, 12 * 16, 0, 0, & ghEmailFont,
    & nXRes, & nYRes);
  xfont_find_font (szEmailBFont, 12 * 16, 12 * 16, 0, 0,
    & ghEmailBFont, & nXRes, & nYRes);
  xfont_find_font (szEmailIFont, 12 * 16, 12 * 16, 0, 0,
    & ghEmailIFont, & nXRes, & nYRes);
  xfont_find_font (szEmailBIFont, 12 * 16, 12 * 16, 0, 0,
    & ghEmailBIFont, & nXRes, & nYRes);
  xfont_read_info (ghEmailFont, & nFontMinX, & nFontMinY, & nFontMaxX,
    & nFontMaxY);
  gnEmailRowHeight = nFontMaxY - nFontMinY;
  gnEmailTextYOffset = - nFontMinY;

  xfont_scan_string (ghEmailFont, "A", (font_GIVEN_FONT
    | font_GIVEN_LENGTH), MILLIPOINT * 64, MILLIPOINT * gnEmailRowHeight,
    NULL, NULL, 1, NULL, & gnEmailTextWidth, NULL, NULL);
  gnEmailCharWidth = gnEmailTextWidth / MILLIPOINT;
  gnEmailTextWidth = (EMAIL_CHAR_WIDTH * gnEmailTextWidth) / MILLIPOINT;
}

//////////////////////////////////////////////////////////////////
// Release all of the additional fonts
void ReleaseAdditionalFonts (void)
{
  xfont_lose_font (ghFont);
  xfont_lose_font (ghFontB);
  xfont_lose_font (ghEmailFont);
  xfont_lose_font (ghEmailBFont);
  xfont_lose_font (ghEmailIFont);
  xfont_lose_font (ghEmailBIFont);
}

//////////////////////////////////////////////////////////////////
// Response to a Mode Change
void ModeChange (void)
{
  ReleaseAdditionalFonts ();
  FindAdditionalFonts ();

  GenerateTransTable ();
}

//////////////////////////////////////////////////////////////////
// Generate sprite palette translation table
void GenerateTransTable (void)
{
  int                         nSize;

  if (gpsTransTable)
  {
    free (gpsTransTable);
    gpsTransTable = NULL;
  }

  if (gpcEmoticons->sprite_count > 0)
  {
    err (xcolourtrans_generate_table_for_sprite (gpcEmoticons,
      (osspriteop_id)((char*)gpcEmoticons + gpcEmoticons->first),
      colourtrans_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
      NULL, colourtrans_GIVEN_SPRITE,
      NULL, NULL, & nSize));

    gpsTransTable = (osspriteop_trans_tab*)malloc (nSize);

    err (xcolourtrans_generate_table_for_sprite (gpcEmoticons,
      (osspriteop_id)((char*)gpcEmoticons + gpcEmoticons->first),
      os_CURRENT_MODE, colourtrans_CURRENT_PALETTE,
      gpsTransTable, colourtrans_GIVEN_SPRITE,
      NULL, NULL, NULL));
  }
}

//////////////////////////////////////////////////////////////////
// Open the registation window
void OpenRegisterWindow (void)
{
  SetIconText ("", gwhRegi, 0);
  SetIconText ("", gwhRegi, 2);
  OpenWindowInitCentre (gwhRegi);
  xwimp_set_caret_position (gwhRegi, (wimp_i)0, 0, 0, -1, -1);
}

//////////////////////////////////////////////////////////////////
// Act on Cancel being selected on the registration window
void RegisterCancel (void)
{
  SetIconText ("", gwhRegi, 0);
  SetIconText ("", gwhRegi, 2);
  xwimp_set_caret_position (gwhRegi, (wimp_i)0, 0, 0, -1, -1);
}


//////////////////////////////////////////////////////////////////
// Register TapirMail
void Register (void)
{
  char                        *szName;
  char                        *szKey;
  unsigned int                uKey;
  unsigned int                uSerial;
  char                        szTemp[256];
  FILE                        *fhLicense;
  int                         nReturn;
  fileswitch_object_type      eType;
  bool                        boSuccess;
  os_t                        nMonotonicTime;

  if (gnRegistered != REGISTERED)
  {
    szName = GetIconText (gwhRegi, 0);
    szKey = GetIconText (gwhRegi, 2);
    sscanf (szKey, "%u", & uKey);
    xos_read_monotonic_time (& nMonotonicTime);
    uKey = nMonotonicTime;

    uSerial = CheckRegister (szName, uKey);

    if (uSerial != SERIAL_INVALID)
    {
      gnRegistered = REGISTERED;
    }
    else
    {
      ShowWarningTag ("Er28");
    }

    if (gnRegistered == REGISTERED)
    {
      strncpy (gszName, szName, sizeof (gszName));
      guSerial = uSerial;

      SetRegistrationInfo ();

      if (gwhRegi)
      {
        xwimp_delete_window (gwhRegi);
        gwhRegi = NULL;
      }
      xwimp_create_menu ((wimp_menu*)-1, 0, 0);
      gpcIconBarMenu->entries[6] = gpcIconBarMenu->entries[7];

      // Check that the directory exists
      xosfile_read_no_path (LICENSE_SAVE_DIR, & eType, NULL, NULL, NULL,
        NULL);
      if (eType == fileswitch_NOT_FOUND)
      {
        // Create a directory
        xosfile_create_dir (LICENSE_SAVE_DIR, 0);
      }

      // Save to disc
      boSuccess = FALSE;
      fhLicense = fopen (LICENSE_SAVE, "w");
      if (fhLicense)
      {
        boSuccess = TRUE;

        nReturn = fputs (szName, fhLicense);
        if (nReturn == EOF)
        {
          boSuccess = FALSE;
        }

        nReturn = fputc ('\n', fhLicense);
        if (nReturn == EOF)
        {
          boSuccess = FALSE;
        }

        sprintf (szTemp, "%u", uKey);
        nReturn = fputs (szTemp, fhLicense);
        if (nReturn == EOF)
        {
          boSuccess = FALSE;
        }

        nReturn = fputc ('\n', fhLicense);
        if (nReturn == EOF)
        {
          boSuccess = FALSE;
        }

        nReturn = fclose (fhLicense);
        if (nReturn == EOF)
        {
          boSuccess = FALSE;
        }
      }

      if (boSuccess)
      {
        ShowWarningTag ("Thanks");
      }
      else
      {
        ShowWarningTag ("Er27");
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Check if a registration should be successful
unsigned int CheckRegister (char * szName, unsigned int uKey)
{
  unsigned int                uChecksum;
  unsigned int                uSerial;
  int                         nPos;
  bool                        boSuccess;

  boSuccess = FALSE;

  uSerial = (uKey >> 16) & 0xffff;

  uChecksum = CHECKSUM_INIT;
  nPos = 0;
  while (szName[nPos] >= 0x20)
  {
    uChecksum ^= (unsigned int)((int)(szName[nPos])) * (nPos + 1);
    nPos++;
  }
  uChecksum += nPos;
  uChecksum &= 0xffff;
  uChecksum ^= uSerial;
  uChecksum |= (uSerial << 16);

  if (uChecksum == uKey)
  {
    boSuccess = TRUE;
  }

  // The following line ensures that the program can always be registered
  boSuccess = TRUE;

  if (!boSuccess)
  {
    uSerial = SERIAL_INVALID;
  }

  return uSerial;
}

//////////////////////////////////////////////////////////////////
// Attempt to load the license file
void LoadLicense (void)
{
  FILE                        *fhLicense;
  char                        szName[256];
  char                        szKey[256];
  char                        *szReturn;
  unsigned int                uKey;
  unsigned int                uSerial;
  int                         nReturn;
  int                         nPos;

  uSerial = SERIAL_INVALID;
  fhLicense = fopen (LICENSE_LOAD, "r");
  if (fhLicense != NULL)
  {
    do
    {
      szReturn = fgets (szName, sizeof (szName), fhLicense);
    } while ((szReturn) && szName[0] == ';');

    if (szReturn)
    {
      do
      {
        szReturn = fgets (szKey, sizeof (szKey), fhLicense);
      } while ((szReturn) && szKey[0] == ';');
    }

    if (szReturn)
    {
      nReturn = sscanf (szKey, "%u", & uKey);
      if (nReturn != EOF)
      {
        uSerial = CheckRegister (szName, uKey);

        if (uSerial != SERIAL_INVALID)
        {
          gnRegistered = REGISTERED;
        }
        else
        {
          gnRegistered = UNREGISTERED;
        }
      }
    }
    fclose (fhLicense);
  }

  if (gnRegistered == REGISTERED)
  {
    strncpy (gszName, szName, sizeof (gszName));
    gszName[sizeof (gszName) - 1] = 0;
    nPos = 0;
    while (gszName[nPos] >= 0x20)
    {
      nPos++;
    }
    gszName[nPos] = 0;
    guSerial = uSerial;
  }
}

//////////////////////////////////////////////////////////////////
// Set up the registration info
void SetRegistrationInfo (void)
{
  char                        szTemp[256];

  if (gnRegistered == REGISTERED)
  {
    // Set up the info window
    sprintf (szTemp, "%s (%s %u)", gszName, Tag("Number"), guSerial);
    SetIconText (szTemp, gawhMenuWinHandle[0], 10);
  }
  else
  {
    strcpy (gszName, "");
    guSerial = SERIAL_INVALID;
    SetIconText (Tag("Unreg"), gawhMenuWinHandle[0], 10);
  }
}

//////////////////////////////////////////////////////////////////
// Returns the version of RISC OS in use
void GetOSVersion (char * szVersion, int nLength)
{
  os_error                   *psVersion;
  char                       *szVersionStart;
  char                       *szVersionEnd = NULL;
  int                        nEnd;

  psVersion = (os_error *) xosbyte1 (osbyte_VERSION, 0, 0, NULL);
  if (psVersion)
  {
    szVersionStart = strchr (psVersion->errmess, ' ') + 1;
  }
  else
  {
    szVersionStart = NULL;
  }
  if (szVersionStart)
  {
    szVersionStart = strchr (szVersionStart, ' ') + 1;
  }
  if (szVersionStart)
  {
    szVersionEnd = strchr (szVersionStart, ' ');
  }
  nEnd = szVersionEnd - szVersionStart;
  if (nEnd >= nLength)
  {
    nEnd = nLength - 1;
  }
  if ((nEnd > 0) && (szVersionStart && szVersionEnd))
  {
    strncpy (szVersion, szVersionStart, nEnd);
    szVersion[nEnd] = 0;
  }
  else
  {
    strcpy (szVersion, "");
  }
}

//////////////////////////////////////////////////////////////////
// Open the account menu from the choices window
void OpenChoicesLoginMenu (void)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = gwhChce;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = gwhChce;
  sIconState.i = 28;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  GenerateAccountMenuNone (gpcChoiceAcctMenu);
  OpenMenu (gpcChoiceAcctMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Set the choices default account
void SetChoicesAccount (int nShowAccount)
{
  gnDefaultAccountDisplay = nShowAccount;
  ShowChoicesAccount (gnDefaultAccountDisplay);
}

//////////////////////////////////////////////////////////////////
// Open the default account
void OpenDefaultAccount (void)
{
  if ((gnDefaultAccount >= 0) && (gnDefaultAccount < gnAccountNum))
  {
    if ((gasAccount[gnDefaultAccount].boPOP3RememberPassword
      || gasAccount[gnDefaultAccount].boPOP3GotPassword)
      && ((gasAccount[gnDefaultAccount].eSMTPAuth == SMTPAUTH_NONE)
      || gasAccount[gnDefaultAccount].boSMTPUsePOP3Details
      || gasAccount[gnDefaultAccount].boSMTPRememberPassword
      || gasAccount[gnDefaultAccount].boSMTPGotPassword))
    {
      LoginAccount (gnDefaultAccount);
    }
    else
    {
      OpenLoginWindow (gnDefaultAccount);
    }
  }
}

//////////////////////////////////////////////////////////////////
// Set up the font list
void SetUpFontMenu (wimp_menu * pcMenu, char * szFont)
{
  xfont_list_fonts ((byte *)(pcMenu), font_RETURN_FONT_MENU
    | font_GIVEN_TICK, FONT_LIST_MAX, gpcFontMenuBuffer, FONT_LIST_IND_MAX,
    szFont, NULL, NULL, NULL);
}

//////////////////////////////////////////////////////////////////
// Open the local email font list
void OpenChoicesLocalFontMenu (void)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = gwhChce;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = gwhChce;
  sIconState.i = 20;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  SetUpFontMenu (gpcLocalFontMenu, gszLocalChoiceFont);

  OpenMenu (gpcLocalFontMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Select the local email font
void ChoicesLocalFontSelect (wimp_selection * psSelection)
{
  char                        szFontBuffer[FONT_NAME_LENGTH] = "";
  int                         nEnd;

  xfont_decode_menu (0, (byte *)(gpcLocalFontMenu), (byte *)(psSelection),
    szFontBuffer, sizeof (szFontBuffer), NULL, NULL);

  if (strncmp (szFontBuffer, "\\F", 2) == 0)
  {
    nEnd = 2;
    while ((nEnd < (int)sizeof (szFontBuffer)) && (szFontBuffer[nEnd] > 0x20)
      && (szFontBuffer[nEnd] != '\\'))
    {
      nEnd++;
    }
    strncpy (gszLocalChoiceFont, szFontBuffer + 2, nEnd - 2);
    gszLocalChoiceFont[nEnd - 2] = 0;
  }

  SetIconText (gszLocalChoiceFont, gwhChce, 19);
}

//////////////////////////////////////////////////////////////////
// Open the remote email font list
void OpenChoicesRemoteFontMenu (void)
{
  wimp_window_state           sWindowState;
  wimp_icon_state             sIconState;
  int                         nXPos;
  int                         nYPos;

  sWindowState.w = gwhChce;
  xwimp_get_window_state (& sWindowState);

  sIconState.w = gwhChce;
  sIconState.i = 23;
  xwimp_get_icon_state (& sIconState);

  nXPos = sWindowState.visible.x0 - sWindowState.xscroll
    + sIconState.icon.extent.x1;
  nYPos = sWindowState.visible.y1 - sWindowState.yscroll
    + sIconState.icon.extent.y1;

  SetUpFontMenu (gpcRemoteFontMenu, gszRemoteChoiceFont);

  OpenMenu (gpcRemoteFontMenu, nXPos, nYPos);
}

//////////////////////////////////////////////////////////////////
// Select the remote email font
void ChoicesRemoteFontSelect (wimp_selection * psSelection)
{
  char                        szFontBuffer[FONT_NAME_LENGTH] = "";
  int                         nEnd;

  xfont_decode_menu (0, (byte *)(gpcRemoteFontMenu), (byte *)(psSelection),
    szFontBuffer, sizeof (szFontBuffer), NULL, NULL);

  if (strncmp (szFontBuffer, "\\F", 2) == 0)
  {
    nEnd = 2;
    while ((nEnd < (int)sizeof (szFontBuffer)) && (szFontBuffer[nEnd] > 0x20)
      && (szFontBuffer[nEnd] != '\\'))
    {
      nEnd++;
    }
    strncpy (gszRemoteChoiceFont, szFontBuffer + 2, nEnd - 2);
    gszRemoteChoiceFont[nEnd - 2] = 0;
  }

  SetIconText (gszRemoteChoiceFont, gwhChce, 22);
}

//////////////////////////////////////////////////////////////////
// A URL Launch message has been received; see if we should respond
void LaunchURL (wimp_block * pcBlock)
{
  int                         nLength;

  if (gnAccountNum != 0)
  {
    nLength = pcBlock->message.size - 20;

    if (nLength > 7)
    {
      if (strncmp ((char *)pcBlock->message.data.reserved, "mailto:", 7)
        == 0)
      {
        // Open an email window with the correct address
        CreateEditWindowAddress (
          (char *)(pcBlock->message.data.reserved + 7));
        // Acknowledge the message
        pcBlock->message.your_ref = pcBlock->message.my_ref;
        xwimp_send_message (wimp_USER_MESSAGE_ACKNOWLEDGE,
          & pcBlock->message, pcBlock->message.sender);
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Add an address from the address book into an icon
void AddAddressToIcon (wimp_w whWindow, wimp_i ihIcon, int nAddress, int nMaxLen)
{
  char                        szString[TO_MAX];
  int                         nLength;
  int                         nAddressLen;

  if ((nAddress >= 0) && (nAddress < gnAddressNum)
    && (nMaxLen <= (int)sizeof (szString)))
  {
    strncpy (szString, GetIconText (whWindow, ihIcon), sizeof (szString));
    szString[sizeof (szString) - 1] = 0;
    nLength = strlen (szString);
    nAddressLen = strlen (gasAddresses[nAddress].szAddress);
    if ((nLength + nAddressLen + 3) < nMaxLen)
    {
      if (nLength > 0)
      {
        strcat (szString, ", ");
      }
      strcat (szString, gasAddresses[nAddress].szAddress);
      szString[sizeof (szString) - 1] = 0;
      SetIconText (szString, whWindow, ihIcon);

      xwimp_set_caret_position (whWindow, ihIcon, 0, 0, -1,
        (nLength + nAddressLen + 2));
    }
  }
}

//////////////////////////////////////////////////////////////////
// Add the 'From:' address into the address book
void AddFromToAddress (int nEmailNum)
{
  char                        szName[ADDRESS_NAME_MAX];
  char                        szAddress[ADDRESS_ADDRESS_MAX];

  strncpy (szName, gasDetails[nEmailNum].szSenderDisplay, ADDRESS_NAME_MAX);
  szName[sizeof (szName) - 1] = 0;

  szAddress[0] = 0;
  AppendExtractedAddresses (gasDetails[nEmailNum].szSender, szAddress,
    (int)sizeof (szAddress), TRUE);

  OpenAddressesWindow (ADDRESS_INVALID);

  SetIconText (szName, gwhAddr, 8);
  SetIconText (szAddress, gwhAddr, 10);
}

//////////////////////////////////////////////////////////////////
// Check if the email is MIME encoded
void CheckMIME (int nEmailNum)
{
  char                        szHeaderVal[1024] = "";
#if defined _DEBUG
  int                         nListLoop;
#endif

  if (gasDetails[nEmailNum].szRawEmail)
  {
    GetHeaderValue ("MIME-Version", gasDetails[nEmailNum].szRawEmail,
      gasDetails[nEmailNum].nSize, szHeaderVal, sizeof (szHeaderVal));

    if (strcmp (szHeaderVal, "1.0") == 0)
    {
      // This is a MIME email
      gasDetails[nEmailNum].nMIMEListNum =
        CreateMIMEList (& gasDetails[nEmailNum].szRawEmail,
        gasDetails[nEmailNum].nSize, & gasDetails[nEmailNum].asMIMEList);
#if defined _DEBUG
      if (gasDetails[nEmailNum].asMIMEList)
      {
        REPORT ("MIME decoded:-");
        for (nListLoop = 0; nListLoop < gasDetails[nEmailNum].nMIMEListNum;
          nListLoop++)
        {
          REPORT (gasDetails[nEmailNum].asMIMEList[nListLoop].szFileName);
          REPORTVAR ("MIME filetype: %x",
            gasDetails[nEmailNum].asMIMEList[nListLoop].nFileType);
          if (gasDetails[nEmailNum].asMIMEList[nListLoop].boText)
          {
            REPORT ("Text");
          }
          else
          {
            REPORT ("Not text");
          }
        }
      }
      else
      {
        REPORT ("No successful MIME decoding:-");
      }
#endif
    }
  }
}

//////////////////////////////////////////////////////////////////
// Warn that a submenu is about to be opened
void MenuWarning (wimp_block *pcBlock)
{
  int                         nSelection;
  int                         nDepth;
  char                        szIconName[32];
  os_error                    *psError;

  if ((gpcMenuCurrent == gpcAttcMenu) || (gpcMenuCurrent == gpcEmailMenu)
   || (gpcMenuCurrent == gpcEditAttcMenu) || (gpcMenuCurrent == gpcNewMenu))
  {
    nDepth = 0;
    while (((int*)
      ((char*)(& pcBlock->message.data.reserved) + 12))[nDepth] != -1)
    {
      nDepth++;
    }
    nDepth--;

    if (((wimp_w*)(& pcBlock->message.data.reserved))[0] == gwhAttc)
    {
      // This is the attachment menu
      if (nDepth >= 0)
      {
        nSelection
          = ((int*)((char*)(& pcBlock->message.data.reserved) + 12))[nDepth];
        if ((!gboEditSelected)
          && (nSelection < gasDetails[gnEmailSelected].nMIMEListNum))
        {
          gnAttachmentNum = nSelection;

          // Update the gwhAttc 'save as' window
          SetIconText (
            gasDetails[gnEmailSelected].asMIMEList[nSelection].szFileName,
            gwhAttc, (wimp_i)2);

          // Set up the icon
          sprintf (szIconName, "file_%03x",
            gasDetails[gnEmailSelected].asMIMEList[nSelection].nFileType);

          psError = xwimpspriteop_read_sprite_info (szIconName, NULL, NULL,
            NULL, NULL);
          if (psError)
          {
            strcpy (szIconName, "file_xxx");
          }
          SetIconText (szIconName, gwhAttc, (wimp_i)3);

          xwimp_create_sub_menu ((wimp_menu*)gwhAttc,
            ((int*)((char*)(& pcBlock->message.data.reserved) + 4))[0],
            ((int*)((char*)(& pcBlock->message.data.reserved) + 8))[0]);
        }
      }
    }
    if (((wimp_w*)(& pcBlock->message.data.reserved))[0] == gwhEdAt)
    {
      if (nDepth >= 0)
      {
        nSelection
          = ((int*)((char*)(& pcBlock->message.data.reserved) + 12))[nDepth];
        if ((gboEditSelected)
          && (nSelection < gasEdit[gnEmailSelected].nMIMEListNum))
        {
          gnAttachmentNum = nSelection;
          SetEditAttachmentDetails (gnEmailSelected, gnAttachmentNum);
          xwimp_create_sub_menu ((wimp_menu*)gwhEdAt,
            ((int*)((char*)(& pcBlock->message.data.reserved) + 4))[0],
            ((int*)((char*)(& pcBlock->message.data.reserved) + 8))[0]);
        }
      }
    }
  }
}

//////////////////////////////////////////////////////////////////
// Set up the details in the edit attachment details window
void SetEditAttachmentDetails (int nEditNum, int nAttachmentNum)
{
  char                        szFileTypeName[FILETYPE_NAME_LEN];
  char                        szIconName[32];
  char                        szIconText[32];
  os_error                    *psError;
  char                        acDate[8];
  unsigned int                uAccess;

  if (nAttachmentNum < gasEdit[nEditNum].nMIMEListNum)
  {
    // Update the gwhEdAt 'info'  window
    SetIconText (gasEdit[nEditNum].asAttachments[nAttachmentNum].szFileName,
      gwhEdAt, (wimp_i)5);

    xmimemaptranslate_filetype_to_filetype_name (
      gasEdit[nEditNum].asAttachments[nAttachmentNum].nFileType,
      szFileTypeName);
    // Filetype name mustn't be longer than FILETYPE_NAME_LEN characters
    szFileTypeName[FILETYPE_NAME_LEN] = 0;

    sprintf (szIconName, "%s (%03x)", szFileTypeName,
      gasEdit[nEditNum].asAttachments[nAttachmentNum].nFileType);
    SetIconText (szIconName, gwhEdAt, (wimp_i)2);

    sprintf (szIconName, "%d",
      gasEdit[nEditNum].asAttachments[nAttachmentNum].nFileSize);
    SetIconText (szIconName, gwhEdAt, (wimp_i)4);

    SetIconText (gasEdit[nEditNum].asAttachments[nAttachmentNum].szFileName,
      gwhEdAt, (wimp_i)5);

    if (gasEdit[nEditNum].asAttachments[nAttachmentNum].boUseAttributes)
    {
      ((unsigned int *)(acDate))[0]
        = gasEdit[nEditNum].asAttachments[nAttachmentNum].uExec;
      ((unsigned int *)(acDate))[1]
        = gasEdit[nEditNum].asAttachments[nAttachmentNum].uLoad;

      szIconText[0] = 0;
      err (xterritory_convert_date_and_time (territory_CURRENT,
        (os_date_and_time const *)((& acDate)), szIconText,
        sizeof (szIconText), ATTACHMENT_INFO_DATE_FORMAT, NULL));
      SetIconText (szIconText, gwhEdAt, (wimp_i)7);

      szIconText[0] = 0;
      uAccess = gasEdit[nEditNum].asAttachments[nAttachmentNum].uAccess;
      if (uAccess & fileswitch_ATTR_OWNER_LOCKED)
      {
        strcat (szIconText, "L");
      }
      if (uAccess & fileswitch_ATTR_OWNER_WRITE)
      {
        strcat (szIconText, "W");
      }
      if (uAccess & fileswitch_ATTR_OWNER_READ)
      {
        strcat (szIconText, "R");
      }
      strcat (szIconText, "/");
      if (uAccess & fileswitch_ATTR_WORLD_WRITE)
      {
        strcat (szIconText, "w");
      }
      if (uAccess & fileswitch_ATTR_WORLD_READ)
      {
        strcat (szIconText, "r");
      }
      SetIconText (szIconText, gwhEdAt, (wimp_i)3);
    }
    else
    {
      SetIconText ("--", gwhEdAt, (wimp_i)7);
      SetIconText ("--", gwhEdAt, (wimp_i)3);
    }

    // Set up the icon
    sprintf (szIconName, "file_%03x",
      gasEdit[nEditNum].asAttachments[nAttachmentNum].nFileType);

    psError = xwimpspriteop_read_sprite_info (szIconName, NULL, NULL, NULL,
      NULL);
    if (psError)
    {
      strcpy (szIconName, "file_xxx");
    }
    SetIconText (szIconName, gwhEdAt, (wimp_i)0);
  }
}

//////////////////////////////////////////////////////////////////
// Attachment save file routine
void SaveAttachment (char * szFilename)
{
  int                         nSizePre;
  int                         nSizePost;
  char                        *pcDecoded;
  int                         nAllocSuccess;
  int                         nStartPos;

  nStartPos
    = gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].nStartPos;
  nSizePre
    = gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].nSizePre;

  // Decode the attachment if necessary and then save it to a file
  switch (gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].eEncoding)
  {
    case CTENCODING_QUOTEDPRINTABLE:
      nSizePost = nSizePre;
      nAllocSuccess = flex_alloc ((flex_ptr)(& pcDecoded), nSizePost);
      if (nAllocSuccess == 1)
      {
        DecodeQuotedPrintable (
          gasDetails[gnEmailSelected].szPreMIMEEmail + nStartPos,
          nSizePre, pcDecoded, & nSizePost);
        err (xosfile_save_stamped (szFilename, gnSaveFileType, pcDecoded,
          pcDecoded + nSizePost));
        if (gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].
          boUseAttributes)
        {
          err (xosfile_write_load (szFilename,
            gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].uLoad));
          err (xosfile_write_exec (szFilename,
            gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].uExec));
          err (xosfile_write_attr (szFilename,
            gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].
            uAccess));
        }
        flex_free ((flex_ptr)(& pcDecoded));
      }
      else
      {
        ShowWarningTag ("Er35");
      }
      break;
    case CTENCODING_BASE64:
      nSizePost = ((nSizePre * 3) / 4) + 3;
      nAllocSuccess = flex_alloc ((flex_ptr)(& pcDecoded), nSizePost);
      if (nAllocSuccess == 1)
      {
        DecodeBase64 (
          gasDetails[gnEmailSelected].szPreMIMEEmail + nStartPos,
          nSizePre, pcDecoded, & nSizePost);
        err (xosfile_save_stamped (szFilename, gnSaveFileType, pcDecoded,
          pcDecoded + nSizePost));
        if (gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].
          boUseAttributes)
        {
          err (xosfile_write_load (szFilename,
            gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].uLoad));
          err (xosfile_write_exec (szFilename,
            gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].uExec));
          err (xosfile_write_attr (szFilename,
            gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].
            uAccess));
        }
        flex_free ((flex_ptr)(& pcDecoded));
      }
      else
      {
        ShowWarningTag ("Er35");
      }
      break;
    case CTENCODING_PLAIN:
    default:
      // Just save out the file
      err (xosfile_save_stamped (szFilename, gnSaveFileType,
        gasDetails[gnEmailSelected].szPreMIMEEmail + nStartPos,
        gasDetails[gnEmailSelected].szPreMIMEEmail + nStartPos + nSizePre));
      if (gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].
        boUseAttributes)
      {
        err (xosfile_write_load (szFilename,
          gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].uLoad));
        err (xosfile_write_exec (szFilename,
          gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].uExec));
        err (xosfile_write_attr (szFilename,
          gasDetails[gnEmailSelected].asMIMEList[gnAttachmentNum].
          uAccess));
      }
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Set the SMTP authentication icon greyness in the accounts window
void SetSMTPAuthGreyness (void)
{
  bool                        boNone;
  bool                        boSame;
  bool                        boRemember;

  boNone = !(GetIconSelectionState (gwhAcct, 28)
    | GetIconSelectionState (gwhAcct, 29)
    | GetIconSelectionState (gwhAcct, 30));
  boSame = GetIconSelectionState (gwhAcct, 31);
  boRemember = GetIconSelectionState (gwhAcct, 34);

  SetIconGreyness (boNone, gwhAcct, 31);

  SetIconGreyness ((boNone | boSame), gwhAcct, 32);
  SetIconGreyness ((boNone | boSame), gwhAcct, 33);
  SetIconGreyness ((boNone | boSame), gwhAcct, 34);

  SetIconGreyness ((boNone | boSame | (!boRemember)), gwhAcct, 35);
  SetIconGreyness ((boNone | boSame | (!boRemember)), gwhAcct, 36);
}

//////////////////////////////////////////////////////////////////
// Encode an MD5 digest for the given data (pcOut is 16 bytes)
void EncodeMD5 (char * pcIn, int nInSize, char * pcOut)
{
  struct MD5Context           sContext;

  MD5Init (& sContext);
  MD5Update (& sContext, pcIn, nInSize);
  MD5Final (pcOut, & sContext);
}

//////////////////////////////////////////////////////////////////
// Encode an hmac-MD5 digest for the given data (pcOut is 16 bytes)
void EncodeHMACMD5 (char * pcIn, int nInSize, char * pcKey, int nKeySize, char * pcOut)
{
  struct MD5Context           sContext;
//  char                        acKeyHashed[16];
  char                        acInPad[65];
  char                        acOutPad[65];
  int                         nPos;

  // if the key length is too long, MD5 hash it
  // or in this case, simply truncate it
  if (nKeySize > 64)
  {
//    EncodeMD5 (pcKey, nKeySize, acKeyHashed);
//    nKeySize = 16;
//    memcpy (pcKey, acKeyHashed, nKeySize);
    nKeySize = 64;
  }

  for (nPos = 0; nPos < 65; nPos++)
  {
    acInPad[nPos] = 0;
    acOutPad[nPos] = 0;
  }
  memcpy (acInPad, pcKey, nKeySize);
  memcpy (acOutPad, pcKey, nKeySize);

  for (nPos = 0; nPos < 64; nPos++)
  {
    acInPad[nPos] ^= 0x36;
    acOutPad[nPos] ^= 0x5c;
  }

  MD5Init (& sContext);
  MD5Update (& sContext, acInPad, 64);
  MD5Update (& sContext, pcIn, nInSize);
  MD5Final (pcOut, & sContext);

  MD5Init (& sContext);
  MD5Update (& sContext, acOutPad, 64);
  MD5Update (& sContext, pcOut, 16);
  MD5Final (pcOut, & sContext);
}

//////////////////////////////////////////////////////////////////
// Respond to a wimp scroll request
void ScrollRequest (wimp_block *pcBlock)
{
  int                         nXScroll;
  int                         nYScroll;
  int                         nPaneHeight = 0;
  int                         nColumnWidth = DEFAULT_X_SCROLL;
  int                         nRowHeight = DEFAULT_Y_SCROLL;
  bool                        boYSnap = FALSE;
  int                         nEditSearch;
  bool                        boWinFound = FALSE;
  wimp_w                      whWindow;

  whWindow = pcBlock->scroll.w;
  nXScroll = pcBlock->scroll.xscroll;
  nYScroll = pcBlock->scroll.yscroll;

  if (whWindow == gwhMain)
  {
    nRowHeight = gnRowHeight;
    nPaneHeight = ROW_YOFFSET;
    boWinFound = TRUE;
    boYSnap = TRUE;
  }

  if (whWindow == gwhAcct)
  {
    nPaneHeight = ACCOUNT_PANE_HEIGHT;
    boWinFound = TRUE;
  }

  if (whWindow == gwhChce)
  {
    nPaneHeight = CHOICES_PANE_HEIGHT;
    boWinFound = TRUE;
  }

  if (whWindow == gwhSett)
  {
    nPaneHeight = SETTINGS_PANE_HEIGHT;
    boWinFound = TRUE;
  }

  if (!boWinFound)
  {
    nPaneHeight = EMAIL_TEXT_Y_OFFSET;

    nEditSearch = 0;
    while ((!boWinFound) && (gawhEditOpen[nEditSearch] != wimp_BACKGROUND))
    {
      if (whWindow == gawhEditOpen[nEditSearch])
      {
        nPaneHeight = gasEdit[ganEditOpen[nEditSearch]].nTextOffset;
        boWinFound = TRUE;
      }
      nEditSearch++;
    }

    nColumnWidth = gnEmailCharWidth;
    nRowHeight = gnEmailRowHeight;
    boWinFound = TRUE;
    boYSnap = TRUE;
  }

  switch (pcBlock->scroll.xmin)
  {
    default:
    case wimp_SCROLL_NONE:
      // Do nothing
      break;
    case wimp_SCROLL_COLUMN_RIGHT:
      nXScroll += nColumnWidth;
      break;
    case wimp_SCROLL_COLUMN_LEFT:
      nXScroll -= nColumnWidth;
      break;
    case wimp_SCROLL_PAGE_RIGHT:
      nXScroll += pcBlock->scroll.visible.x1 - pcBlock->scroll.visible.x0;
      break;
    case wimp_SCROLL_PAGE_LEFT:
      nXScroll -= pcBlock->scroll.visible.x1 - pcBlock->scroll.visible.x0;
      break;
  }
  switch (pcBlock->scroll.ymin)
  {
    default:
    case wimp_SCROLL_NONE:
      // Do nothing
      break;
    case wimp_SCROLL_LINE_UP:
      nYScroll += nRowHeight;
      if (boYSnap)
      {
        nYScroll = ((nYScroll - nRowHeight + 1) / nRowHeight) * nRowHeight;
      }
      break;
    case wimp_SCROLL_LINE_DOWN:
      nYScroll -= nRowHeight;
      if (boYSnap)
      {
        nYScroll = (nYScroll / nRowHeight) * nRowHeight;
      }
      break;
    case wimp_SCROLL_PAGE_UP:
      nYScroll += pcBlock->scroll.visible.y1 - pcBlock->scroll.visible.y0
        - nPaneHeight + PAGE_SCROLL_Y_ADD;
      break;
    case wimp_SCROLL_PAGE_DOWN:
      nYScroll -= pcBlock->scroll.visible.y1 - pcBlock->scroll.visible.y0
        - nPaneHeight + PAGE_SCROLL_Y_ADD;
      break;
  }

  pcBlock->scroll.xscroll = nXScroll;
  pcBlock->scroll.yscroll = nYScroll;

  OpenWindow (pcBlock);
}

//////////////////////////////////////////////////////////////////
// Sets the delete/backspace key type: either OS4, OS5 or guess
void SetDeleteType (DELETETYPE eDeleteType)
{
  int                         nOSVersion;

  geDeleteTypeConfig = eDeleteType;
  switch (eDeleteType)
  {
    case DELETETYPE_OS4:
      gboIyonixDelete = FALSE;
      break;
    case DELETETYPE_OS5:
      gboIyonixDelete = TRUE;
      break;
    default:
    case DELETETYPE_GUESS:
      xosbyte1 (osbyte_IN_KEY, 0, 0xff, & nOSVersion);
      if (nOSVersion >= 0xaa)
      {
        gboIyonixDelete = TRUE;
      }
      else
      {
        gboIyonixDelete = FALSE;
      }
      break;
  }
}

//////////////////////////////////////////////////////////////////
// Find a character in a string of given length
char * strnchr (char * szString, char cChar, int nLength)
{
  char                        *szReturn;

  szReturn = NULL;
  while ((szString[0] != 0) && (nLength > 0))
  {
    if (szString[0] == cChar)
    {
      nLength = 0;
      szReturn = szString;
    }
    szString++;
    nLength--;
  }

  return szReturn;
}

//////////////////////////////////////////////////////////////////
// Find a character in a string of given length ignoring zero terminators
char * strnzchr (char * szString, char cChar, int nLength)
{
  char                        *szReturn;

  szReturn = NULL;
  while (nLength > 0)
  {
    if (szString[0] == cChar)
    {
      nLength = 0;
      szReturn = szString;
    }
    szString++;
    nLength--;
  }

  return szReturn;
}

//////////////////////////////////////////////////////////////////
// Copy a string adding linefeeds
int ConvertString (char * szOutput, char * szInput, int nBufferLen)
{
  int                         nPosTo;
  int                         nPosFrom;

  nPosTo = 0;
  nPosFrom = 0;
  while ((szInput[nPosFrom] >= 32) && (nPosTo < (nBufferLen - 1)))
  {
    if (szInput[nPosFrom] == '\\')
    {
      nPosFrom++;
      if (szInput[nPosFrom] == 'n')
      {
        szOutput[nPosTo] = '\n';
        nPosFrom++;
      }
      else
      {
        if (szInput[nPosFrom] != 0)
        {
          szOutput[nPosTo] = '\\';
          nPosFrom++;
        }
      }
    }
    else
    {
      szOutput[nPosTo] = szInput[nPosFrom];
      nPosFrom++;
    }
    nPosTo++;
  }
  szOutput[nPosTo] = 0;

  return nPosTo;
}

//////////////////////////////////////////////////////////////////
// Update the edit window 'attachments' (18) icon
void EditAttachmentsIconUpdate (int nEditNum)
{
  sprintf (gasEdit[nEditNum].szAttachNum, "%d",
    gasEdit[nEditNum].nMIMEListNum);
  SetIconGreyness ((gasEdit[nEditNum].nMIMEListNum == 0),
    gasEdit[nEditNum].whHead, 18);
}

//////////////////////////////////////////////////////////////////
// Add a file to an edit windows attachment list
bool AddFileToAttachmentsListFlex (int nEditNum, char * szFileName, int nFileType, char * * ppcStartFile, int nFileSize, bool boUseAttributes, unsigned int uLoad, unsigned int uExec, unsigned int uAccess)
{
  MIMEEditDetails             *psMIMEEdit;
  char                        szNumber[6];
  bool                        boSuccess;

  boSuccess = FALSE;
  if (gasEdit[nEditNum].nMIMEListNum < ATTACHMENT_EDIT_MAX)
  {
    // Add the attachment to the attachment list
    psMIMEEdit = & gasEdit[nEditNum].asAttachments
      [gasEdit[nEditNum].nMIMEListNum];
    FreeMIMEEditDetails (psMIMEEdit);
    strncpy (psMIMEEdit->szFileName, szFileName, MIME_FILENAME_MAX);
    strncpy (psMIMEEdit->szLeafName, FindLeafName (szFileName),
      MIME_LEAFNAME_MAX);
    psMIMEEdit->nFileType = nFileType;

    if (ppcStartFile)
    {
      flex_reanchor ((flex_ptr)(& psMIMEEdit->pcFileStart),
        (flex_ptr)(ppcStartFile));
      * ppcStartFile = NULL;
    }

    psMIMEEdit->nFileSize = nFileSize;
    psMIMEEdit->boUseAttributes = boUseAttributes;
    if (boUseAttributes)
    {
      psMIMEEdit->uLoad = uLoad;
      psMIMEEdit->uExec = uExec;
      psMIMEEdit->uAccess = uAccess;
    }

    gasEdit[nEditNum].nMIMEListNum++;
    REPORTVAR ("Total attachments: %d", gasEdit[nEditNum].nMIMEListNum);
    EditAttachmentsIconUpdate (nEditNum);
    EditChanged (nEditNum);

    boSuccess = TRUE;
  }
  else
  {
    sprintf(szNumber, "%d", ATTACHMENT_EDIT_MAX);
    ShowWarningTagArg ("Er41", szNumber);
  }

  return boSuccess;
}

//////////////////////////////////////////////////////////////////
// Remove a file from an edit windows attachment list
void RemoveFileFromAttachmentsList (int nEditNum, int nAttachmentNum)
{
  int                         nSuccess;
  int                         nCount;

  if (nAttachmentNum == (gasEdit[nEditNum].nMIMEListNum - 1))
  {
    FreeMIMEEditDetails (& gasEdit[nEditNum].asAttachments[nAttachmentNum]);
  }
  else
  {
    // Shift all of the attachments above that to be removed down one
    for (nCount = nAttachmentNum; nCount <
      (gasEdit[nEditNum].nMIMEListNum - 1); nCount++)
    {
      nSuccess = MoveMIMEEditDetails (& gasEdit[nEditNum].asAttachments
        [nCount], & gasEdit[nEditNum].asAttachments[(nCount + 1)]);
      if (nSuccess == 0)
      {
        ShowWarningTag ("Er44");
      }
    }
  }
  gasEdit[nEditNum].nMIMEListNum--;
  REPORTVAR ("Total attachments: %d", gasEdit[nEditNum].nMIMEListNum);
  EditChanged (nEditNum);
  EditAttachmentsIconUpdate (nEditNum);
}
